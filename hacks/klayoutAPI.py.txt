class Box:
    '''@brief A box class with integer coordinates

    This object represents a box (a rectangular shape).

    The definition of the attributes is: p1 is the lower left point, p2 the  upper right one. If a
    box is constructed from two points (or four coordinates), the  coordinates are sorted
    accordingly.

    A box can be empty. An empty box represents no area (not even a point). Empty boxes behave
    neutral with respect to most operations.  Empty boxes return true on \\empty?.

    A box can be a point or a single line. In this case, the area is zero but the box still can
    overlap other boxes for example and it is not empty.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the bottom coordinate of the box

     @brief Sets the bottom coordinate of the box @args c'''
    bottom = None

    '''@brief Gets the left coordinate of the box

     @brief Sets the left coordinate of the box @args c'''
    left = None

    '''@brief Gets the lower left point of the box

     @brief Sets the lower left point of the box @args p'''
    p1 = None

    '''@brief Gets the upper right point of the box

     @brief Sets the upper right point of the box @args p'''
    p2 = None

    '''@brief Gets the right coordinate of the box

     @brief Sets the right coordinate of the box @args c'''
    right = None

    '''@brief Gets the top coordinate of the box

     @brief Sets the top coordinate of the box @args c'''
    top = None

    # Methods
    def __add__(self, ...):
        '''@brief Joins two boxes

        @args box

        The + operator joins the first box with the one given as  the second argument. Joining
        constructs a box that encloses both boxes given. Empty boxes are neutral: they do not change
        another box when joining. Overwrites this box with the result.

        @param box The box to join with this box.

        @return The joined box'''

    def __and__(self, ...):
        '''@brief Returns the intersection of this box with another box

        @args box

        The intersection of two boxes is the largest box common to both boxes. The intersection may
        be  empty if both boxes to not touch. If the boxes do not overlap but touch the result may
        be a single line or point with an area of zero. Overwrites this box with the result.

        @param box The box to take the intersection with

        @return The intersection box'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Returns true if this box is equal to the other box @args box Returns true, if this
        box and the given box are equal '''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given box. This method enables
        boxes as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a box from two points

        @args lower_left, upper_right

        Two points are given to create a new box. If the coordinates are not provided in the correct
        order (i.e. right < left), these are swapped.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Returns true if this box is 'less' than another box @args box Returns true, if
        this box is 'less' with respect to first and second point (in this order)'''

    def __mul__(self, ...):
        '''@brief Returns the scaled box

        @args scale_factor

        The * operator scales the box with the given factor and returns the result.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled box'''

    def __ne__(self, ...):
        '''@brief Returns true if this box is not equal to the other box @args box Returns true, if
        this box and the given box are not equal '''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Returns a string representing this box

        This string can be turned into a box again by using \\from_s'''

    def __rmul__(self, ...):
        '''@brief Returns the scaled box

        @args scale_factor

        The * operator scales the box with the given factor and returns the result.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled box'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Returns a string representing this box

        This string can be turned into a box again by using \\from_s'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief Computes the box area

        Returns the box area or 0 if the box is empty'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def center(self, ...):
        '''@brief Gets the center of the box'''

    def contains(self, ...):
        '''@brief Returns true if the box contains the given point

        @args point Tests whether a point is inside the box. It also returns true if the point is
        exactly on the box contour.

        @param p The point to test against.

        @return true if the point is inside the box.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def empty(self, ...):
        '''@brief Returns a value indicating whether the box is empty

        An empty box may be created with the default constructor for example. Such a box is neutral
        when combining it with other boxes and renders empty boxes if used in box intersections and
        false in geometrical relationship tests. '''

    def enlarge(self, ...):
        '''@brief Enlarges the box by a certain amount.

        @args enlargement

        Enlarges the box by x and y value specified in the vector passed. Positive values with grow
        the box, negative ones will shrink the box. The result may be an empty box if the box
        disappears. The amount specifies the grow or shrink per edge. The width and height will
        change by twice the amount. Does not check for coordinate overflows.

        @param enlargement The grow or shrink amount in x and y direction

        @return A reference to this box.'''

    def enlarged(self, ...):
        '''@brief Returns the enlarged box.

        @args enlargement

        Enlarges the box by x and y value specified in the vector passed. Positive values with grow
        the box, negative ones will shrink the box. The result may be an empty box if the box
        disappears. The amount specifies the grow or shrink per edge. The width and height will
        change by twice the amount. Does not modify this box. Does not check for coordinate
        overflows.

        @param enlargement The grow or shrink amount in x and y direction

        @return The enlarged box.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given box. This method enables
        boxes as hash keys.

        This method has been introduced in version 0.25.'''

    def height(self, ...):
        '''@brief Gets the height of the box'''

    def inside(self, ...):
        '''@brief Tests if this box is inside the argument box

        @args box

        Returns true, if this box is inside the given box, i.e. the box intersection renders this
        box'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_point(self, ...):
        '''@brief Returns true, if the box is a single point'''

    def move(self, ...):
        '''@brief Moves the box by a certain distance

        @args distance

        Moves the box by a given offset and returns the moved box. Does not check for coordinate
        overflows.

        @param distance The offset to move the box.

        @return A reference to this box.'''

    def moved(self, ...):
        '''@brief Returns the box moved by a certain distance

        @args distance

        Moves the box by a given offset and returns the moved box. Does not modify this box. Does
        not check for coordinate overflows.

        @param distance The offset to move the box.

        @return The moved box.'''

    def overlaps(self, ...):
        '''@brief Tests if this box overlaps the argument box

        @args box

        Returns true, if the intersection box of this box with the argument box exists and has a
        non-vanishing area'''

    def perimeter(self, ...):
        '''@brief Returns the perimeter of the box

        This method is equivalent to 2*(width+height). For empty boxes, this method returns 0.

        This method has been introduced in version 0.23.'''

    def to_dtype(self, ...):
        '''@brief Converts the box to a floating-point coordinate box

        The database unit can be specified to translate the integer-coordinate box into a floating-
        point coordinate box in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Returns a string representing this box

        This string can be turned into a box again by using \\from_s'''

    def touches(self, ...):
        '''@brief Tests if this box touches the argument box

        @args box

        Two boxes touch if they overlap or their boundaries share at least one common point.
        Touching is equivalent to a non-empty intersection ('!(b1 & b2).empty?').'''

    def transformed(self, ...):
        '''@brief Returns the box transformed with the given complex transformation

        @args t

        @param t The magnifying transformation to apply @return The transformed box (a DBox now)'''

    def width(self, ...):
        '''@brief Gets the width of the box'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_dbox(cls, ...):
        '''@brief Creates an integer coordinate box from a floating-point coordinate box

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dbox'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates a box object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a box from two points

        @args lower_left, upper_right

        Two points are given to create a new box. If the coordinates are not provided in the correct
        order (i.e. right < left), these are swapped.'''


class Cell:
    '''@brief A cell

    A cell object consists of a set of shape containers (called layers), a set of child cell
    instances and auxiliary informations such as the parent instance list. A cell is identified
    through an index given to the cell upon instantiation. Cell instances refer to single instances
    or array instances. Both are encapsulated in the same object, the \\CellInstArray object. In the
    simple case, this object refers to a single instance. In the general case, this object may refer
    to a regular array of cell instances as well.

    Starting from version 0.16, the child_inst and erase_inst methods are no longer available since
    they were using index addressing which is no longer supported. Instead, instances are now
    addressed with the \\Instance reference objects.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects like the Cell class. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Sets the "ghost cell" flag @args flag

    See \\is_ghost_cell? for a description of this property.

    This method has been introduced in version 0.20.'''
    ghost_cell = None

    '''@brief Gets the cell's name

    This method has been introduced in version 0.22.

     @brief Renames the cell @args name Renaming a cell may cause name clashes, i.e. the name may be
    identical to the name of another cell. This does not have any immediate effect, but the cell
    needs to be renamed, for example when writing the layout to a GDS file.

    This method has been introduced in version 0.22.'''
    name = None

    '''@brief Gets the properties ID associated with the cell

    This method has been introduced in version 0.23.

    @brief Sets the properties ID associated with the cell @args id This method is provided, if a
    properties ID has been derived already. Usually it's more convenient to use \\delete_property,
    \\set_property or \\property.

    This method has been introduced in version 0.23.'''
    prop_id = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def basic_name(self, ...):
        '''@brief Returns the name of the library or PCell or the real name of the cell For non-
        proxy cells (see \\is_proxy?), this method simply returns the cell name. For proxy cells,
        this method returns the PCell's definition name or the library cell name. This name may
        differ from the actual cell's name because to ensure that cell names are unique, KLayout may
        assign different names to the actual  cell compared to the source cell.

        This method has been introduced in version 0.22.'''

    def bbox(self, ...):
        '''@brief Gets the bounding box of the cell

        @return The bounding box of the cell

        The bounding box is computed over all layers. To compute the bounding box over single
        layers, use \\bbox_per_layer.'''

    def bbox_per_layer(self, ...):
        '''@brief Gets the per-layer bounding box of the cell @args layer_index

        @return The bounding box of the cell considering only the given layer

        The bounding box is the box enclosing all shapes on the given layer.'''

    def begin_shapes_rec(self, ...):
        '''@brief Delivers a recursive shape iterator for the shapes below the cell on the given
        layer @args layer @param layer The layer from which to get the shapes @return A suitable
        iterator

        For details see the description of the \\RecursiveShapeIterator class.

        This method has been added in version 0.23.'''

    def begin_shapes_rec_overlapping(self, ...):
        '''@brief Delivers a recursive shape iterator for the shapes below the cell on the given
        layer using a region search, with the region given in micrometer units @param layer The
        layer from which to get the shapes @param region The search region as \\DBox object in
        micrometer units @return A suitable iterator

        For details see the description of the \\RecursiveShapeIterator class. This version gives an
        iterator delivering shapes whose bounding box overlaps the given region.

        This variant has been added in version 0.25.'''

    def begin_shapes_rec_touching(self, ...):
        '''@brief Delivers a recursive shape iterator for the shapes below the cell on the given
        layer using a region search, with the region given in micrometer units @param layer The
        layer from which to get the shapes @param region The search region as \\DBox object in
        micrometer units @return A suitable iterator

        For details see the description of the \\RecursiveShapeIterator class. This version gives an
        iterator delivering shapes whose bounding box touches the given region.

        This variant has been added in version 0.25.'''

    def called_cells(self, ...):
        '''@brief Gets a list of all called cells

        This method determines all cells which are called either directly or indirectly by the cell.
        It returns an array of cell indexes. Use the 'cell' method of \\Layout to retrieve the
        corresponding Cell object.

        This method has been introduced in version 0.19.

        @return A list of cell indices.'''

    def caller_cells(self, ...):
        '''@brief Gets a list of all caller cells

        This method determines all cells which call this cell either directly or indirectly. It
        returns an array of cell indexes. Use the 'cell' method of \\Layout to retrieve the
        corresponding Cell object.

        This method has been introduced in version 0.19.

        @return A list of cell indices.'''

    def cell_index(self, ...):
        '''@brief Gets the cell index

        @return The cell index of the cell'''

    def change_pcell_parameter(self, ...):
        '''@brief Changes a single parameter for an individual PCell instance given by name @args
        instance, name, value @return The new instance (the old may be invalid) This will set the
        PCell parameter named 'name' to the given value for the instance addressed by 'instance'. If
        no parameter with that name exists, the method will do nothing.

        This method has been introduced in version 0.23.'''

    def change_pcell_parameters(self, ...):
        '''@brief Changes the parameters for an individual PCell instance @args instance, parameters
        @return The new instance (the old may be invalid) If necessary, this method creates a new
        variant and replaces the given instance by an instance of this variant.

        The parameters are given in the order the parameters are declared. Use \\pcell_declaration
        on the instance to get the PCell declaration object of the cell. That PCellDeclaration
        object delivers the parameter declaration with it's 'get_parameters' method. Each parameter
        in the variant list passed to the second list of values corresponds to one parameter
        declaration.

        There is a more convenient method (\\change_pcell_parameter) that changes a single parameter
        by name.

        This method has been introduced in version 0.22.'''

    def child_cells(self, ...):
        '''@brief Gets the number of child cells

        The number of child cells (not child instances!) is returned. CAUTION: this method is SLOW,
        in particular if many instances are present.'''

    def child_instances(self, ...):
        '''@brief Gets the number of child instances

        @return Returns the number of cell instances'''

    def clear(self, ...):
        '''@brief Clears the cell (deletes shapes and instances) This method has been introduced in
        version 0.23.'''

    def clear_insts(self, ...):
        '''@brief Clears the instance list'''

    def clear_shapes(self, ...):
        '''@brief Clears all shapes in the cell'''

    def copy(self, ...):
        '''@brief Copies shapes from another cell to the target layern this cell @args src_cell,
        src_layer, dest

        This method will copy all shapes on layer 'src_layer' of cell 'src_cell' to the layer 'dest'
        of this cell. The destination layer is not overwritten. Instead, the shapes are added to the
        shapes of the destination layer. If the source cell lives in a layout with a different
        database unit than that current cell is in, the shapes will be transformed accordingly. The
        same way, shape properties are transformed as well. Note that the shape transformation may
        require rounding to smaller coordinates. This may result in a slight distortion of the
        original shapes, in particular when transforming into a layout with a bigger database unit.
        @param src_cell The cell where to take the shapes from @param src_layer The layer index of
        the layer from which to take the shapes @param dest The layer index of the destination
        layer'''

    def copy_instances(self, ...):
        '''@brief Copies the instances of child cells in the source cell to this cell @args
        source_cell @param source_cell The cell where the instances are copied from The source cell
        must reside in the same layout than this cell. The instances of child cells inside the
        source cell are copied to this cell. No new cells are created, just new instances are
        created to already existing cells in the target cell.

        The instances will be added to any existing instances in the cell.

        More elaborate methods of copying hierarchy trees between layouts or duplicating trees are
        provided through the \\copy_tree_shapes (in cooperation with the \\CellMapping class) or
        \\copy_tree methods.

        This method has been added in version 0.23.'''

    def copy_shapes(self, ...):
        '''@brief Copies the shapes from the given cell into this cell @args source_cell,
        layer_mapping @param source_cell The cell from where to copy shapes @param layer_mapping A
        \\LayerMapping object that specifies which layers are copied and where All shapes on layers
        specified in the layer mapping object are copied from the source cell to this cell.
        Instances are not copied. The target layer is taken from the mapping table.

        The shapes will be added to any shapes already in the cell.

        This method has been added in version 0.23.'''

    def copy_tree(self, ...):
        '''@brief Copies the cell tree of the given cell into this cell @args source_cell @param
        source_cell The cell from where to copy the cell tree @return A list of indexes of newly
        created cells The complete cell tree of the source cell is copied to the target cell plus
        all shapes in that tree are copied as well. This method will basically duplicate the cell
        tree of the source cell.

        The source cell may reside in a separate layout. This method therefore provides a way to
        copy over complete cell trees from one layout to another.

        The shapes and instances will be added to any shapes or instances already in the cell.

        This method has been added in version 0.23.'''

    def copy_tree_shapes(self, ...):
        '''@brief Copies the shapes from the given cell and the cell tree below into this cell or
        subcells of this cell with layer mapping @args source_cell, cell_mapping, layer_mapping
        @param source_cell The cell from where to copy shapes and instances @param cell_mapping The
        cell mapping object that determines how cells are identified between source and target
        layout

        This method is provided if source and target cell reside in different layouts. If will copy
        the shapes from all cells below the given source cell, but use a cell mapping object that
        provides a specification how cells are identified between the layouts. Cells in the source
        tree, for which no mapping is provided, will be flattened - their shapes will be propagated
        into parent cells for which a mapping is provided.

        The cell mapping object provides various methods to map cell trees between layouts. See the
        \\CellMapping class for details about the mapping methods available. The cell mapping object
        is also responsible for creating a proper hierarchy of cells in the target layout if that is
        required.

        In addition, the layer mapping object can be specified which maps source to target layers.
        This feature can be used to restrict the copy operation to a subset of layers or to convert
        shapes to different layers in that step.

        The shapes copied will be added to any shapes already in the cells.

        This method has been added in version 0.23.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def dbbox(self, ...):
        '''@brief Gets the bounding box of the cell in micrometer units

        @return The bounding box of the cell

        The bounding box is computed over all layers. To compute the bounding box over single
        layers, use \\dbbox_per_layer.

        This method has been introduced in version 0.25.'''

    def dbbox_per_layer(self, ...):
        '''@brief Gets the per-layer bounding box of the cell in micrometer units

        @return The bounding box of the cell considering only the given layer

        The bounding box is the box enclosing all shapes on the given layer.

        This method has been introduced in version 0.25.'''

    def delete(self, ...):
        '''@brief Deletes this cell

        This deletes the cell but not the sub cells of the cell. These subcells will likely become
        new top cells unless they are used otherwise. All instances of this cell are deleted as
        well. Hint: to delete multiple cells, use "delete_cells" which is  far more efficient in
        this case.

        After the cell has been deleted, the Cell object becomes invalid. Do not access methods or
        attributes of this object after deleting the cell.

        This method has been introduced in version 0.23.'''

    def delete_property(self, ...):
        '''@brief Deletes the user property with the given key @args key This method is a
        convenience method that deletes the property with the given key. It does nothing if no
        property with that key exists. Using that method is more convenient than creating a new
        property set with a new ID and assigning that properties ID. This method may change the
        properties ID.

        This method has been introduced in version 0.23.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def display_title(self, ...):
        '''@brief Returns a nice looking name for display purposes

        For example, this name include PCell parameters for PCell proxy cells.

        This method has been introduced in version 0.22.'''

    def dump_mem_statistics(self, ...):
        '''@hide'''

    def each_child_cell(self, ...):
        '''@brief Iterates over all child cells

        This iterator will report the child cell indices, not every instance.'''

    def each_inst(self, ...):
        '''@brief Iterates over all child instances (which may actually be instance arrays)

        Starting with version 0.15, this iterator delivers \\Instance objects rather than
        \\CellInstArray objects.'''

    def each_overlapping_inst(self, ...):
        '''@brief Gets the instances overlapping the given rectangle, with the rectangle in
        micrometer units

        This will iterate over all child cell instances overlapping with the given rectangle b. This
        method is identical to the \\each_overlapping_inst version that takes a \\Box object, but
        instead of taking database unit coordinates in will take a micrometer unit \\DBox object.

        @param b The region to iterate over

        This variant has been introduced in version 0.25.'''

    def each_overlapping_shape(self, ...):
        '''@brief Iterates over all shapes of a given layer that overlap the given box, with the box
        given in micrometer units

        @param box The box by which to query the shapes as a \\DBox object in micrometer units
        @param layer_index The layer on which to run the query

        This call is equivalent to each_overlapping_shape(layer_index,box,RBA::Shapes::SAll). This
        convenience method has been introduced in version 0.16.'''

    def each_parent_cell(self, ...):
        '''@brief Iterates over all parent cells

        This iterator will iterate over the parent cells, just returning their cell index.'''

    def each_parent_inst(self, ...):
        '''@brief Iterates over the parent instance list (which may actually be instance arrays)

        The parent instances are basically inversions of the instances. Using parent instances it is
        possible to determine how a specific cell is called from where.'''

    def each_shape(self, ...):
        '''@brief Iterates over all shapes of a given layer @args layer_index

        @param layer_index The layer on which to run the query

        This call is equivalent to each_shape(layer_index,RBA::Shapes::SAll). This convenience
        method has been introduced in version 0.16.'''

    def each_touching_inst(self, ...):
        '''@brief Gets the instances touching the given rectangle, with the rectangle in micrometer
        units

        This will iterate over all child cell instances touching the given rectangle b. This method
        is identical to the \\each_touching_inst version that takes a \\Box object, but instead of
        taking database unit coordinates in will take a micrometer unit \\DBox object.

        @param b The region to iterate over

        This variant has been introduced in version 0.25.'''

    def each_touching_shape(self, ...):
        '''@brief Iterates over all shapes of a given layer that touch the given box, with the box
        given in micrometer units

        @param box The box by which to query the shapes as a \\DBox object in micrometer units
        @param layer_index The layer on which to run the query

        This call is equivalent to each_touching_shape(layer_index,box,RBA::Shapes::SAll). This
        convenience method has been introduced in version 0.16.'''

    def erase(self, ...):
        '''@brief Erases the instance given by the Instance object @args inst

        This method has been introduced in version 0.16. It can only be used in editable mode.'''

    def fill_region(self, ...):
        '''@brief Fills the given region with cells of the given type (extended version) @args
        region, fill_cell_index, fc_box, origin, remaining_parts, fill_margin, remaining_polygons
        @param region The region to fill @param fill_cell_index The fill cell to place @param fc_box
        The fill cell's footprint @param origin The global origin of the fill pattern or nil to
        allow local (per-polygon) optimization @param remaining_parts See explanation below @param
        fill_margin See explanation below @param remaining_polygons See explanation below

        First of all, this method behaves like the simple form. In addition, it can be configured to
        return information about the parts which could not be filled. Those can be full polygons
        from the input (without a chance to fill) or parts of original polygons which are worth
        being fed into the fill algorithm again.

        If the 'remaining_parts' argument is non-nil, the corresponding region will receive the
        parts of the polygons which are not covered by tiles. Basically the tiles are subtracted
        from the original polygons. A margin can be specified which is applied separately in x and y
        direction before the subtraction is done ('fill_margin' parameter).

        If the 'remaining_polygons' argument is non-nil, the corresponding region will receive all
        polygons from the input region which could not be filled and where there is no chance of
        filling because not a single tile will fit into them.

        'remaining_parts' and 'remaining_polygons' can be identical with the input. In that case the
        input will be overwritten with the respective output. Otherwise, the respective polygons are
        added to these regions.

        This allows to set up a more elaborate fill scheme using multiple iterations and local
        origin-optimization ('origin' is nil):

        @code r = ...        # region to fill c = ...        # cell in which to produce the fill
        cells fc_index = ... # fill cell index fc_box = ...   # fill cell footprint

        fill_margin = RBA::Point::new(0, 0)   # x/y distance between tile cells with different
        origin

        # Iteration: fill a region and fill the remaining parts as long as there is anything left. #
        Polygons not worth being considered further are dropped (last argument is nil). while
        !r.is_empty?   c.fill_region(r, fc_index, fc_box, nil, r, fill_margin, nil) end @/code

        This method has been introduced in version 0.23.'''

    def flatten(self, ...):
        '''@brief Flattens the given cell @args levels, prune

        This method propagates all shapes from the specified number of hierarchy levels below into
        the given cell. It also removes the instances of the cells from which the shapes came from,
        but does not remove the cells themselves if prune is set to false. If prune is set to true,
        these cells are removed if not used otherwise.

        @param levels The number of hierarchy levels to flatten (-1: all, 0: none, 1: one level
        etc.) @param prune Set to true to remove orphan cells.

        This method has been introduced in version 0.23.'''

    def has_prop_id(self, ...):
        '''@brief Returns true, if the cell has user properties

        This method has been introduced in version 0.23.'''

    def hierarchy_levels(self, ...):
        '''@brief Returns the number of hierarchy levels below

        This method returns the number of call levels below the current cell. If there are no child
        cells, this method will return 0, if there are only direct children, it will return 1.

        CAUTION: this method may be expensive!'''

    def insert(self, ...):
        '''@brief Inserts a cell instance (array) with properties @return An \\Instance object
        representing the new instance The property Id must be obtained from the \\Layout object's
        property_id method which associates a property set with a property Id. With version 0.16,
        this method returns an Instance object that represents the new instance. It's use is
        discouraged in readonly mode, since it invalidates other Instance references.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_empty(self, ...):
        '''@brief Returns a value indicating whether the cell is empty

        An empty cell is a cell not containing instances nor any shapes.

        This method has been introduced in version 0.20.'''

    def is_ghost_cell(self, ...):
        '''@brief Returns a value indicating whether the cell is a "ghost cell"

        The ghost cell flag is used by the GDS reader for example to indicate that the cell is not
        located inside the file. Upon writing the reader can determine whether to write the cell or
        not. To satisfy the references inside the layout, a dummy cell is created in this case which
        has the "ghost cell" flag set to true.

        This method has been introduced in version 0.20.'''

    def is_leaf(self, ...):
        '''@brief Gets a value indicating whether the cell is a leaf cell

        A cell is a leaf cell if there are no child instantiations.'''

    def is_library_cell(self, ...):
        '''@brief Returns true, if the cell is a proxy cell pointing to a library cell If the cell
        is imported from some library, this attribute returns true. Please note, that this attribute
        can combine with \\is_pcell? for PCells imported from a library.

        This method has been introduced in version 0.22.'''

    def is_pcell_variant(self, ...):
        '''@brief Returns true, if this instance is a PCell variant @args instance This method
        returns true, if this instance represents a PCell with a distinct set of parameters. This
        method also returns true, if it is a PCell imported from a library.

        This method has been introduced in version 0.22.'''

    def is_proxy(self, ...):
        '''@brief Returns true, if the cell presents some external entity    A cell may represent
        some data which is imported from some other source, i.e. a library. Such cells are called
        "proxy cells". For a library reference, the proxy cell is some kind of pointer to the
        library and the cell within the library.

        For PCells, this data can even be computed through some script. A PCell proxy represents all
        instances with a given set of parameters.

        Proxy cells cannot be modified, except that pcell parameters can be modified and PCell
        instances can be recomputed.

        This method has been introduced in version 0.22.'''

    def is_top(self, ...):
        '''@brief Gets a value indicating whether the cell is a top-level cell

        A cell is a top-level cell if there are no parent instantiations.'''

    def is_valid(self, ...):
        '''@brief Tests if the given \\Instance object is still pointing to a valid object @args
        instance This method has been introduced in version 0.16. If the instance represented by the
        given reference has been deleted, this method returns false. If however, another instance
        has been inserted already that occupies the original instances position, this method will
        return true again.'''

    def layout(self, ...):
        '''@brief Returns a reference to the layout where the cell resides (const references)

        this method has been introduced in version 0.22.'''

    def library(self, ...):
        '''@brief Returns a reference to the library from which the cell is imported if the cell is
        not imported from a library, this reference is nil.

        this method has been introduced in version 0.22.'''

    def library_cell_index(self, ...):
        '''@brief Returns the index of the cell in the layout of the library (if it's a library
        proxy) Together with the \\library method, it is possible to locate the source cell of a
        library proxy. The source cell can be retrieved from a cell "c" with

        @code c.library.layout.cell(c.library_cell_index) @/code

        This cell may be itself a proxy, i.e. for pcell libraries, where the library cells are pcell
        variants which itself are proxies to a pcell.

        This method has been introduced in version 0.22.'''

    def move(self, ...):
        '''@brief Moves shapes from another cell to the target layern this cell @args src_cell,
        src_layer, dest

        This method will move all shapes on layer 'src_layer' of cell 'src_cell' to the layer 'dest'
        of this cell. The destination layer is not overwritten. Instead, the shapes are added to the
        shapes of the destination layer. If the source cell lives in a layout with a different
        database unit than that current cell is in, the shapes will be transformed accordingly. The
        same way, shape properties are transformed as well. Note that the shape transformation may
        require rounding to smaller coordinates. This may result in a slight distortion of the
        original shapes, in particular when transforming into a layout with a bigger database unit.
        @param src_cell The cell where to take the shapes from @param src_layer The layer index of
        the layer from which to take the shapes @param dest The layer index of the destination
        layer'''

    def move_instances(self, ...):
        '''@brief Moves the instances of child cells in the source cell to this cell @args
        source_cell @param source_cell The cell where the instances are moved from The source cell
        must reside in the same layout than this cell. The instances of child cells inside the
        source cell are moved to this cell. No new cells are created, just new instances are created
        to already existing cells in the target cell.

        The instances will be added to any existing instances in the cell.

        More elaborate methods of moving hierarchy trees between layouts are provided through the
        \\move_tree_shapes (in cooperation with the \\CellMapping class) or \\move_tree methods.

        This method has been added in version 0.23.'''

    def move_shapes(self, ...):
        '''@brief Moves the shapes from the given cell into this cell @args source_cell,
        layer_mapping @param source_cell The cell from where to move shapes @param layer_mapping A
        \\LayerMapping object that specifies which layers are moved and where All shapes on layers
        specified in the layer mapping object are moved from the source cell to this cell. Instances
        are not moved. The target layer is taken from the mapping table.

        The shapes will be added to any shapes already in the cell.

        This method has been added in version 0.23.'''

    def move_tree(self, ...):
        '''@brief Moves the cell tree of the given cell into this cell @args source_cell @param
        source_cell The cell from where to move the cell tree @return A list of indexes of newly
        created cells The complete cell tree of the source cell is moved to the target cell plus all
        shapes in that tree are moved as well. This method will basically rebuild the cell tree of
        the source cell and empty the source cell.

        The source cell may reside in a separate layout. This method therefore provides a way to
        move over complete cell trees from one layout to another.

        The shapes and instances will be added to any shapes or instances already in the cell.

        This method has been added in version 0.23.'''

    def move_tree_shapes(self, ...):
        '''@brief Moves the shapes from the given cell and the cell tree below into this cell or
        subcells of this cell with layer mapping @args source_cell, cell_mapping, layer_mapping
        @param source_cell The cell from where to move shapes and instances @param cell_mapping The
        cell mapping object that determines how cells are identified between source and target
        layout

        This method is provided if source and target cell reside in different layouts. If will move
        the shapes from all cells below the given source cell, but use a cell mapping object that
        provides a specification how cells are identified between the layouts. Cells in the source
        tree, for which no mapping is provided, will be flattened - their shapes will be propagated
        into parent cells for which a mapping is provided.

        The cell mapping object provides various methods to map cell trees between layouts. See the
        \\CellMapping class for details about the mapping methods available. The cell mapping object
        is also responsible for creating a proper hierarchy of cells in the target layout if that is
        required.

        In addition, the layer mapping object can be specified which maps source to target layers.
        This feature can be used to restrict the move operation to a subset of layers or to convert
        shapes to different layers in that step.

        The shapes moved will be added to any shapes already in the cells.

        This method has been added in version 0.23.'''

    def parent_cells(self, ...):
        '''@brief Gets the number of parent cells

        The number of parent cells (cells which reference our cell) is reported.'''

    def pcell_declaration(self, ...):
        '''@brief Returns the PCell declaration of a pcell instance @args instance If the instance
        is not a PCell instance, this method returns nil. The \\PCellDeclaration object allows to
        retrieve PCell parameter definitions for example.

        This method has been introduced in version 0.22.'''

    def pcell_id(self, ...):
        '''@brief Returns the PCell ID if the cell is a pcell variant This method returns the ID
        which uniquely identifies the PCell within the  layout where it's declared. It can be used
        to retrieve the PCell declaration  or to create new PCell variants.

        The method will be rarely used. It's more convenient to use \\pcell_declaration to directly
        retrieve the PCellDeclaration object for example.

        This method has been introduced in version 0.22.'''

    def pcell_library(self, ...):
        '''@brief Returns the library where the PCell is declared if this cell is a PCell and it is
        not defined locally. A PCell often is not declared within the current layout but in some
        library.  This method returns a reference to that library, which technically is the last of
        the  chained library proxies. If this cell is not a PCell or it is not located in a
        library, this method returns nil.

        This method has been introduced in version 0.22.'''

    def pcell_parameter(self, ...):
        '''@brief Returns a PCell parameter by name for a pcell instance

        If the given instance is a PCell instance, this method returns the value of the PCell
        parameter with the given name. If the instance is not a PCell instance or the name is not a
        valid PCell parameter name, this method returns nil.

        This method has been introduced in version 0.25.'''

    def pcell_parameters(self, ...):
        '''@brief Returns the PCell parameters for a pcell instance @args instance If the given
        instance is a PCell instance, this method returns a list of values for the PCell parameters.
        If the instance is not a PCell instance, this method returns an empty list.

        This method has been introduced in version 0.22.'''

    def pcell_parameters_by_name(self, ...):
        '''@brief Returns the PCell parameters for a pcell instance as a name to value dictionary
        @args instance If the given instance is a PCell instance, this method returns a dictionary
        of values for the PCell parameters with the parameter names as the keys. If the instance is
        not a PCell instance, this method returns an empty dictionary.

        This method has been introduced in version 0.24.'''

    def property(self, ...):
        '''@brief Gets the user property with the given key @args key This method is a convenience
        method that gets the property with the given key. If no property with that key exists, it
        will return nil. Using that method is more convenient than using the layout object and the
        properties ID to retrieve the property value.  This method has been introduced in version
        0.23.'''

    def prune_cell(self, ...):
        '''@brief Deletes the cell plus subcells not used otherwise @args levels

        This deletes the cell and also all sub cells of the cell which are not used otherwise. The
        number of hierarchy levels to consider can be specified as well. One level of hierarchy
        means that only the direct children of the cell are deleted with the cell itself. All
        instances of this cell are deleted as well.

        After the cell has been deleted, the Cell object becomes invalid. Do not access methods or
        attributes of this object after deleting the cell.

        @param levels The number of hierarchy levels to consider (-1: all, 0: none, 1: one level
        etc.)

        This method has been introduced in version 0.23.'''

    def prune_subcells(self, ...):
        '''@brief Deletes all sub cells of the cell which are not used otherwise down to the
        specified level of hierarchy @args levels

        This deletes all sub cells of the cell which are not used otherwise. All instances of the
        deleted cells are deleted as well. It is possible to specify how many levels of hierarchy
        below the given root cell are considered.

        @param levels The number of hierarchy levels to consider (-1: all, 0: none, 1: one level
        etc.)

        This method has been introduced in version 0.23.'''

    def qname(self, ...):
        '''@brief Returns the library-qualified name

        Library cells will be indicated by returning a qualified name composed of the library name,
        a dot and the basic cell name. For example: "Basic.TEXT" will be the qname of the TEXT cell
        of the Basic library. For non-library cells, the qname is identical to the basic name (see
        \\name).

        This method has been introduced in version 0.25.'''

    def refresh(self, ...):
        '''@brief Refreshes the cell

        If the cell is a PCell or a proxy to a PCell in a library, this method recomputes the PCell.
        If the cell is a library proxy, this method reloads the information from the library, but
        not the library itself.

        This method has been introduced in version 0.22.'''

    def replace(self, ...):
        '''@brief Replaces a cell instance (array) with a different one and new properties, where
        the cell instance is given in micrometer units @return An \\Instance object representing the
        new instance This method is identical to the corresponding \\replace variant with a
        \\CellInstArray argument and a property ID. It however accepts a micrometer-unit
        \\DCellInstArray object which is translated to database units internally.

        This variant has been introduced in version 0.25.'''

    def replace_prop_id(self, ...):
        '''@brief Replaces (or install) the properties of a cell @args instance,property_id @return
        An Instance object representing the new instance This method has been introduced in version
        0.16. It can only be used in editable mode. Changes the properties Id of the given instance
        or install a properties Id on that instance if it does not have one yet. The property Id
        must be obtained from the \\Layout object's property_id method which associates a property
        set with a property Id.'''

    def set_property(self, ...):
        '''@brief Sets the user property with the given key to the given value @args key, value This
        method is a convenience method that sets the property with the given key to the given value.
        If no property with that key exists, it will create one. Using that method is more
        convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID.  This method has been introduced in version
        0.23.'''

    def shapes(self, ...):
        '''@brief Returns the shapes list of the given layer @args layer_index

        This method allows to access the shapes list on a certain layer. If the layer does not exist
        yet, it is created.

        @param index The layer index of the shapes list to retrieve

        @return A reference to the shapes list'''

    def swap(self, ...):
        '''@brief Swaps the layers given @args layer_index1, layer_index2

        This method swaps two layers inside this cell.'''

    def transform(self, ...):
        '''@brief Transforms the instance with the given complex floating-point transformation given
        in micrometer units @return A reference (an \\Instance object) to the new instance This
        method is identical to the corresponding \\transform method with a \\ICplxTrans argument.
        For this variant however, the transformation is given in micrometer units and is translated
        to database units internally.

        This variant has been introduced in version 0.25.'''

    def transform_into(self, ...):
        '''@brief Transforms the cell into a new coordinate system with the given complex integer
        transformation where the transformation is in micrometer units This method is identical to
        the corresponding \\transform_into method with a \\ICplxTrans argument. For this variant
        however, the transformation is given in micrometer units and is translated to database units
        internally.

        This variant has been introduced in version 0.25.'''

    def write(self, ...):
        '''@brief Writes the cell to a layout file @args file_name, options The format of the file
        will be determined from the file name. Only the cell and it's subtree below will be saved.
        In contrast to the other 'write' method, this version allows to specify save options, i.e.
        scaling etc.

        This method has been introduced in version 0.23.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class CellInstArray:
    '''@brief A single or array cell instance This object represents either single or array cell
    instances. A cell instance array is a regular array, described by two displacement vectors (a,
    b) and the instance count along that axes (na, nb).

    In addition, this object represents either instances with simple transformations or instances
    with complex transformations. The latter includes magnified instances and instances rotated by
    an arbitrary angle.

    The cell which is instantiated is given by a cell index. The cell index can be converted to a
    cell pointer by using \\Layout#cell. The cell index of a cell can be obtained using
    \\Cell#cell_index.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the displacement vector for the 'a' axis

    Starting with version 0.25 the displacement is of vector type.

     @brief Sets the displacement vector for the 'a' axis @args vector

    If the instance was not regular before this property is set, it will be initialized to a regular
    instance.

    This method was introduced in version 0.22. Starting with version 0.25 the displacement is of
    vector type.'''
    a = None

    '''@brief Gets the displacement vector for the 'b' axis

    Starting with version 0.25 the displacement is of vector type.

     @brief Sets the displacement vector for the 'b' axis @args vector

    If the instance was not regular before this property is set, it will be initialized to a regular
    instance.

    This method was introduced in version 0.22. Starting with version 0.25 the displacement is of
    vector type.'''
    b = None

    '''@brief Gets the cell index of the cell instantiated

     @brief Sets the index of the cell this instance refers to @args index'''
    cell_index = None

    '''@brief Gets the complex transformation of the first instance in the array This method is
    always applicable, compared to \\trans, since simple transformations can be expressed as complex
    transformations as well.

    @brief Sets the complex transformation of the instance or the first instance in the array @args
    trans

    This method was introduced in version 0.22.'''
    cplx_trans = None

    '''@brief Gets the number of instances in the 'a' axis

     @brief Sets the number of instances in the 'a' axis @args n

    If the instance was not regular before this property is set to a value larger than zero, it will
    be initialized to a regular instance. To make an instance a single instance, set na or nb to 0.

    This method was introduced in version 0.22.'''
    na = None

    '''@brief Gets the number of instances in the 'b' axis

     @brief Sets the number of instances in the 'b' axis @args n

    If the instance was not regular before this property is set to a value larger than zero, it will
    be initialized to a regular instance. To make an instance a single instance, set na or nb to 0.

    This method was introduced in version 0.22.'''
    nb = None

    '''@brief Gets the transformation of the first instance in the array The transformation returned
    is only valid if the array does not represent a complex transformation array

    @brief Sets the transformation of the instance or the first instance in the array @args t

    This method was introduced in version 0.22.'''
    trans = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Compares two arrays for equality @args other'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given cell instance. This
        method enables cell instances as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a single cell instance with a complex transformation @args cell_index,
        trans, a, b, na, nb @param cell_index The cell to instantiate @param trans The complex
        transformation by which to instantiate the cell @param a The displacement vector of the
        array in the 'a' axis @param b The displacement vector of the array in the 'b' axis @param
        na The number of placements in the 'a' axis @param nb The number of placements in the 'b'
        axis

        Starting with version 0.25 the displacements are of vector type.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __len__(self, ...):
        '''@brief Gets the number of single instances in the array If the instance represents a
        single instance, the count is 1. Otherwise it is na*nb.'''

    def __lt__(self, ...):
        '''@brief Compares two arrays for 'less' @args other The comparison provides an arbitrary
        sorting criterion and not specific sorting order. It is guaranteed that if an array a is
        less than b, b is not less than a. In addition, it a is not less than b and b is not less
        than a, then a is equal to b.'''

    def __ne__(self, ...):
        '''@brief Compares two arrays for inequality @args other'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Converts the array to a string

        This method was introduced in version 0.22.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Converts the array to a string

        This method was introduced in version 0.22.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Gets the bounding box of the array The bounding box incorporates all instances
        that the array represents. It needs the layout object to access the actual cell from the
        cell index.'''

    def bbox_per_layer(self, ...):
        '''@brief Gets the bounding box of the array with respect to one layer The bounding box
        incorporates all instances that the array represents. It needs the layout object to access
        the actual cell from the cell index.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_cplx_trans(self, ...):
        '''@brief Gets the complex transformations represented by this instance For a single
        instance, this iterator will deliver the single, complex transformation. For array
        instances, the iterator will deliver each complex transformation of the expanded array. This
        iterator is a generalization of \\each_trans for general complex transformations.

        This method has been introduced in version 0.25.'''

    def each_trans(self, ...):
        '''@brief Gets the simple transformations represented by this instance For a single
        instance, this iterator will deliver the single, simple transformation. For array instances,
        the iterator will deliver each simple transformation of the expanded array.

        This iterator will only deliver valid transformations if the instance array is not of
        complex type (see \\is_complex?). A more general iterator that delivers the complex
        transformations is \\each_cplx_trans.

        This method has been introduced in version 0.25.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given cell instance. This
        method enables cell instances as hash keys.

        This method has been introduced in version 0.25.'''

    def invert(self, ...):
        '''@brief Inverts the array reference

        The inverted array reference describes in which transformations the parent cell is seen from
        the current cell.'''

    def is_complex(self, ...):
        '''@brief Gets a value indicating whether the array is a complex array

        Returns true if the array represents complex instances (that is, with magnification and
        arbitrary rotation angles).'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_regular_array(self, ...):
        '''@brief Gets a value indicating whether this instance is a regular array'''

    def size(self, ...):
        '''@brief Gets the number of single instances in the array If the instance represents a
        single instance, the count is 1. Otherwise it is na*nb.'''

    def to_s(self, ...):
        '''@brief Converts the array to a string

        This method was introduced in version 0.22.'''

    def transform(self, ...):
        '''@brief Transforms the cell instance with the given complex transformation @args trans

        This method has been introduced in version 0.20.'''

    def transformed(self, ...):
        '''@brief Gets the transformed cell instance (complex transformation) @args trans

        This method has been introduced in version 0.20.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a single cell instance with a complex transformation @args cell_index,
        trans, a, b, na, nb @param cell_index The cell to instantiate @param trans The complex
        transformation by which to instantiate the cell @param a The displacement vector of the
        array in the 'a' axis @param b The displacement vector of the array in the 'b' axis @param
        na The number of placements in the 'a' axis @param nb The number of placements in the 'b'
        axis

        Starting with version 0.25 the displacements are of vector type.'''


class CellMapping:
    '''@brief A cell mapping (source to target layout)

    A cell mapping is an association of cells in two layouts forming pairs of cells, i.e. one cell
    corresponds to another cell in the other layout. The CellMapping object describes the mapping of
    cells of a source layout B to a target layout A. The cell mapping object is basically a table
    associating a cell in layout B with a cell in layout A.

    The mapping object is used to create and hold that table. There are three basic modes in which a
    table can be generated:

    @ul   @li Top-level identity @/li   @li Geometrical identity @/li   @li Name identity @/li @/ul

    Top-level identity means that only one cell (the top cell) is regarded identical. All child
    cells are not considered identical. In full mode (see below), this will create a new, identical
    cell tree below the top cell in layout A.

    Geometrical identity is defined by the exact identity of the set of expanded instances in each
    starting cell. Therefore, when a cell is mapped to another cell, shapes can be transferred from
    one cell to another while effectively rendering the same flat geometry (in the context of the
    given starting cells). Location identity is basically the safest way to map cells from one
    hierarchy into another, because it preserves the flat shape geometry. However in some cases the
    algorithm may find multiple mapping candidates. In that case it will make a guess about what
    mapping to choose.

    Name identity means that cells are identified by their names - for a source cell in layer B, a
    target cell with the same name is looked up in the target layout A and a mapping is created if a
    cell with the same name is found. However, name identity does not mean that the cells are
    actually equivalent because they may be placed differently. Hence, cell mapping by name is not a
    good choice when it is important to preserve the shape geometry of a layer.

    A cell might not be mapped to another cell which basically means that there is no corresponding
    cell. In this case, flattening to the next mapped cell is an option to transfer geometries
    despite the missing mapping. You can enforce a mapping by using the mapping generator methods in
    'full' mode, i.e. \\from_names_full or \\from_geometry_full. These versions will create new
    cells and their corresponding instances in the target layout if no suitable target cell is
    found.

    CellMapping objects play a role mainly in the hierarchical copy or move operations of \\Layout.
    However, use is not restricted to these applications. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def cell_mapping(self, ...):
        '''@brief Determines cell mapping of a layout_b cell to the corresponding layout_a cell.

        @args cell_index_b

        @param cell_index_b The index of the cell in layout_b whose mapping is requested. @return
        The cell index in layout_a.

        Note that the returned index can be \\DropCell to indicate the cell shall be dropped.'''

    def clear(self, ...):
        '''@brief Clears the mapping.

        This method has been introduced in version 0.23.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def for_single_cell(self, ...):
        '''@brief Initializes the cell mapping for top-level identity

        @args layout_a, cell_index_a, layout_b, cell_index_b @param layout_a The target layout.
        @param cell_index_a The index of the target cell. @param layout_b The source layout. @param
        cell_index_b The index of the source cell.

        The cell mapping is created for cell_b to cell_a in the respective layouts. This method
        clears the mapping and creates one for the single cell pair. If used for \\Cell#copy_tree or
        \\Cell#move_tree, this cell mapping will essentially flatten the cell.

        This method is equivalent to \\clear, followed by \\map(cell_index_a, cell_index_b).

        This method has been introduced in version 0.23.'''

    def for_single_cell_full(self, ...):
        '''@brief Initializes the cell mapping for top-level identity

        @args layout_a, cell_index_a, layout_b, cell_index_b @param layout_a The target layout.
        @param cell_index_a The index of the target cell. @param layout_b The source layout. @param
        cell_index_b The index of the source cell.

        The cell mapping is created for cell_b to cell_a in the respective layouts. This method
        clears the mapping and creates one for the single cell pair. In addition and in contrast to
        \\for_single_cell, this method completes the mapping by adding all the child cells of cell_b
        to layout_a and creating the proper instances.  This method has been introduced in version
        0.23.'''

    def from_geometry(self, ...):
        '''@brief Initializes the cell mapping using the geometrical identity

        @args layout_a, cell_index_a, layout_b, cell_index_b @param layout_a The target layout.
        @param cell_index_a The index of the target starting cell. @param layout_b The source
        layout. @param cell_index_b The index of the source starting cell.

        The cell mapping is created for cells below cell_a and cell_b in the respective layouts.
        This method employs geometrical identity to derive mappings for the child cells of the
        starting cell in layout A and B. If the geometrical identity is ambiguous, the algorithm
        will make an arbitrary choice.

        This method has been introduced in version 0.23.'''

    def from_geometry_full(self, ...):
        '''@brief Initializes the cell mapping using the geometrical identity in full mapping mode

        @args layout_a, cell_index_a, layout_b, cell_index_b @param layout_a The target layout.
        @param cell_index_a The index of the target starting cell. @param layout_b The source
        layout. @param cell_index_b The index of the source starting cell. @return A list of indexes
        of cells created.

        The cell mapping is created for cells below cell_a and cell_b in the respective layouts.
        This method employs geometrical identity to derive mappings for the child cells of the
        starting cell in layout A and B. If the geometrical identity is ambiguous, the algorithm
        will make an arbitrary choice.

        Full mapping means that cells which are not found in the target layout A are created there
        plus their corresponding instances are created as well. The returned list will contain the
        indexes of all cells created for that reason.

        This method has been introduced in version 0.23.'''

    def from_names(self, ...):
        '''@brief Initializes the cell mapping using the name identity

        @args layout_a, cell_index_a, layout_b, cell_index_b @param layout_a The target layout.
        @param cell_index_a The index of the target starting cell. @param layout_b The source
        layout. @param cell_index_b The index of the source starting cell.

        The cell mapping is created for cells below cell_a and cell_b in the respective layouts.
        This method employs name identity to derive mappings for the child cells of the starting
        cell in layout A and B.

        This method has been introduced in version 0.23.'''

    def from_names_full(self, ...):
        '''@brief Initializes the cell mapping using the name identity in full mapping mode

        @args layout_a, cell_index_a, layout_b, cell_index_b @param layout_a The target layout.
        @param cell_index_a The index of the target starting cell. @param layout_b The source
        layout. @param cell_index_b The index of the source starting cell. @return A list of indexes
        of cells created.

        The cell mapping is created for cells below cell_a and cell_b in the respective layouts.
        This method employs name identity to derive mappings for the child cells of the starting
        cell in layout A and B.

        Full mapping means that cells which are not found in the target layout A are created there
        plus their corresponding instances are created as well. The returned list will contain the
        indexes of all cells created for that reason.

        This method has been introduced in version 0.23.'''

    def has_mapping(self, ...):
        '''@brief Returns as value indicating whether a cell of layout_b has a mapping to a layout_a
        cell.

        @args cell_index_b

        @param cell_index_b The index of the cell in layout_b whose mapping is requested. @return
        true, if the cell has a mapping

        Note that if the cell is supposed to be dropped (see \\DropCell), the respective source cell
        will also be regarded "mapped", so has_mapping? will return true in this case.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def map(self, ...):
        '''@brief Explicitly specifies a mapping.

        @args cell_index_b, cell_index_a

        @param cell_index_b The index of the cell in layout B (the "source") @param cell_index_a The
        index of the cell in layout A (the "target") - this index can be \\DropCell

        Beside using the mapping generator algorithms provided through \\from_names and
        \\from_geometry, it is possible to explicitly specify cell mappings using this method.

        This method has been introduced in version 0.23.'''

    def table(self, ...):
        '''@brief Returns the mapping table.

        The mapping table is a dictionary where the keys are source layout cell indexes and the
        values are the target layout cell indexes. Note that the target cell index can be \\DropCell
        to indicate that a cell is supposed to be dropped.

        This method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class CplxTrans:
    '''@brief A complex transformation

    A complex transformation provides magnification, mirroring at the x-axis, rotation by an
    arbitary angle and a displacement. This is also the order, the operations are applied. This
    version can transform integer-coordinate objects into floating-point coordinate objects. This is
    the generic and exact case, for example for non-integer magnifications.

    Complex transformations are extensions of the simple transformation classes (\\Trans or \\DTrans
    in that case) and behave similar.

    Transformations can be used to transform points or other objects. Transformations can be
    combined with the '*' operator to form the transformation which is equivalent to applying the
    second and then the first. Here is some code:

    @code # Create a transformation that applies a magnication of 1.5, a rotation by 90 degree # and
    displacement of 10 in x and 20 units in y direction: t = RBA::DCplxTrans::new(1.5, 90, false,
    10.0, 20.0) t.to_s            # r90 *1.5 10,20 # compute the inverse: t.inverted.to_s   # r270
    *0.666666667 -13,7 # Combine with another displacement (applied after that):
    (RBA::DCplxTrans::new(5, 5) * t).to_s    # r90 *1.5 15,25 # Transform a point:
    t.trans(RBA::DPoint::new(100, 200)).to_s # -290,170 @/code

    The inverse type of the CplxTrans type is VCplxTrans which will transform floating-point to
    integer coordinate objects. Transformations of CplxTrans type can be concatenated (operator *)
    with either itself or with transformations of compatible input or output type. This means, the
    operator CplxTrans * ICplxTrans is allowed (output types of ICplxTrans and input of CplxTrans
    are identical) while CplxTrans * DCplxTrans is not. See @<a
    href="/programming/database_api.xml">The Database API@</a> for more details about the database
    objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the angle

    Note that the simple transformation returns the angle in units of 90 degree. Hence for a simple
    trans (i.e. \\Trans), a rotation angle of 180 degree delivers a value of 2 for the angle
    attribute. The complex transformation, supporting any rotation angle returns the angle in
    degree.

    @return The rotation angle this transformation provides in degree units (0..360 deg).

     @brief Sets the angle @param a The new angle See \\angle for a description of that
    attribute.'''
    angle = None

    '''@brief Gets the displacement

     @brief Sets the displacement @param u The new displacement'''
    disp = None

    '''@brief Gets the magnification

     @brief Sets the magnification @args m @param m The new magnification'''
    mag = None

    '''@brief Sets the mirror flag "mirroring" describes a reflection at the x-axis which is
    included in the transformation prior to rotation.@param m The new mirror flag'''
    mirror = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Tests for equality'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis, rotation, application of
        displacement.

        @param mag The magnification @param rot The rotation angle in units of degree @param mirrx
        True, if mirrored at x axis @param x The x displacement @param y The y displacement'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Provides a 'less' criterion for sorting This method is provided to implement a
        sorting order. The definition of 'less' is opaque and might change in future versions.'''

    def __mul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __ne__(self, ...):
        '''@brief Tests for inequality'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def ctrans(self, ...):
        '''@brief Transforms a distance

        The "ctrans" method transforms the given distance. e = t(d). For the simple transformations,
        there is no magnification and no modification of the distance therefore.

        @param d The distance to transform @return The transformed distance'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def invert(self, ...):
        '''@brief Inverts the transformation (in place)

        Inverts the transformation and replaces this transformation by it's inverted one.

        @return The inverted transformation'''

    def inverted(self, ...):
        '''@brief Returns the inverted transformation

        Returns the inverted transformation. This method does not modify the transformation.

        @return The inverted transformation'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mag(self, ...):
        '''@brief Test, if the transformation is a magnifying one

        This is the recommended test for checking if the transformation represents a
        magnification.'''

    def is_mirror(self, ...):
        '''@brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis
        followed by a rotation by the angle given by the \\angle property. '''

    def is_ortho(self, ...):
        '''@brief Tests, if the transformation is an orthogonal transformation

        If the rotation is by a multiple of 90 degree, this method will return true.'''

    def is_unity(self, ...):
        '''@brief Tests, whether this is a unit transformation'''

    def rot(self, ...):
        '''@brief Returns the respective simple transformation equivalent rotation code if possible

        If this transformation is orthogonal (is_ortho () == true), then this method will return the
        corresponding fixpoint transformation, not taking into account magnification and
        displacement. If the transformation is not orthogonal, the result reflects the quadrant the
        rotation goes into.'''

    def s_trans(self, ...):
        '''@brief Extracts the simple transformation part

        The simple transformation part does not reflect magnification or arbitrary angles. Rotation
        angles are rounded down to multiples of 90 degree. Magnification is fixed to 1.0.'''

    def to_itrans(self, ...):
        '''@brief Converts the transformation to another transformation with integer input and
        output coordinates

        The database unit can be specified to translate the floating-point coordinate displacement
        in micron units to an integer-coordinate displacement in database units. The displacement's'
        coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def to_trans(self, ...):
        '''@brief Converts the transformation to another transformation with floating-point input
        coordinates

        This method has been introduced in version 0.25.'''

    def to_vtrans(self, ...):
        '''@brief Converts the transformation to another transformation with integer output and
        floating-point input coordinates

        The database unit can be specified to translate the floating-point coordinate displacement
        in micron units to an integer-coordinate displacement in database units. The displacement's'
        coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.'''

    def trans(self, ...):
        '''@brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform @return The transformed text

        This convenience method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_dtrans(cls, ...):
        '''@brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dtrans'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string Creates the object from a string representation
        (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis, rotation, application of
        displacement.

        @param mag The magnification @param rot The rotation angle in units of degree @param mirrx
        True, if mirrored at x axis @param x The x displacement @param y The y displacement'''


class DBox:
    '''@brief A box class with floating-point coordinates

    This object represents a box (a rectangular shape).

    The definition of the attributes is: p1 is the lower left point, p2 the  upper right one. If a
    box is constructed from two points (or four coordinates), the  coordinates are sorted
    accordingly.

    A box can be empty. An empty box represents no area (not even a point). Empty boxes behave
    neutral with respect to most operations.  Empty boxes return true on \\empty?.

    A box can be a point or a single line. In this case, the area is zero but the box still can
    overlap other boxes for example and it is not empty.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the bottom coordinate of the box

     @brief Sets the bottom coordinate of the box @args c'''
    bottom = None

    '''@brief Gets the left coordinate of the box

     @brief Sets the left coordinate of the box @args c'''
    left = None

    '''@brief Gets the lower left point of the box

     @brief Sets the lower left point of the box @args p'''
    p1 = None

    '''@brief Gets the upper right point of the box

     @brief Sets the upper right point of the box @args p'''
    p2 = None

    '''@brief Gets the right coordinate of the box

     @brief Sets the right coordinate of the box @args c'''
    right = None

    '''@brief Gets the top coordinate of the box

     @brief Sets the top coordinate of the box @args c'''
    top = None

    # Methods
    def __add__(self, ...):
        '''@brief Joins two boxes

        @args box

        The + operator joins the first box with the one given as  the second argument. Joining
        constructs a box that encloses both boxes given. Empty boxes are neutral: they do not change
        another box when joining. Overwrites this box with the result.

        @param box The box to join with this box.

        @return The joined box'''

    def __and__(self, ...):
        '''@brief Returns the intersection of this box with another box

        @args box

        The intersection of two boxes is the largest box common to both boxes. The intersection may
        be  empty if both boxes to not touch. If the boxes do not overlap but touch the result may
        be a single line or point with an area of zero. Overwrites this box with the result.

        @param box The box to take the intersection with

        @return The intersection box'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Returns true if this box is equal to the other box @args box Returns true, if this
        box and the given box are equal '''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given box. This method enables
        boxes as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a box from two points

        @args lower_left, upper_right

        Two points are given to create a new box. If the coordinates are not provided in the correct
        order (i.e. right < left), these are swapped.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Returns true if this box is 'less' than another box @args box Returns true, if
        this box is 'less' with respect to first and second point (in this order)'''

    def __mul__(self, ...):
        '''@brief Returns the scaled box

        @args scale_factor

        The * operator scales the box with the given factor and returns the result.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled box'''

    def __ne__(self, ...):
        '''@brief Returns true if this box is not equal to the other box @args box Returns true, if
        this box and the given box are not equal '''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Returns a string representing this box

        This string can be turned into a box again by using \\from_s'''

    def __rmul__(self, ...):
        '''@brief Returns the scaled box

        @args scale_factor

        The * operator scales the box with the given factor and returns the result.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled box'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Returns a string representing this box

        This string can be turned into a box again by using \\from_s'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief Computes the box area

        Returns the box area or 0 if the box is empty'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def center(self, ...):
        '''@brief Gets the center of the box'''

    def contains(self, ...):
        '''@brief Returns true if the box contains the given point

        @args point Tests whether a point is inside the box. It also returns true if the point is
        exactly on the box contour.

        @param p The point to test against.

        @return true if the point is inside the box.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def empty(self, ...):
        '''@brief Returns a value indicating whether the box is empty

        An empty box may be created with the default constructor for example. Such a box is neutral
        when combining it with other boxes and renders empty boxes if used in box intersections and
        false in geometrical relationship tests. '''

    def enlarge(self, ...):
        '''@brief Enlarges the box by a certain amount.

        @args enlargement

        Enlarges the box by x and y value specified in the vector passed. Positive values with grow
        the box, negative ones will shrink the box. The result may be an empty box if the box
        disappears. The amount specifies the grow or shrink per edge. The width and height will
        change by twice the amount. Does not check for coordinate overflows.

        @param enlargement The grow or shrink amount in x and y direction

        @return A reference to this box.'''

    def enlarged(self, ...):
        '''@brief Returns the enlarged box.

        @args enlargement

        Enlarges the box by x and y value specified in the vector passed. Positive values with grow
        the box, negative ones will shrink the box. The result may be an empty box if the box
        disappears. The amount specifies the grow or shrink per edge. The width and height will
        change by twice the amount. Does not modify this box. Does not check for coordinate
        overflows.

        @param enlargement The grow or shrink amount in x and y direction

        @return The enlarged box.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given box. This method enables
        boxes as hash keys.

        This method has been introduced in version 0.25.'''

    def height(self, ...):
        '''@brief Gets the height of the box'''

    def inside(self, ...):
        '''@brief Tests if this box is inside the argument box

        @args box

        Returns true, if this box is inside the given box, i.e. the box intersection renders this
        box'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_point(self, ...):
        '''@brief Returns true, if the box is a single point'''

    def move(self, ...):
        '''@brief Moves the box by a certain distance

        @args distance

        Moves the box by a given offset and returns the moved box. Does not check for coordinate
        overflows.

        @param distance The offset to move the box.

        @return A reference to this box.'''

    def moved(self, ...):
        '''@brief Returns the box moved by a certain distance

        @args distance

        Moves the box by a given offset and returns the moved box. Does not modify this box. Does
        not check for coordinate overflows.

        @param distance The offset to move the box.

        @return The moved box.'''

    def overlaps(self, ...):
        '''@brief Tests if this box overlaps the argument box

        @args box

        Returns true, if the intersection box of this box with the argument box exists and has a
        non-vanishing area'''

    def perimeter(self, ...):
        '''@brief Returns the perimeter of the box

        This method is equivalent to 2*(width+height). For empty boxes, this method returns 0.

        This method has been introduced in version 0.23.'''

    def to_itype(self, ...):
        '''@brief Converts the box to an integer coordinate box

        The database unit can be specified to translate the floating-point coordinate box in micron
        units to an integer-coordinate box in database units. The boxes coordinates will be divided
        by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Returns a string representing this box

        This string can be turned into a box again by using \\from_s'''

    def touches(self, ...):
        '''@brief Tests if this box touches the argument box

        @args box

        Two boxes touch if they overlap or their boundaries share at least one common point.
        Touching is equivalent to a non-empty intersection ('!(b1 & b2).empty?').'''

    def transformed(self, ...):
        '''@brief Returns the box transformed with the given complex transformation

        @args t

        @param t The magnifying transformation to apply @return The transformed box (a DBox now)'''

    def width(self, ...):
        '''@brief Gets the width of the box'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_ibox(cls, ...):
        '''@brief Creates a floating-point coordinate box from an integer coordinate box

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_ibox'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates a box object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a box from two points

        @args lower_left, upper_right

        Two points are given to create a new box. If the coordinates are not provided in the correct
        order (i.e. right < left), these are swapped.'''


class DCellInstArray:
    '''@brief A single or array cell instance in micrometer units This object is identical to
    \\CellInstArray, except that it holds coordinates in micron units instead of database units.

    This class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the displacement vector for the 'a' axis

     @brief Sets the displacement vector for the 'a' axis @args vector

    If the instance was not regular before this property is set, it will be initialized to a regular
    instance.'''
    a = None

    '''@brief Gets the displacement vector for the 'b' axis

     @brief Sets the displacement vector for the 'b' axis @args vector

    If the instance was not regular before this property is set, it will be initialized to a regular
    instance.'''
    b = None

    '''@brief Gets the cell index of the cell instantiated

     @brief Sets the index of the cell this instance refers to @args index'''
    cell_index = None

    '''@brief Gets the complex transformation of the first instance in the array This method is
    always applicable, compared to \\trans, since simple transformations can be expressed as complex
    transformations as well.

    @brief Sets the complex transformation of the instance or the first instance in the array @args
    trans'''
    cplx_trans = None

    '''@brief Gets the number of instances in the 'a' axis

     @brief Sets the number of instances in the 'a' axis @args n

    If the instance was not regular before this property is set to a value larger than zero, it will
    be initialized to a regular instance. To make an instance a single instance, set na or nb to
    0.'''
    na = None

    '''@brief Gets the number of instances in the 'b' axis

     @brief Sets the number of instances in the 'b' axis @args n

    If the instance was not regular before this property is set to a value larger than zero, it will
    be initialized to a regular instance. To make an instance a single instance, set na or nb to
    0.'''
    nb = None

    '''@brief Gets the transformation of the first instance in the array The transformation returned
    is only valid if the array does not represent a complex transformation array

    @brief Sets the transformation of the instance or the first instance in the array @args t'''
    trans = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Compares two arrays for equality @args other'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given cell instance. This
        method enables cell instances as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a single cell instance with a complex transformation @args cell_index,
        trans, a, b, na, nb @param cell_index The cell to instantiate @param trans The complex
        transformation by which to instantiate the cell @param a The displacement vector of the
        array in the 'a' axis @param b The displacement vector of the array in the 'b' axis @param
        na The number of placements in the 'a' axis @param nb The number of placements in the 'b'
        axis'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __len__(self, ...):
        '''@brief Gets the number of single instances in the array If the instance represents a
        single instance, the count is 1. Otherwise it is na*nb.'''

    def __lt__(self, ...):
        '''@brief Compares two arrays for 'less' @args other The comparison provides an arbitrary
        sorting criterion and not specific sorting order. It is guaranteed that if an array a is
        less than b, b is not less than a. In addition, it a is not less than b and b is not less
        than a, then a is equal to b.'''

    def __ne__(self, ...):
        '''@brief Compares two arrays for inequality @args other'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Converts the array to a string'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Converts the array to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Gets the bounding box of the array The bounding box incorporates all instances
        that the array represents. It needs the layout object to access the actual cell from the
        cell index.'''

    def bbox_per_layer(self, ...):
        '''@brief Gets the bounding box of the array with respect to one layer The bounding box
        incorporates all instances that the array represents. It needs the layout object to access
        the actual cell from the cell index.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_cplx_trans(self, ...):
        '''@brief Gets the complex transformations represented by this instance For a single
        instance, this iterator will deliver the single, complex transformation. For array
        instances, the iterator will deliver each complex transformation of the expanded array. This
        iterator is a generalization of \\each_trans for general complex transformations.'''

    def each_trans(self, ...):
        '''@brief Gets the simple transformations represented by this instance For a single
        instance, this iterator will deliver the single, simple transformation. For array instances,
        the iterator will deliver each simple transformation of the expanded array.

        This iterator will only deliver valid transformations if the instance array is not of
        complex type (see \\is_complex?). A more general iterator that delivers the complex
        transformations is \\each_cplx_trans.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given cell instance. This
        method enables cell instances as hash keys.

        This method has been introduced in version 0.25.'''

    def invert(self, ...):
        '''@brief Inverts the array reference

        The inverted array reference describes in which transformations the parent cell is seen from
        the current cell.'''

    def is_complex(self, ...):
        '''@brief Gets a value indicating whether the array is a complex array

        Returns true if the array represents complex instances (that is, with magnification and
        arbitrary rotation angles).'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_regular_array(self, ...):
        '''@brief Gets a value indicating whether this instance is a regular array'''

    def size(self, ...):
        '''@brief Gets the number of single instances in the array If the instance represents a
        single instance, the count is 1. Otherwise it is na*nb.'''

    def to_s(self, ...):
        '''@brief Converts the array to a string'''

    def transform(self, ...):
        '''@brief Transforms the cell instance with the given complex transformation @args trans'''

    def transformed(self, ...):
        '''@brief Gets the transformed cell instance (complex transformation) @args trans'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a single cell instance with a complex transformation @args cell_index,
        trans, a, b, na, nb @param cell_index The cell to instantiate @param trans The complex
        transformation by which to instantiate the cell @param a The displacement vector of the
        array in the 'a' axis @param b The displacement vector of the array in the 'b' axis @param
        na The number of placements in the 'a' axis @param nb The number of placements in the 'b'
        axis'''


class DCplxTrans:
    '''@brief A complex transformation

    A complex transformation provides magnification, mirroring at the x-axis, rotation by an
    arbitary angle and a displacement. This is also the order, the operations are applied.

    A complex transformation provides a superset of the simple transformation. In many applications,
    a complex transformation computes floating-point coordinates to minimize rounding effects. This
    version can transform floating-point coordinate objects.

    Complex transformations are extensions of the simple transformation classes (\\DTrans in that
    case) and behave similar.

    Transformations can be used to transform points or other objects. Transformations can be
    combined with the '*' operator to form the transformation which is equivalent to applying the
    second and then the first. Here is some code:

    @code # Create a transformation that applies a magnication of 1.5, a rotation by 90 degree # and
    displacement of 10 in x and 20 units in y direction: t = RBA::CplxTrans::new(1.5, 90, false,
    10.0, 20.0) t.to_s            # r90 *1.5 10,20 # compute the inverse: t.inverted.to_s   # r270
    *0.666666667 -13,7 # Combine with another displacement (applied after that):
    (RBA::CplxTrans::new(5, 5) * t).to_s    # r90 *1.5 15,25 # Transform a point:
    t.trans(RBA::Point::new(100, 200)).to_s # -290,170 @/code

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the angle

    Note that the simple transformation returns the angle in units of 90 degree. Hence for a simple
    trans (i.e. \\Trans), a rotation angle of 180 degree delivers a value of 2 for the angle
    attribute. The complex transformation, supporting any rotation angle returns the angle in
    degree.

    @return The rotation angle this transformation provides in degree units (0..360 deg).

     @brief Sets the angle @param a The new angle See \\angle for a description of that
    attribute.'''
    angle = None

    '''@brief Gets the displacement

     @brief Sets the displacement @param u The new displacement'''
    disp = None

    '''@brief Gets the magnification

     @brief Sets the magnification @args m @param m The new magnification'''
    mag = None

    '''@brief Sets the mirror flag "mirroring" describes a reflection at the x-axis which is
    included in the transformation prior to rotation.@param m The new mirror flag'''
    mirror = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Tests for equality'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis, rotation, application of
        displacement.

        @param mag The magnification @param rot The rotation angle in units of degree @param mirrx
        True, if mirrored at x axis @param x The x displacement @param y The y displacement'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Provides a 'less' criterion for sorting This method is provided to implement a
        sorting order. The definition of 'less' is opaque and might change in future versions.'''

    def __mul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __ne__(self, ...):
        '''@brief Tests for inequality'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def ctrans(self, ...):
        '''@brief Transforms a distance

        The "ctrans" method transforms the given distance. e = t(d). For the simple transformations,
        there is no magnification and no modification of the distance therefore.

        @param d The distance to transform @return The transformed distance'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def invert(self, ...):
        '''@brief Inverts the transformation (in place)

        Inverts the transformation and replaces this transformation by it's inverted one.

        @return The inverted transformation'''

    def inverted(self, ...):
        '''@brief Returns the inverted transformation

        Returns the inverted transformation. This method does not modify the transformation.

        @return The inverted transformation'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mag(self, ...):
        '''@brief Test, if the transformation is a magnifying one

        This is the recommended test for checking if the transformation represents a
        magnification.'''

    def is_mirror(self, ...):
        '''@brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis
        followed by a rotation by the angle given by the \\angle property. '''

    def is_ortho(self, ...):
        '''@brief Tests, if the transformation is an orthogonal transformation

        If the rotation is by a multiple of 90 degree, this method will return true.'''

    def is_unity(self, ...):
        '''@brief Tests, whether this is a unit transformation'''

    def rot(self, ...):
        '''@brief Returns the respective simple transformation equivalent rotation code if possible

        If this transformation is orthogonal (is_ortho () == true), then this method will return the
        corresponding fixpoint transformation, not taking into account magnification and
        displacement. If the transformation is not orthogonal, the result reflects the quadrant the
        rotation goes into.'''

    def s_trans(self, ...):
        '''@brief Extracts the simple transformation part

        The simple transformation part does not reflect magnification or arbitrary angles. Rotation
        angles are rounded down to multiples of 90 degree. Magnification is fixed to 1.0.'''

    def to_itrans(self, ...):
        '''@brief Converts the transformation to another transformation with integer input and
        output coordinates

        The database unit can be specified to translate the floating-point coordinate displacement
        in micron units to an integer-coordinate displacement in database units. The displacement's'
        coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def to_trans(self, ...):
        '''@brief Converts the transformation to another transformation with integer input
        coordinates

        This method has been introduced in version 0.25.'''

    def to_vtrans(self, ...):
        '''@brief Converts the transformation to another transformation with integer output
        coordinates

        The database unit can be specified to translate the floating-point coordinate displacement
        in micron units to an integer-coordinate displacement in database units. The displacement's'
        coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.'''

    def trans(self, ...):
        '''@brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform @return The transformed text

        This convenience method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_itrans(cls, ...):
        '''@brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_itrans'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string Creates the object from a string representation
        (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis, rotation, application of
        displacement.

        @param mag The magnification @param rot The rotation angle in units of degree @param mirrx
        True, if mirrored at x axis @param x The x displacement @param y The y displacement'''


class DEdge:
    '''@brief An edge class

    An edge is a connection between points, usually participating in a larger context such as a
    polygon. An edge has a defined direction (from p1 to p2). Edges play a role in the database as
    parts of polygons and to describe a line through both points. The \\Edge object is also used
    inside the boolean processor (\\EdgeProcessor). Altough supported, edges are rarely used as
    individual database objects.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects like the Edge class. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief The first point.

     @brief Sets the first point. @args point This method has been added in version 0.23.'''
    p1 = None

    '''@brief The second point.

     @brief Sets the second point. @args point This method has been added in version 0.23.'''
    p2 = None

    '''@brief Shortcut for p1.x

     @brief Sets p1.x @args coord This method has been added in version 0.23.'''
    x1 = None

    '''@brief Shortcut for p2.x

     @brief Sets p2.x @args coord This method has been added in version 0.23.'''
    x2 = None

    '''@brief Shortcut for p1.y

     @brief Sets p1.y @args coord This method has been added in version 0.23.'''
    y1 = None

    '''@brief Shortcut for p2.y

     @brief Sets p2.y @args coord This method has been added in version 0.23.'''
    y2 = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test @args e @param e The object to compare against'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given edge. This method enables
        edges as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor with two points

        @args p1, p2

        Two points are given to create a new edge.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args e @param e The object to compare against @return True, if the
        edge is 'less' as the other edge with respect to first and second point'''

    def __mul__(self, ...):
        '''@brief Scale edge

        @args scale_factor

        The * operator scales self with the given factor.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled edge'''

    def __ne__(self, ...):
        '''@brief Inequality test @args e @param e The object to compare against'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Returns a string representing the edge'''

    def __rmul__(self, ...):
        '''@brief Scale edge

        @args scale_factor

        The * operator scales self with the given factor.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled edge'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Returns a string representing the edge'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Return the bounding box of the edge.'''

    def coincident(self, ...):
        '''@brief Coincidence check. @args e

        Checks whether a edge is coincident with another edge.  Coincidence is defined by being
        parallel and that  at least one point of one edge is on the other edge.

        @param e the edge to test with

        @return True if the edges are coincident.'''

    def contains(self, ...):
        '''@brief Test whether a point is on an edge. @args p

        A point is on a edge if it is on (or at least closer  than a grid point to) the edge.

        @param p The point to test with the edge.

        @return True if the point is on the edge.'''

    def contains_excl(self, ...):
        '''@brief Test whether a point is on an edge excluding the endpoints. @args p

        A point is on a edge if it is on (or at least closer  than a grid point to) the edge.

        @param p The point to test with the edge.

        @return True if the point is on the edge but not equal p1 or p2.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def crossed_by(self, ...):
        '''@brief Check, if an edge is cut by a line (given by an edge) @args e

        This method returns true if p1 is in one semispace  while p2 is in the other or one of them
        is on the line through the edge "e"

        @param e The edge representing the line that the edge must be crossing.'''

    def crossing_point(self, ...):
        '''@brief Returns the crossing point on two edges.  @args e

        This method delivers the point where the given edge (self) crosses the line given by the
        edge in argument "e". If self does not cross this line, the result is undefined. See
        \\crossed_by? for a description of the crossing predicate.

        @param e The edge representing the line that self must be crossing. @return The point where
        self crosses the line given by "e".

        This method has been introduced in version 0.19.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def distance(self, ...):
        '''@brief Distance between the edge and a point. @args p

        Returns the distance between the edge and the point. The  distance is signed which is
        negative if the point is to the "left" of the edge and positive if the point is to the
        "right". The distance is measured by projecting the point onto the line through the edge. If
        the edge is degenerated, the distance is not defined.

        @param p The point to test.

        @return The distance'''

    def distance_abs(self, ...):
        '''@brief Absolute distance between the edge and a point. @args p

        Returns the distance between the edge and the point.

        @param p The point to test.

        @return The distance'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def dx(self, ...):
        '''@brief The horizontal extend of the edge.'''

    def dx_abs(self, ...):
        '''@brief The absolute value of the horizontal extend of the edge.'''

    def dy(self, ...):
        '''@brief The vertical extend of the edge.'''

    def dy_abs(self, ...):
        '''@brief The absolute value of the vertical extend of the edge.'''

    def enlarge(self, ...):
        '''@brief Enlarges the edge. @args p

        Enlarges the edge by the given distance and returns the  enlarged edge. The edge is
        overwritten. Enlargement means that the first point is shifted by -p, the second by p.

        @param p The distance to move the edge points.

        @return The enlarged edge.'''

    def enlarged(self, ...):
        '''@brief Returns the enlarged edge (does not modify self) @args p

        Enlarges the edge by the given offset and returns the  enlarged edge. The edge is not
        modified. Enlargement means that the first point is shifted by -p, the second by p.

        @param p The distance to move the edge points.

        @return The enlarged edge.'''

    def extend(self, ...):
        '''@brief Extends the edge (modifies self) @args d

        Extends the edge by the given distance and returns the  extended edge. The edge is not
        modified. Extending means that the first point is shifted by -d along the edge, the second
        by d. The length of the edge will increase by 2*d.

        \\extended is a version that does not modify self but returns the extended edges.

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the end points.

        @return The extended edge (self).'''

    def extended(self, ...):
        '''@brief Returns the extended edge (does not modify self) @args d

        Extends the edge by the given distance and returns the  extended edge. The edge is not
        modified. Extending means that the first point is shifted by -d along the edge, the second
        by d. The length of the edge will increase by 2*d.

        \\extend is a version that modifies self (in-place).

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the end points.

        @return The extended edge.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given edge. This method enables
        edges as hash keys.

        This method has been introduced in version 0.25.'''

    def intersect(self, ...):
        '''@brief Intersection test.  @args e

        Returns true if the edges intersect. Two edges intersect if they share at least one point.
        If the edges coincide, they also intersect. For degenerated edges, the intersection is
        mapped to point containment tests.

        @param e The edge to test.'''

    def intersection_point(self, ...):
        '''@brief Returns the intersection point of two edges.  @args e

        This method delivers the intersection point. If the edges do not intersect, the result is
        undefined.

        @param e The edge to test. @return The point where the edges intersect.

        This method has been introduced in version 0.19.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_degenerate(self, ...):
        '''@brief Test for degenerated edge

        An edge is degenerate, if both end and start point are identical.'''

    def is_parallel(self, ...):
        '''@brief Test for being parallel @args e

        @param e The edge to test against

        @return True if both edges are parallel'''

    def length(self, ...):
        '''@brief The length of the edge'''

    def move(self, ...):
        '''@brief Moves the edge. @args dx, dy

        Moves the edge by the given offset and returns the  moved edge. The edge is overwritten.

        @param dx The x distance to move the edge. @param dy The y distance to move the edge.

        @return The moved edge.

        This version has been added in version 0.23.'''

    def moved(self, ...):
        '''@brief Returns the moved edge (does not modify self) @args dx, dy

        Moves the edge by the given offset and returns the  moved edge. The edge is not modified.

        @param dx The x distance to move the edge. @param dy The y distance to move the edge.

        @return The moved edge.

        This version has been added in version 0.23.'''

    def ortho_length(self, ...):
        '''@brief The orthogonal length of the edge ("manhattan-length")

        @return The orthogonal length (abs(dx)+abs(dy))'''

    def shift(self, ...):
        '''@brief Shifts the edge (modifies self) @args d

        Shifts the edge by the given distance and returns the  shifted edge. The edge is not
        modified. Shifting by a positive value will produce an edge which is shifted by d to the
        left. Shifting by a negative value will produce an edge which is shifted by d to the right.

        \\shifted is a version that does not modify self but returns the extended edges.

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the edge.

        @return The shifted edge (self).'''

    def shifted(self, ...):
        '''@brief Returns the shifted edge (does not modify self) @args d

        Shifts the edge by the given distance and returns the  shifted edge. The edge is not
        modified. Shifting by a positive value will produce an edge which is shifted by d to the
        left. Shifting by a negative value will produce an edge which is shifted by d to the right.

        \\shift is a version that modifies self (in-place).

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the edge.

        @return The shifted edge.'''

    def side_of(self, ...):
        '''@brief Indicates at which side the point is located relative to the edge. @args p

        Returns 1 if the point is "left" of the edge, 0 if on and -1 if the point is "right" of the
        edge.

        @param p The point to test.

        @return The side value'''

    def sq_length(self, ...):
        '''@brief The square of the length of the edge'''

    def swap_points(self, ...):
        '''@brief Swap the points of the edge

        This version modifies self. A version that does not modify self is \\swapped_points.
        Swapping the points basically reverses the direction of the edge.

        This method has been introduced in version 0.23.'''

    def swapped_points(self, ...):
        '''@brief Returns an edge in which both points are swapped

        Swapping the points basically reverses the direction of the edge.

        This method has been introduced in version 0.23.'''

    def to_itype(self, ...):
        '''@brief Converts the edge to an integer coordinate edge

        The database unit can be specified to translate the floating-point coordinate edge in micron
        units to an integer-coordinate edge in database units. The edges coordinates will be divided
        by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Returns a string representing the edge'''

    def transformed(self, ...):
        '''@brief Transform the edge. @args t

        Transforms the edge with the given complex transformation. Does not modify the edge but
        returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge.'''

    def transformed_cplx(self, ...):
        '''@brief Transform the edge. @args t

        Transforms the edge with the given complex transformation. Does not modify the edge but
        returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_iedge(cls, ...):
        '''@brief Creates a floating-point coordinate edge from an integer coordinate edge

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_iedge'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor with two points

        @args p1, p2

        Two points are given to create a new edge.'''

    @classmethod
    def new_pp(cls, ...):
        '''@brief Constructor with two points

        @args p1, p2

        Two points are given to create a new edge.'''

    @classmethod
    def new_xyxy(cls, ...):
        '''@brief Constructor with two coordinates given as single values

        @args x1, y1, x2, y2

        Two points are given to create a new edge.'''


class DEdgePair:
    '''@brief An edge pair (a pair of two edges) Edge pairs are objects representing two edges or
    parts of edges. They play a role mainly in the context of DRC functions, where they specify a
    DRC violation by connecting two edges which violate the condition checked. Within the framework
    of polygon and edge collections which provide DRC functionality, edges pairs with integer
    coordinates (\\EdgePair type) are used in the form of edge pair collections (\\EdgePairs).

    Edge pairs basically consist of two edges, called first and second. If created by a two-layer
    DRC function, the first edge will correspond to edges from the first layer and the second to
    edges from the second layer.

    This class has been introduced in version 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the first edge

     @brief Sets the first edge @args edge'''
    first = None

    '''@brief Gets the second edge

     @brief Sets the second edge @args edge'''
    second = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality @args box Returns true, if this edge pair and the given one are equal

        This method has been introduced in version 0.25.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given edge pair. This method
        enables edge pairs as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor from two edges

        This constructor creates an edge pair from the two edges given.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args box Returns true, if this edge pair is 'less' with respect to
        first and second edge

        This method has been introduced in version 0.25.'''

    def __ne__(self, ...):
        '''@brief Inequality @args box Returns true, if this edge pair and the given one are not
        equal

        This method has been introduced in version 0.25.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Returns a string representing the edge pair'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Returns a string representing the edge pair'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Gets the bounding box of the edge pair'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given edge pair. This method
        enables edge pairs as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def normalized(self, ...):
        '''@brief Normalizes the edge pair This method normalized the edge pair such that when
        connecting the edges at their  start and end points a closed loop is formed which is
        oriented clockwise. To achieve this, the points of the first and/or first and second edge
        are swapped. Normalization is a first step recommended before converting an edge pair to a
        polygon, because that way the polygons won't be self-overlapping and the enlargement
        parameter is applied properly.'''

    def polygon(self, ...):
        '''@brief Convert an edge pair to a polygon @args e The enlargement (set to zero for exact
        representation) The polygon is formed by connecting the end and start points of the edges.
        It is recommended to use \\normalized before converting the edge pair to a polygon.

        The enlargement parameter allows to apply the specified enlargement parallel and
        perpendicular to the edges. Basically this introduces a bias which blows up edge pairs by
        the specified amount. That parameter is useful to convert degenerated edge pairs to valid
        polygons, i.e. edge pairs with coincident edges and edge pairs consisting of two point-like
        edges.

        Another version for converting edge pairs to simple polygons is \\simple_polygon which
        renders a \\SimplePolygon object.'''

    def simple_polygon(self, ...):
        '''@brief Convert an edge pair to a simple polygon @args e The enlargement (set to zero for
        exact representation) The polygon is formed by connecting the end and start points of the
        edges. It is recommended to use \\normalized before converting the edge pair to a polygon.

        The enlargement parameter allows to apply the specified enlargement parallel and
        perpendicular to the edges. Basically this introduces a bias which blows up edge pairs by
        the specified amount. That parameter is useful to convert degenerated edge pairs to valid
        polygons, i.e. edge pairs with coincident edges and edge pairs consisting of two point-like
        edges.

        Another version for converting edge pairs to polygons is \\polygon which renders a \\Polygon
        object.'''

    def to_itype(self, ...):
        '''@brief Converts the edge pair to an integer coordinate edge pair

        The database unit can be specified to translate the floating-point coordinate edge pair in
        micron units to an integer-coordinate edge pair in database units. The edge pair's'
        coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Returns a string representing the edge pair'''

    def transformed(self, ...):
        '''@brief Returns the transformed edge pair @args t

        Transforms the edge pair with the given complex transformation. Does not modify the edge
        pair but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge pair'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor from two edges

        This constructor creates an edge pair from the two edges given.'''


class DPath:
    '''@brief A path class

    A path consists of an sequence of line segments forming the 'spine' of the path and a width. In
    addition, the starting point can be drawn back by a certain extent (the 'begin extension') and
    the end point can be pulled forward somewhat (by the 'end extension').

    A path may have round ends for special purposes. In particular, a round-ended path with a single
    point can represent a circle. Round-ended paths should have being and end extensions equal to
    half the width. Non-round-ended paths with a single point are allowed but the definition of the
    resulting shape in not well defined and may differ in other tools.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Get the begin extension

     @brief Set the begin extension @args ext'''
    bgn_ext = None

    '''@brief Get the end extension

     @brief Set the end extension @args ext'''
    end_ext = None

    '''@brief Get the number of points

    @brief Set the points of the path @args p @param p An array of points to assign to the path's
    spine'''
    points = None

    '''@brief Set the 'round ends' flag @args round_ends_flag A path with round ends show half
    circles at the ends, instead of square or rectangular ends. Paths with this flag set should use
    a begin and end extension of half the width (see \\bgn_ext and \\end_ext). The interpretation of
    such paths in other tools may differ otherwise.'''
    round = None

    '''@brief Get the width

     @brief Set the width @args w'''
    width = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test @args p @param p The object to compare against'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor given the points of the path's spine, the width, the extensions and
        the round end flag

        @args pts, width, bgn_ext, end_ext, round

        @param pts The points forming the spine of the path @param width The width of the path
        @param bgn_ext The begin extension of the path @param end_ext The end extension of the path
        @param round If this flag is true, the path will get rounded ends'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args p @param p The object to compare against This operator is
        provided to establish some, not necessarily a certain sorting order'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test @args p @param p The object to compare against'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert to a string'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief Returns the approximate area of the path This method returns the approximate value
        of the area. It is computed from the length times the width. end extensions are taken into
        account correctly, but not effects of the corner interpolation. This method was added in
        version 0.22.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Returns the bounding box of the path'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_point(self, ...):
        '''@brief Get the points that make up the path's spine'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_round(self, ...):
        '''@brief Returns true, if the path has round ends'''

    def length(self, ...):
        '''@brief Returns the length of the path the length of the path is determined by summing the
        lengths of the segments and adding begin and end extensions. For round-ended paths the
        length of the paths between the tips of the ends.

        This method was added in version 0.23.'''

    def move(self, ...):
        '''@brief Moves the path. @args dx, dy

        Moves the path by the given offset and returns the  moved path. The path is overwritten.

        @param dx The x distance to move the path. @param dy The y distance to move the path.

        @return The moved path.

        This version has been added in version 0.23.'''

    def moved(self, ...):
        '''@brief Returns the moved path (does not change self) @args dx, dy

        Moves the path by the given offset and returns the  moved path. The path is not modified.

        @param dx The x distance to move the path. @param dy The y distance to move the path.

        @return The moved path.

        This version has been added in version 0.23.'''

    def num_points(self, ...):
        '''@brief Get the number of points'''

    def perimeter(self, ...):
        '''@brief Returns the approximate perimeter of the path This method returns the approximate
        value of the perimeter. It is computed from the length and the width. end extensions are
        taken into account correctly, but not effects of the corner interpolation. This method was
        added in version 0.24.4.'''

    def polygon(self, ...):
        '''@brief Convert the path to a polygon The returned polygon is not guaranteed to be non-
        self overlapping. This may happen if the path overlaps itself or contains very short
        segments.'''

    def round_corners(self, ...):
        '''@brief Creates a new path whose corners are interpolated with circular bends

        @param radius The radius of the bends @param npoints The number of points (per full circle)
        used for interpolating the bends @param accuracy The numerical accuracy of the computation

        The accuracy parameter controls the numerical resolution of the approximation process and
        should be in the order of half the database unit. This accuracy is used for suppressing
        redundant points and simplication of the resulting path.

        This method has been introduced in version 0.25.'''

    def simple_polygon(self, ...):
        '''@brief Convert the path to a simple polygon The returned polygon is not guaranteed to be
        non-selfoverlapping. This may happen if the path overlaps itself or contains very short
        segments.'''

    def to_itype(self, ...):
        '''@brief Converts the path to an integer coordinate path

        The database unit can be specified to translate the floating-point coordinate path in micron
        units to an integer-coordinate path in database units. The path's' coordinates will be
        divided by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Convert to a string'''

    def transformed(self, ...):
        '''@brief Transform the path. @args t

        Transforms the path with the given complex transformation. Does not modify the path but
        returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path.'''

    def transformed_cplx(self, ...):
        '''@brief Transform the path. @args t

        Transforms the path with the given complex transformation. Does not modify the path but
        returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_ipath(cls, ...):
        '''@brief Creates a floating-point coordinate path from an integer coordinate path

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_ipath'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor given the points of the path's spine, the width, the extensions and
        the round end flag

        @args pts, width, bgn_ext, end_ext, round

        @param pts The points forming the spine of the path @param width The width of the path
        @param bgn_ext The begin extension of the path @param end_ext The end extension of the path
        @param round If this flag is true, the path will get rounded ends'''

    @classmethod
    def new_pw(cls, ...):
        '''@brief Constructor given the points of the path's spine and the width

        @args pts, width

        @param pts The points forming the spine of the path @param width The width of the path'''

    @classmethod
    def new_pwx(cls, ...):
        '''@brief Constructor given the points of the path's spine, the width and the extensions

        @args pts, width, bgn_ext, end_ext

        @param pts The points forming the spine of the path @param width The width of the path
        @param bgn_ext The begin extension of the path @param end_ext The end extension of the
        path'''

    @classmethod
    def new_pwxr(cls, ...):
        '''@brief Constructor given the points of the path's spine, the width, the extensions and
        the round end flag

        @args pts, width, bgn_ext, end_ext, round

        @param pts The points forming the spine of the path @param width The width of the path
        @param bgn_ext The begin extension of the path @param end_ext The end extension of the path
        @param round If this flag is true, the path will get rounded ends'''


class DPoint:
    '''@brief A point class with double (floating-point) coordinates Points represent a coordinate
    in the two-dimensional coordinate space of layout. They are not geometrical objects by itself.
    But they are frequently used in the database API for various purposes. Other than the integer
    variant (\\Point), points with floating-point coordinates can represent fractions of a database
    unit.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Accessor to the x coordinate

     @brief Write accessor to the x coordinate @args coord'''
    x = None

    '''@brief Accessor to the y coordinate

     @brief Write accessor to the y coordinate @args coord'''
    y = None

    # Methods
    def __add__(self, ...):
        '''@brief Adds a vector to a point

        @args v

        Adds vector v to self by adding the coordinates.

        Starting with version 0.25, this method expects a vector argument.'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test operator

        @args p'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given point. This method
        enables points as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor for a point from two coordinate values

        @args x, y'''

    def __itruediv__(self, ...):
        '''@brief Division by some divisor

        @args d

        Divides the object in place. All coordinates are divided with the given divisor and if
        necessary rounded.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief "less" comparison operator

        @args p

        This operator is provided to establish a sorting order'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test operator

        @args p'''

    def __neg__(self, ...):
        '''@brief Compute the negative of a point

        @args p

        Returns a new point with -x, -y.

        This method has been added in version 0.23.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def __sub__(self, ...):
        '''@brief Subtract one point from another

        @args p

        Subtract point p from self by subtracting the coordinates. This renders a vector.

        Starting with version 0.25, this method renders a vector.'''

    def __truediv__(self, ...):
        '''@brief Division by some divisor

        @args d

        Returns the scaled object. All coordinates are divided with the given divisor and if
        necessary rounded.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def abs(self, ...):
        '''@brief The absolute value of the point (Euclidian distance to 0,0)

        The returned value is 'sqrt(x*x+y*y)'.

        This method has been introduced in version 0.23.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def distance(self, ...):
        '''@brief The Euclidian distance to another point

        @args d

        @param d The other point to compute the distance to.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given point. This method
        enables points as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def sq_abs(self, ...):
        '''@brief The square of the absolute value of the point (Euclidian distance to 0,0)

        The returned value is 'x*x+y*y'.

        This method has been introduced in version 0.23.'''

    def sq_distance(self, ...):
        '''@brief The square Euclidian distance to another point

        @args d

        @param d The other point to compute the distance to.'''

    def to_itype(self, ...):
        '''@brief Converts the point to an integer coordinate point

        The database unit can be specified to translate the floating-point coordinate point in
        micron units to an integer-coordinate point in database units. The point's' coordinates will
        be divided by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def to_v(self, ...):
        '''@brief Turns the point into a vector This method returns a vector representing the
        distance from (0,0) to the point.This method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_ipoint(cls, ...):
        '''@brief Creates a floating-point coordinate point from an integer coordinate point

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_ipoint'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor for a point from two coordinate values

        @args x, y'''


class DPolygon:
    '''@brief A polygon class

    A polygon consists of an outer hull and zero to many holes. Each contour consists of several
    points. The point list is normalized such that the leftmost, lowest point is  the first one. The
    orientation is normalized such that the orientation of the hull contour is clockwise, while the
    orientation of the holes is counterclockwise.

    It is in no way checked that the contours are not overlapping. This must be ensured by the user
    of the object when filling the contours.

    A polygon can be asked for the number of holes using the \\holes method. \\each_point_hull
    delivers the points of the hull contour. \\each_point_hole delivers the points of a specific
    hole. \\each_edge delivers the edges (point-to-point connections) of both hull and holes. \\bbox
    delivers the bounding box, \\area the area and \\perimeter the perimeter of the polygon.

    Here's an example of how to create a polygon:

    @code hull =  [ RBA::DPoint::new(0, 0),       RBA::DPoint::new(6000, 0),
    RBA::DPoint::new(6000, 3000), RBA::DPoint::new(0, 3000) ] hole1 = [ RBA::DPoint::new(1000,
    1000), RBA::DPoint::new(2000, 1000),            RBA::DPoint::new(2000, 2000),
    RBA::DPoint::new(1000, 2000) ] hole2 = [ RBA::DPoint::new(3000, 1000), RBA::DPoint::new(4000,
    1000),            RBA::DPoint::new(4000, 2000), RBA::DPoint::new(3000, 2000) ] poly =
    RBA::DPolygon::new(hull) poly.insert_hole(hole1) poly.insert_hole(hole2)

    # ask the polygon for some properties poly.holes      # -> 2 poly.area       # -> 16000000.0
    poly.perimeter  # -> 26000.0 poly.bbox       # -> (0,0;6000,3000) @/code

    The \\DPolygon class stores coordinates in floating-point format which gives a higher precision
    for some operations. A class that stores integer coordinates is \\Polygon.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Set the points of the hull of polygon @args p @param p An array of points to assign to
    the polygon's hull The 'assign_hull' variant is provided in analogy to 'assign_hole'.'''
    hull = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test @args p @param p The object to compare against'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor converting a box to a polygon

        @args box

        @param box The box to convert to a polygon'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args p @param p The object to compare against This operator is
        provided to establish some, not necessarily a certain sorting order'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test @args p @param p The object to compare against'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert to a string'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief The area of the polygon The area is correct only if the polygon is not self-
        overlapping and the polygon is oriented clockwise.Orientation is ensured automatically in
        most cases.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def assign_hole(self, ...):
        '''@brief Set the box as the given hole of the polygon @args n,b @param n The index of the
        hole to which the points should be assigned @param b The box to assign to the polygon's hole
        If the hole index is not valid, this method does nothing. This method was introduced in
        version 0.23.'''

    def assign_hull(self, ...):
        '''@brief Set the points of the hull of polygon @args p @param p An array of points to
        assign to the polygon's hull @param raw If true, the points won't be compressed

        If the 'raw' argument is set to true, the points are taken as they are. Specifically no
        removal of redundant points or joining of coincident edges will take place. In effect,
        polygons consisting of a single point or two points can be constructed as well as polygons
        with duplicate points. Note that such polygons may cause problems in some applications.

        Regardless of raw mode, the point list will be adjusted such that the first point is the
        lowest-leftmost one and the orientation is clockwise always.

        The 'assign_hull' variant is provided in analogy to 'assign_hole'.

        The 'raw' argument was added in version 0.24.'''

    def bbox(self, ...):
        '''@brief Return the bounding box of the polygon The bounding box is the box enclosing all
        points of the polygon.'''

    def compress(self, ...):
        '''@brief Compress the polygon. @args remove_reflected

        This method removes redundant points from the polygon, such as points being on a line formed
        by two other points. If remove_reflected is true, points are also removed if the two
        adjacent edges form a spike.

        @param remove_reflected See description of the functionality.

        This method was introduced in version 0.18.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_edge(self, ...):
        '''@brief Iterate over the edges of one contour of the polygon

        @args contour @param contour The contour number (0 for hull, 1 for first hole ...)

        This iterator will deliver all edges of the contour specified by the contour parameter. The
        hull has contour number 0, the first hole has contour 1 etc. Hole edges are oriented
        counterclockwise while hull egdes are oriented clockwise.

        This method was introduced in version 0.24.'''

    def each_point_hole(self, ...):
        '''@brief Iterate over the points that make up the nth hole @args n The hole number must be
        less than the number of holes (see \\holes)'''

    def each_point_hull(self, ...):
        '''@brief Iterate over the points that make up the hull'''

    def extract_rad(self, ...):
        '''@brief Extracts the corner radii from a rounded polygon

        Attempts to extract the radii of rounded corner polygon. This is essentially the inverse of
        the \\round_corners method. If this method succeeds, if will return an array of four
        elements: @ul @li The polygon with the rounded corners replaced by edgy ones @/li @li The
        radius of the inner corners @/li @li The radius of the outer corners @/li @li The number of
        points per full circle @/li @/ul

        This method is based on some assumptions and may fail. In this case, an empty array is
        returned.

        If successful, the following code will more or less render the original polygon and
        parameters

        @code p = ...   # some polygon p.round_corners(ri, ro, n) (p2, ri2, ro2, n2) = p.extract_rad
        # -> p2 == p, ro2 == ro, ri2 == ri, n2 == n (within some limits) @/code

        This method was introduced in version 0.25.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def holes(self, ...):
        '''@brief Returns the number of holes'''

    def insert_hole(self, ...):
        '''@brief Insert a hole from the given box @args b @param b The box to insert as a new hole
        This method was introduced in version 0.23.'''

    def inside(self, ...):
        '''@brief Test, if the given point is inside the polygon @args p If the given point is
        inside or on the edge of the polygon, true is returned. This tests works well only if the
        polygon is not self-overlapping and oriented clockwise. '''

    def is_box(self, ...):
        '''@brief Returns true, if the polygon is a simple box.

        A polygon is a box if it is identical to it's bounding box.

        @return True if the polygon is a box.

        This method was introduced in version 0.23.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def move(self, ...):
        '''@brief Moves the polygon. @args x,y

        Moves the polygon by the given offset and returns the  moved polygon. The polygon is
        overwritten.

        @param x The x distance to move the polygon. @param y The y distance to move the polygon.

        @return The moved polygon (self).'''

    def moved(self, ...):
        '''@brief Returns the moved polygon (does not modify self) @args x,y

        Moves the polygon by the given offset and returns the  moved polygon. The polygon is not
        modified.

        @param x The x distance to move the polygon. @param y The y distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.'''

    def num_points(self, ...):
        '''@brief Get the total number of points (hull plus holes) This method was introduced in
        version 0.18.'''

    def num_points_hole(self, ...):
        '''@brief Get the number of points of the given hole @args n The argument gives the index of
        the hole of which the number of points are requested. The index must be less than the number
        of holes (see \\holes). '''

    def num_points_hull(self, ...):
        '''@brief Get the number of points of the hull'''

    def perimeter(self, ...):
        '''@brief The perimeter of the polygon The perimeter is sum of the lengths of all edges
        making up the polygon.

        This method has been introduce in version 0.23.'''

    def point_hole(self, ...):
        '''@brief Get a specific point of a hole @args n,p @param n The index of the hole to which
        the points should be assigned @param p The index of the point to get If the index of the
        point or of the hole is not valid, a default value is returned. This method was introduced
        in version 0.18.'''

    def point_hull(self, ...):
        '''@brief Get a specific point of the hull @args p @param p The index of the point to get If
        the index of the point is not a valid index, a default value is returned. This method was
        introduced in version 0.18.'''

    def round_corners(self, ...):
        '''@brief Rounds the corners of the polygon @args rinner, router, n

        Replaces the corners of the polygon with circle segments.

        @param rinner The circle radius of inner corners (in database units). @param router The
        circle radius of outer corners (in database units). @param n The number of points per full
        circle.

        @return The new polygon.

        This method was introduced in version 0.20 for integer coordinates and in 0.25 for all
        coordinate types.'''

    def size(self, ...):
        '''@brief Sizing (biasing) @args d

        Shifts the contour outwards (d>0) or inwards (d<0). This method is equivalent to @code
        size(d, d, 2) @/code

        See \\size for a detailed description.'''

    def sized(self, ...):
        '''@brief Sizing (biasing) @args d

        @brief Sizing (biasing) without modifying self This method is equivalent to @code sized(d,
        d, 2) @/code

        See \\size and \\sized for a detailed description.'''

    def split(self, ...):
        '''@brief Splits the polygon into two or more parts This method will break the polygon into
        parts. The exact breaking algorithm is unspecified, the result are smaller polygons of
        roughly equal number of points and 'less concave' nature. Usually the returned polygon set
        consists of two polygons, but there can be more. The merged region of the resulting polygons
        equals the original polygon with the exception of small snapping effects at new vertexes.

        The intended use for this method is a iteratively split polygons until the satisfy some
        maximum number of points limit.

        This method has been introduced in version 0.25.3.'''

    def to_itype(self, ...):
        '''@brief Converts the polygon to an integer coordinate polygon

        The database unit can be specified to translate the floating-point coordinate polygon in
        micron units to an integer-coordinate polygon in database units. The polygons coordinates
        will be divided by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Convert to a string'''

    def touches(self, ...):
        '''@brief Returns true, if the polygon touches the other polygon. The polygons touch if they
        overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.'''

    def transform(self, ...):
        '''@brief Transforms the polygon (in-place) @args t

        Transforms the polygon with the given transformation. Modifies self and returns self. An
        out-of-place version which does not modify self is \\transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.'''

    def transformed(self, ...):
        '''@brief Transforms the polygon with a complex transformation @args t

        Transforms the polygon with the given complex transformation. Does not modify the polygon
        but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed'
        takes both simple and complex transformations.'''

    def transformed_cplx(self, ...):
        '''@brief Transforms the polygon with a complex transformation @args t

        Transforms the polygon with the given complex transformation. Does not modify the polygon
        but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed'
        takes both simple and complex transformations.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def ellipse(cls, ...):
        '''@brief Creates a simple polygon appoximating an ellipse

        @args box, n

        @param box The bounding box of the ellipse @param n The number of points that will be used
        to approximate the ellipse

        This method has been introduced in version 0.23.'''

    @classmethod
    def from_ipoly(cls, ...):
        '''@brief Creates a floating-point coordinate polygon from an integer coordinate polygon

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_ipolygon'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor converting a box to a polygon

        @args box

        @param box The box to convert to a polygon'''


class DSimplePolygon:
    '''@brief A simple polygon class

    A simple polygon consists of an outer hull only. To support polygons with holes, use \\DPolygon.
    The contour consists of several points. The point list is normalized such that the leftmost,
    lowest point is  the first one. The orientation is normalized such that the orientation of the
    hull contour is clockwise.

    It is in no way checked that the contours are not over- lapping. This must be ensured by the
    user of the object when filling the contours.

    The \\DSimplePolygon class stores coordinates in floating-point format which gives a higher
    precision for some operations. A class that stores integer coordinates is \\SimplePolygon.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Set the points of the simple polygon

    @args pts @param pts An array of points to assign to the simple polygon

    See the constructor description for details about raw mode.'''
    points = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test @args p @param p The object to compare against'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor converting a box to a polygon

        @args box

        @param box The box to convert to a polygon'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args p @param p The object to compare against This operator is
        provided to establish some, not necessarily a certain sorting order

        This method has been introduced in version 0.25.'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test @args p @param p The object to compare against'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert to a string'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief The area of the polygon The area is correct only if the polygon is not self-
        overlapping and the polygon is oriented clockwise.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Return the bounding box of the simple polygon'''

    def compress(self, ...):
        '''@brief Compress the simple polygon. @args remove_reflected

        This method removes redundant points from the polygon, such as points being on a line formed
        by two other points. If remove_reflected is true, points are also removed if the two
        adjacent edges form a spike.

        @param remove_reflected See description of the functionality.

        This method was introduced in version 0.18.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_edge(self, ...):
        '''@brief Iterate over the edges that make up the simple polygon'''

    def each_point(self, ...):
        '''@brief Iterate over the points that make up the simple polygon'''

    def extract_rad(self, ...):
        '''@brief Extracts the corner radii from a rounded polygon

        Attempts to extract the radii of rounded corner polygon. This is essentially the inverse of
        the \\round_corners method. If this method succeeds, if will return an array of four
        elements: @ul @li The polygon with the rounded corners replaced by edgy ones @/li @li The
        radius of the inner corners @/li @li The radius of the outer corners @/li @li The number of
        points per full circle @/li @/ul

        This method is based on some assumptions and may fail. In this case, an empty array is
        returned.

        If successful, the following code will more or less render the original polygon and
        parameters

        @code p = ...   # some polygon p.round_corners(ri, ro, n) (p2, ri2, ro2, n2) = p.extract_rad
        # -> p2 == p, ro2 == ro, ri2 == ri, n2 == n (within some limits) @/code

        This method was introduced in version 0.25.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def inside(self, ...):
        '''@brief Test, if the given point is inside the polygon @args p If the given point is
        inside or on the edge the polygon, true is returned. This tests works well only if the
        polygon is not self-overlapping and oriented clockwise. '''

    def is_box(self, ...):
        '''@brief Returns true, if the polygon is a simple box.

        A polygon is a box if it is identical to it's bounding box.

        @return True if the polygon is a box.

        This method was introduced in version 0.23.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def move(self, ...):
        '''@brief Moves the polygon. @args x,y

        Moves the polygon by the given offset and returns the  moved polygon. The polygon is
        overwritten.

        @param x The x distance to move the polygon. @param y The y distance to move the polygon.

        @return The moved polygon (self).'''

    def moved(self, ...):
        '''@brief Returns the moved polygon (does not modify self) @args x,y

        Moves the polygon by the given offset and returns the  moved polygon. The polygon is not
        modified.

        @param x The x distance to move the polygon. @param y The y distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.'''

    def num_points(self, ...):
        '''@brief Get the number of points'''

    def perimeter(self, ...):
        '''@brief The perimeter of the polygon The perimeter is sum of the lengths of all edges
        making up the polygon.'''

    def point(self, ...):
        '''@brief Get a specific point of the contour@args p @param p The index of the point to get
        If the index of the point is not a valid index, a default value is returned. This method was
        introduced in version 0.18.'''

    def round_corners(self, ...):
        '''@brief Round the corners of the polygon @args rinner, router, n

        Replaces the corners of the polygon with circle segments.

        @param rinner The circle radius of inner corners (in database units). @param router The
        circle radius of outer corners (in database units). @param n The number of points per full
        circle.

        @return The new polygon.

        This method was introduced in version 0.22 for integer coordinates and in 0.25 for all
        coordinate types.'''

    def set_points(self, ...):
        '''@brief Set the points of the simple polygon

        @param pts An array of points to assign to the simple polygon @param raw If true, the points
        are taken as they are

        See the constructor description for details about raw mode.

        This method has been added in version 0.24.'''

    def split(self, ...):
        '''@brief Splits the polygon into two or more parts This method will break the polygon into
        parts. The exact breaking algorithm is unspecified, the result are smaller polygons of
        roughly equal number of points and 'less concave' nature. Usually the returned polygon set
        consists of two polygons, but there can be more. The merged region of the resulting polygons
        equals the original polygon with the exception of small snapping effects at new vertexes.

        The intended use for this method is a iteratively split polygons until the satisfy some
        maximum number of points limit.

        This method has been introduced in version 0.25.3.'''

    def to_itype(self, ...):
        '''@brief Converts the polygon to an integer coordinate polygon The database unit can be
        specified to translate the floating-point coordinate polygon in micron units to an integer-
        coordinate polygon in database units. The polygon's' coordinates will be divided by the
        database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Convert to a string'''

    def touches(self, ...):
        '''@brief Returns true, if the polygon touches the other polygon. The polygons touch if they
        overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.'''

    def transform(self, ...):
        '''@brief Transforms the simple polygon (in-place) @args t

        Transforms the simple polygon with the given transformation. Modifies self and returns self.
        An out-of-place version which does not modify self is \\transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.'''

    def transformed(self, ...):
        '''@brief Transforms the simple polygon. @args t

        Transforms the simple polygon with the given complex transformation. Does not modify the
        simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed'
        takes both simple and complex transformations.'''

    def transformed_cplx(self, ...):
        '''@brief Transforms the simple polygon. @args t

        Transforms the simple polygon with the given complex transformation. Does not modify the
        simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed'
        takes both simple and complex transformations.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def ellipse(cls, ...):
        '''@brief Creates a simple polygon appoximating an ellipse

        @args box, n

        @param box The bounding box of the ellipse @param n The number of points that will be used
        to approximate the ellipse

        This method has been introduced in version 0.23.'''

    @classmethod
    def from_ipoly(cls, ...):
        '''@brief Creates a floating-point coordinate polygon from an integer coordinate polygon
        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_ipoly'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor converting a box to a polygon

        @args box

        @param box The box to convert to a polygon'''


class DText:
    '''@brief A text object

    A text object has a point (location), a text, a text transformation, a text size and a font id.
    Text size and font id are provided to be be able to render the text correctly. Text objects are
    used as labels (i.e. for pins) or to indiciate a particular position.

    The \\DText class uses floating-point coordinates. A class that operates with integer
    coordinates is \\Text.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Get the font number

     @brief Set the font number @args f'''
    font = None

    '''@brief Get the horizontal alignment

    See \\halign= for a description of this property.

     @brief Set the horizontal alignment @args a

    This property specifies how the text is aligned relative to the anchor point. Allowed values for
    this property are 0 (left), 1 (center) and 2 (right). This property has been introduced in
    version 0.22.'''
    halign = None

    '''@brief Get the text height

     @brief Set the text height of this object @args s'''
    size = None

    '''@brief Get the text string

     @brief Assign a text string to this object @args text'''
    string = None

    '''@brief Get the transformation

     @brief Assign a transformation (text position and orientation) to this object @args t'''
    trans = None

    '''@brief Get the vertical alignment

    See \\valign= for a description of this property.

     @brief Set the vertical alignment @args a

    This property specifies how the text is aligned relative to the anchor point. Allowed values for
    this property are 0 (top), 1 (center) and 2 (bottom). This property has been introduced in
    version 0.22.'''
    valign = None

    '''@brief Gets the x location of the text

    This method has been introduced in version 0.23.

     @brief Sets the x location of the text @args x

    This method has been introduced in version 0.23.'''
    x = None

    '''@brief Gets the y location of the text

    This method has been introduced in version 0.23.

     @brief Sets the y location of the text @args y

    This method has been introduced in version 0.23.'''
    y = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality

        @args text

        Return true, if this text object and the given text are equal '''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given text object. This method
        enables texts as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor with string, transformation, text height and font

        @args string, trans, height, font

        A string and a transformation is provided to this constructor. The transformation specifies
        the location and orientation of the text object. In addition, the text height and font can
        be specified.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args t @param t The object to compare against This operator is
        provided to establish some, not necessarily a certain sorting order'''

    def __ne__(self, ...):
        '''@brief Inequality

        @args text

        Return true, if this text object and the given text are not equal '''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert to a string'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given text object. This method
        enables texts as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def move(self, ...):
        '''@brief Moves the text by a certain distance (modifies self)

        @args dx, dy

        Moves the text by a given distance in x and y direction and returns the moved text. Does not
        check for coordinate overflows.

        @param dx The x distance to move the text. @param dy The y distance to move the text.

        @return A reference to this text object

        This method was introduced in version 0.23.'''

    def moved(self, ...):
        '''@brief Returns the text moved by a certain distance (does not modify self)

        @args dx, dy

        Moves the text by a given offset and returns the moved text. Does not modify *this. Does not
        check for coordinate overflows.

        @param dx The x distance to move the text. @param dy The y distance to move the text.

        @return The moved text.

        This method was introduced in version 0.23.'''

    def to_itype(self, ...):
        '''@brief Converts the text to an integer coordinate text

        The database unit can be specified to translate the floating-point coordinate Text in micron
        units to an integer-coordinate text in database units. The text's coordinates will be
        divided by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Convert to a string'''

    def transformed(self, ...):
        '''@brief Transform the text with the given complex transformation

        @args t

        @param t The magnifying transformation to apply @return The transformed text (a DText
        now)'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor with string, transformation, text height and font

        @args string, trans, height, font

        A string and a transformation is provided to this constructor. The transformation specifies
        the location and orientation of the text object. In addition, the text height and font can
        be specified.'''


class DTrans:
    '''@brief A simple transformation

    Simple transformations only provide rotations about angles which a multiples of 90 degree.
    Together with the mirror options, this results in 8 distinct orientations (fixpoint
    transformations). These can be combined with a displacement which is applied after the
    rotation/mirror. This version acts on floating-point coordinates. A version for integer
    coordinates is \\Trans.

    Here are some examples for using the DTrans class:

    @code t = RBA::DTrans::new(0, 100)  # displacement by 100 DBU in y direction # the inverse: ->
    "r0 0,-100" t.inverted.to_s # concatenation: -> "r90 -100,0" (RBA::DTrans::new(RBA::DTrans::R90)
    * t).to_s # apply to a point: -> "0,100"
    RBA::DTrans::new(RBA::DTrans::R90).trans(RBA::DPoint::new(100, 0)) @/code

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the angle in units of 90 degree

    This value delivers the rotation component. In addition, a mirroring at the x axis may be
    applied before if the \\is_mirror? property is true.

    @brief Sets the angle in units of 90 degree @param a The new angle

    This method was introduced in version 0.20.'''
    angle = None

    '''@brief Gets to the displacement vector

    Staring with version 0.25 the displacement type is a vector.

    @brief Sets the displacement @param u The new displacement

    This method was introduced in version 0.20. Staring with version 0.25 the displacement type is a
    vector.'''
    disp = None

    '''@brief Sets the mirror flag "mirroring" describes a reflection at the x-axis which is
    included in the transformation prior to rotation.@param m The new mirror flag

    This method was introduced in version 0.20.'''
    mirror = None

    '''@brief Gets the angle/mirror code

    The angle/mirror code is one of the constants R0, R90, R180, R270, M0, M45, M90 and M135. rx is
    the rotation by an angle of x counter clockwise. mx is the mirroring at the axis given by the
    angle x (to the x-axis).

    @brief Sets the angle/mirror code @param r The new angle/rotation code (see \\rot property)

    This method was introduced in version 0.20.'''
    rot = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Tests for equality'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a transformation using a displacement given as two coordinates

        @param x The horizontal displacement @param y The vertical displacement'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Provides a 'less' criterion for sorting This method is provided to implement a
        sorting order. The definition of 'less' is opaque and might change in future versions.'''

    def __mul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __ne__(self, ...):
        '''@brief Tests for inequality'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def ctrans(self, ...):
        '''@brief Transforms a distance

        The "ctrans" method transforms the given distance. e = t(d). For the simple transformations,
        there is no magnification and no modification of the distance therefore.

        @param d The distance to transform @return The transformed distance'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def invert(self, ...):
        '''@brief Inverts the transformation (in place)

        Inverts the transformation and replaces this object by the inverted one.

        @return The inverted transformation'''

    def inverted(self, ...):
        '''@brief Returns the inverted transformation Returns the inverted transformation

        @return The inverted transformation'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mirror(self, ...):
        '''@brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis
        followed by a rotation by the angle given by the \\angle property. '''

    def to_itype(self, ...):
        '''@brief Converts the transformation to an integer coordinate transformation

        The database unit can be specified to translate the floating-point coordinate transformation
        in micron units to an integer-coordinate transformation in database units. The
        transformation's' coordinates will be divided by the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def trans(self, ...):
        '''@brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform @return The transformed text

        This convenience method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_itrans(cls, ...):
        '''@brief Creates a floating-point coordinate transformation from an integer coordinate
        transformation

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_itrans'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates a transformation from a string Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a transformation using a displacement given as two coordinates

        @param x The horizontal displacement @param y The vertical displacement'''


class DVector:
    '''@brief A vector class with double (floating-point) coordinates A vector is a distance in
    cartesian, 2 dimensional space. A vector is given by two coordinates (x and y) and represents
    the distance between two points. Being the distance, transformations act differently on vectors:
    the displacement is not applied.  Vectors are not geometrical objects by itself. But they are
    frequently used in the database API for various purposes. Other than the integer variant
    (\\Vector), points with floating-point coordinates can represent fractions of a database unit or
    vectors in physical (micron) units.

    This class has been introduced in version 0.25.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Accessor to the x coordinate

     @brief Write accessor to the x coordinate @args coord'''
    x = None

    '''@brief Accessor to the y coordinate

     @brief Write accessor to the y coordinate @args coord'''
    y = None

    # Methods
    def __add__(self, ...):
        '''@brief Adds a vector and a point

        @args p

        Returns the point p shifted by the vector.'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test operator

        @args v'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given vector. This method
        enables vectors as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor for a vector from two coordinate values

        @args x, y'''

    def __itruediv__(self, ...):
        '''@brief Division by some divisor

        @args d

        Divides the object in place. All coordinates are divided with the given divisor and if
        necessary rounded.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief "less" comparison operator

        @args v

        This operator is provided to establish a sorting order'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test operator

        @args v'''

    def __neg__(self, ...):
        '''@brief Compute the negative of a vector

        @args p

        Returns a new vector with -x,-y.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def __sub__(self, ...):
        '''@brief Subtract two vectors

        @args v

        Subtract vector v from self by subtracting the coordinates.'''

    def __truediv__(self, ...):
        '''@brief Division by some divisor

        @args d

        Returns the scaled object. All coordinates are divided with the given divisor and if
        necessary rounded.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def abs(self, ...):
        '''@brief Returns the length of the vector 'abs' is an alias provided for compatibility with
        the former point type.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given vector. This method
        enables vectors as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def length(self, ...):
        '''@brief Returns the length of the vector 'abs' is an alias provided for compatibility with
        the former point type.'''

    def sprod(self, ...):
        '''@brief Computes the scalar product between self and the given vector

        @args v

        The scalar product of a and b is defined as: vp = ax*bx+ay*by.'''

    def sprod_sign(self, ...):
        '''@brief Computes the scalar product between self and the given vector and returns a value
        indicating the sign of the product

        @args v

        @return 1 if the scalar product is positive, 0 if it is zero and -1 if it is negative.'''

    def sq_abs(self, ...):
        '''@brief The square length of the vector 'sq_abs' is an alias provided for compatibility
        with the former point type.'''

    def sq_length(self, ...):
        '''@brief The square length of the vector 'sq_abs' is an alias provided for compatibility
        with the former point type.'''

    def to_itype(self, ...):
        '''@brief Converts the point to an integer coordinate point

        The database unit can be specified to translate the floating-point coordinate vector in
        micron units to an integer-coordinate vector in database units. The vector's' coordinates
        will be divided by the database unit.'''

    def to_p(self, ...):
        '''@brief Turns the vector into a point This method returns the point resulting from adding
        the vector to (0,0). This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def vprod(self, ...):
        '''@brief Computes the vector product between self and the given vector

        @args v

        The vector product of a and b is defined as: vp = ax*by-ay*bx.'''

    def vprod_sign(self, ...):
        '''@brief Computes the vector product between self and the given vector and returns a value
        indicating the sign of the product

        @args v

        @return 1 if the vector product is positive, 0 if it is zero and -1 if it is negative.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor for a vector from two coordinate values

        @args x, y'''


class Edge:
    '''@brief An edge class

    An edge is a connection between points, usually participating in a larger context such as a
    polygon. An edge has a defined direction (from p1 to p2). Edges play a role in the database as
    parts of polygons and to describe a line through both points. Altough supported, edges are
    rarely used as individual database objects.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects like the Edge class. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief The first point.

     @brief Sets the first point. @args point This method has been added in version 0.23.'''
    p1 = None

    '''@brief The second point.

     @brief Sets the second point. @args point This method has been added in version 0.23.'''
    p2 = None

    '''@brief Shortcut for p1.x

     @brief Sets p1.x @args coord This method has been added in version 0.23.'''
    x1 = None

    '''@brief Shortcut for p2.x

     @brief Sets p2.x @args coord This method has been added in version 0.23.'''
    x2 = None

    '''@brief Shortcut for p1.y

     @brief Sets p1.y @args coord This method has been added in version 0.23.'''
    y1 = None

    '''@brief Shortcut for p2.y

     @brief Sets p2.y @args coord This method has been added in version 0.23.'''
    y2 = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test @args e @param e The object to compare against'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given edge. This method enables
        edges as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor with two points

        @args p1, p2

        Two points are given to create a new edge.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args e @param e The object to compare against @return True, if the
        edge is 'less' as the other edge with respect to first and second point'''

    def __mul__(self, ...):
        '''@brief Scale edge

        @args scale_factor

        The * operator scales self with the given factor.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled edge'''

    def __ne__(self, ...):
        '''@brief Inequality test @args e @param e The object to compare against'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Returns a string representing the edge'''

    def __rmul__(self, ...):
        '''@brief Scale edge

        @args scale_factor

        The * operator scales self with the given factor.

        This method has been introduced in version 0.22.

        @param scale_factor The scaling factor

        @return The scaled edge'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Returns a string representing the edge'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Return the bounding box of the edge.'''

    def coincident(self, ...):
        '''@brief Coincidence check. @args e

        Checks whether a edge is coincident with another edge.  Coincidence is defined by being
        parallel and that  at least one point of one edge is on the other edge.

        @param e the edge to test with

        @return True if the edges are coincident.'''

    def contains(self, ...):
        '''@brief Test whether a point is on an edge. @args p

        A point is on a edge if it is on (or at least closer  than a grid point to) the edge.

        @param p The point to test with the edge.

        @return True if the point is on the edge.'''

    def contains_excl(self, ...):
        '''@brief Test whether a point is on an edge excluding the endpoints. @args p

        A point is on a edge if it is on (or at least closer  than a grid point to) the edge.

        @param p The point to test with the edge.

        @return True if the point is on the edge but not equal p1 or p2.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def crossed_by(self, ...):
        '''@brief Check, if an edge is cut by a line (given by an edge) @args e

        This method returns true if p1 is in one semispace  while p2 is in the other or one of them
        is on the line through the edge "e"

        @param e The edge representing the line that the edge must be crossing.'''

    def crossing_point(self, ...):
        '''@brief Returns the crossing point on two edges.  @args e

        This method delivers the point where the given edge (self) crosses the line given by the
        edge in argument "e". If self does not cross this line, the result is undefined. See
        \\crossed_by? for a description of the crossing predicate.

        @param e The edge representing the line that self must be crossing. @return The point where
        self crosses the line given by "e".

        This method has been introduced in version 0.19.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def distance(self, ...):
        '''@brief Distance between the edge and a point. @args p

        Returns the distance between the edge and the point. The  distance is signed which is
        negative if the point is to the "left" of the edge and positive if the point is to the
        "right". The distance is measured by projecting the point onto the line through the edge. If
        the edge is degenerated, the distance is not defined.

        @param p The point to test.

        @return The distance'''

    def distance_abs(self, ...):
        '''@brief Absolute distance between the edge and a point. @args p

        Returns the distance between the edge and the point.

        @param p The point to test.

        @return The distance'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def dx(self, ...):
        '''@brief The horizontal extend of the edge.'''

    def dx_abs(self, ...):
        '''@brief The absolute value of the horizontal extend of the edge.'''

    def dy(self, ...):
        '''@brief The vertical extend of the edge.'''

    def dy_abs(self, ...):
        '''@brief The absolute value of the vertical extend of the edge.'''

    def enlarge(self, ...):
        '''@brief Enlarges the edge. @args p

        Enlarges the edge by the given distance and returns the  enlarged edge. The edge is
        overwritten. Enlargement means that the first point is shifted by -p, the second by p.

        @param p The distance to move the edge points.

        @return The enlarged edge.'''

    def enlarged(self, ...):
        '''@brief Returns the enlarged edge (does not modify self) @args p

        Enlarges the edge by the given offset and returns the  enlarged edge. The edge is not
        modified. Enlargement means that the first point is shifted by -p, the second by p.

        @param p The distance to move the edge points.

        @return The enlarged edge.'''

    def extend(self, ...):
        '''@brief Extends the edge (modifies self) @args d

        Extends the edge by the given distance and returns the  extended edge. The edge is not
        modified. Extending means that the first point is shifted by -d along the edge, the second
        by d. The length of the edge will increase by 2*d.

        \\extended is a version that does not modify self but returns the extended edges.

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the end points.

        @return The extended edge (self).'''

    def extended(self, ...):
        '''@brief Returns the extended edge (does not modify self) @args d

        Extends the edge by the given distance and returns the  extended edge. The edge is not
        modified. Extending means that the first point is shifted by -d along the edge, the second
        by d. The length of the edge will increase by 2*d.

        \\extend is a version that modifies self (in-place).

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the end points.

        @return The extended edge.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given edge. This method enables
        edges as hash keys.

        This method has been introduced in version 0.25.'''

    def intersect(self, ...):
        '''@brief Intersection test.  @args e

        Returns true if the edges intersect. Two edges intersect if they share at least one point.
        If the edges coincide, they also intersect. For degenerated edges, the intersection is
        mapped to point containment tests.

        @param e The edge to test.'''

    def intersection_point(self, ...):
        '''@brief Returns the intersection point of two edges.  @args e

        This method delivers the intersection point. If the edges do not intersect, the result is
        undefined.

        @param e The edge to test. @return The point where the edges intersect.

        This method has been introduced in version 0.19.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_degenerate(self, ...):
        '''@brief Test for degenerated edge

        An edge is degenerate, if both end and start point are identical.'''

    def is_parallel(self, ...):
        '''@brief Test for being parallel @args e

        @param e The edge to test against

        @return True if both edges are parallel'''

    def length(self, ...):
        '''@brief The length of the edge'''

    def move(self, ...):
        '''@brief Moves the edge. @args dx, dy

        Moves the edge by the given offset and returns the  moved edge. The edge is overwritten.

        @param dx The x distance to move the edge. @param dy The y distance to move the edge.

        @return The moved edge.

        This version has been added in version 0.23.'''

    def moved(self, ...):
        '''@brief Returns the moved edge (does not modify self) @args dx, dy

        Moves the edge by the given offset and returns the  moved edge. The edge is not modified.

        @param dx The x distance to move the edge. @param dy The y distance to move the edge.

        @return The moved edge.

        This version has been added in version 0.23.'''

    def ortho_length(self, ...):
        '''@brief The orthogonal length of the edge ("manhattan-length")

        @return The orthogonal length (abs(dx)+abs(dy))'''

    def shift(self, ...):
        '''@brief Shifts the edge (modifies self) @args d

        Shifts the edge by the given distance and returns the  shifted edge. The edge is not
        modified. Shifting by a positive value will produce an edge which is shifted by d to the
        left. Shifting by a negative value will produce an edge which is shifted by d to the right.

        \\shifted is a version that does not modify self but returns the extended edges.

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the edge.

        @return The shifted edge (self).'''

    def shifted(self, ...):
        '''@brief Returns the shifted edge (does not modify self) @args d

        Shifts the edge by the given distance and returns the  shifted edge. The edge is not
        modified. Shifting by a positive value will produce an edge which is shifted by d to the
        left. Shifting by a negative value will produce an edge which is shifted by d to the right.

        \\shift is a version that modifies self (in-place).

        This method has been introduced in version 0.23.

        @param d The distance by which to shift the edge.

        @return The shifted edge.'''

    def side_of(self, ...):
        '''@brief Indicates at which side the point is located relative to the edge. @args p

        Returns 1 if the point is "left" of the edge, 0 if on and -1 if the point is "right" of the
        edge.

        @param p The point to test.

        @return The side value'''

    def sq_length(self, ...):
        '''@brief The square of the length of the edge'''

    def swap_points(self, ...):
        '''@brief Swap the points of the edge

        This version modifies self. A version that does not modify self is \\swapped_points.
        Swapping the points basically reverses the direction of the edge.

        This method has been introduced in version 0.23.'''

    def swapped_points(self, ...):
        '''@brief Returns an edge in which both points are swapped

        Swapping the points basically reverses the direction of the edge.

        This method has been introduced in version 0.23.'''

    def to_dtype(self, ...):
        '''@brief Converts the edge to a floating-point coordinate edge

        The database unit can be specified to translate the integer-coordinate edge into a floating-
        point coordinate edge in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Returns a string representing the edge'''

    def transformed(self, ...):
        '''@brief Transform the edge. @args t

        Transforms the edge with the given complex transformation. Does not modify the edge but
        returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge.'''

    def transformed_cplx(self, ...):
        '''@brief Transform the edge. @args t

        Transforms the edge with the given complex transformation. Does not modify the edge but
        returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_dedge(cls, ...):
        '''@brief Creates an integer coordinate edge from a floating-point coordinate edge

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dedge'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor with two points

        @args p1, p2

        Two points are given to create a new edge.'''

    @classmethod
    def new_pp(cls, ...):
        '''@brief Constructor with two points

        @args p1, p2

        Two points are given to create a new edge.'''

    @classmethod
    def new_xyxy(cls, ...):
        '''@brief Constructor with two coordinates given as single values

        @args x1, y1, x2, y2

        Two points are given to create a new edge.'''


class EdgePair:
    '''@brief An edge pair (a pair of two edges) Edge pairs are objects representing two edges or
    parts of edges. They play a role mainly in the context of DRC functions, where they specify a
    DRC violation by connecting two edges which violate the condition checked. Within the framework
    of polygon and edge collections which provide DRC functionality, edges pairs are used in the
    form of edge pair collections (\\EdgePairs).

    Edge pairs basically consist of two edges, called first and second. If created by a two-layer
    DRC function, the first edge will correspond to edges from the first layer and the second to
    edges from the second layer.

    This class has been introduced in version 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the first edge

     @brief Sets the first edge @args edge'''
    first = None

    '''@brief Gets the second edge

     @brief Sets the second edge @args edge'''
    second = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality @args box Returns true, if this edge pair and the given one are equal

        This method has been introduced in version 0.25.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given edge pair. This method
        enables edge pairs as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor from two edges

        This constructor creates an edge pair from the two edges given.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args box Returns true, if this edge pair is 'less' with respect to
        first and second edge

        This method has been introduced in version 0.25.'''

    def __ne__(self, ...):
        '''@brief Inequality @args box Returns true, if this edge pair and the given one are not
        equal

        This method has been introduced in version 0.25.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Returns a string representing the edge pair'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Returns a string representing the edge pair'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Gets the bounding box of the edge pair'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given edge pair. This method
        enables edge pairs as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def normalized(self, ...):
        '''@brief Normalizes the edge pair This method normalized the edge pair such that when
        connecting the edges at their  start and end points a closed loop is formed which is
        oriented clockwise. To achieve this, the points of the first and/or first and second edge
        are swapped. Normalization is a first step recommended before converting an edge pair to a
        polygon, because that way the polygons won't be self-overlapping and the enlargement
        parameter is applied properly.'''

    def polygon(self, ...):
        '''@brief Convert an edge pair to a polygon @args e The enlargement (set to zero for exact
        representation) The polygon is formed by connecting the end and start points of the edges.
        It is recommended to use \\normalized before converting the edge pair to a polygon.

        The enlargement parameter allows to apply the specified enlargement parallel and
        perpendicular to the edges. Basically this introduces a bias which blows up edge pairs by
        the specified amount. That parameter is useful to convert degenerated edge pairs to valid
        polygons, i.e. edge pairs with coincident edges and edge pairs consisting of two point-like
        edges.

        Another version for converting edge pairs to simple polygons is \\simple_polygon which
        renders a \\SimplePolygon object.'''

    def simple_polygon(self, ...):
        '''@brief Convert an edge pair to a simple polygon @args e The enlargement (set to zero for
        exact representation) The polygon is formed by connecting the end and start points of the
        edges. It is recommended to use \\normalized before converting the edge pair to a polygon.

        The enlargement parameter allows to apply the specified enlargement parallel and
        perpendicular to the edges. Basically this introduces a bias which blows up edge pairs by
        the specified amount. That parameter is useful to convert degenerated edge pairs to valid
        polygons, i.e. edge pairs with coincident edges and edge pairs consisting of two point-like
        edges.

        Another version for converting edge pairs to polygons is \\polygon which renders a \\Polygon
        object.'''

    def to_dtype(self, ...):
        '''@brief Converts the edge pair to a floating-point coordinate edge pair

        The database unit can be specified to translate the integer-coordinate edge pair into a
        floating-point coordinate edge pair in micron units. The database unit is basically a
        scaling factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Returns a string representing the edge pair'''

    def transformed(self, ...):
        '''@brief Returns the transformed edge pair @args t

        Transforms the edge pair with the given complex transformation. Does not modify the edge
        pair but returns the transformed edge.

        @param t The transformation to apply.

        @return The transformed edge pair'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor from two edges

        This constructor creates an edge pair from the two edges given.'''


class EdgePairs:
    '''@brief EdgePairs (a collection of edge pairs)

    Edge pairs are used mainly in the context of the DRC functions (width_check, space_check etc.)
    of \\Region and \\Edges. A single edge pair represents two edges participating in a DRC
    violation. In the two-layer checks (inside, overlap) The first edge represents an edge from the
    first layer and the second edge an edge from the second layer. For single-layer checks (width,
    space) the order of the edges is arbitrary.

    This class has been introduced in version 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __add__(self, ...):
        '''@brief Returns the combined edge pair collection of self and the other one

        @args other @return The resulting edge pair collection

        This operator adds the edge pairs of the other collection to self and returns a new combined
        set.

        This method has been introduced in version 0.24.'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __getitem__(self, ...):
        '''@brief Returns the nth edge pair @args n

        This method returns nil if the index is out of range.'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __iadd__(self, ...):
        '''@brief Adds the edge pairs of the other edge pair collection to self

        @args other @return The edge pair collection after modification (self)

        This operator adds the edge pairs of the other collection to self.

        This method has been introduced in version 0.24.'''

    def __init__(self, ...):
        '''@brief Default constructor

        This constructor creates an empty edge pair collection.'''

    def __iter__(self, ...):
        '''@brief Returns each edge pair of the edge pair collection'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __len__(self, ...):
        '''@brief Returns the number of edge pairs in this collection'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Converts the edge pair collection to a string @args max_count This version allows
        specification of the maximum number of edge pairs contained in the string.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Converts the edge pair collection to a string @args max_count This version allows
        specification of the maximum number of edge pairs contained in the string.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Return the bounding box of the edge pair collection The bounding box is the box
        enclosing all points of all edge pairs.'''

    def clear(self, ...):
        '''@brief Clears the edge pair collection'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def disable_progress(self, ...):
        '''@brief Disable progress reporting Calling this method will disable progress reporting.
        See \\enable_progress.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each(self, ...):
        '''@brief Returns each edge pair of the edge pair collection'''

    def edges(self, ...):
        '''@brief Decomposes the edge pairs into single edges @return An edge collection containing
        the individual edges'''

    def enable_progress(self, ...):
        '''@brief Enable progress reporting @args label After calling this method, the edge pair
        collection will report the progress through a progress bar while expensive operations are
        running. The label is a text which is put in front of the progress bar. Using a progress bar
        will imply a performance penalty of a few percent typically.'''

    def extents(self, ...):
        '''@brief Returns a region with the enlarged bounding boxes of the edge pairs @args dx, dy
        This method will return a region consisting of the bounding boxes of the edge pairs enlarged
        by the given distance dx in x direction and dy in y direction. The enlargement is specified
        per edge, i.e the width will be increased by 2*dx. The boxes will not be merged, so it is
        possible to determine overlaps of these boxes for example.'''

    def first_edges(self, ...):
        '''@brief Returns the first one of all edges @return An edge collection containing the first
        edges'''

    def insert(self, ...):
        '''@brief Inserts all edge pairs from the other edge pair collection into this edge pair
        collection @args edge_pairs This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_empty(self, ...):
        '''@brief Returns true if the collection is empty'''

    def move(self, ...):
        '''@brief Moves the edge pair collection @args x,y

        Moves the edge pairs by the given offset and returns the  moved edge pairs. The edge pair
        collection is overwritten.

        @param x The x distance to move the edge pairs. @param y The y distance to move the edge
        pairs.

        @return The moved edge pairs (self).'''

    def moved(self, ...):
        '''@brief Returns the moved edge pair collection (does not modify self) @args x,y

        Moves the edge pairs by the given offset and returns the  moved edge pairs. The edge pair
        collection is not modified.

        @param x The x distance to move the edge pairs. @param y The y distance to move the edge
        pairs.

        @return The moved edge pairs.'''

    def polygons(self, ...):
        '''@brief Converts the edge pairs to polygons @args e This method creates polygons from the
        edge pairs. Each polygon will be a triangle or quadrangle which connects the start and end
        points of the edges forming the edge pair. This version allows to specify an enlargement
        which is applied to the edges. The length of the edges is modified by applying the
        enlargement and the edges are shifted by the enlargement. By specifying an enlargement it is
        possible to give edge pairs an area which otherwise would not have one (coincident edges,
        two point-like edges).'''

    def second_edges(self, ...):
        '''@brief Returns the second one of all edges @return An edge collection containing the
        second edges'''

    def size(self, ...):
        '''@brief Returns the number of edge pairs in this collection'''

    def swap(self, ...):
        '''@brief Swap the contents of this collection with the contents of another collection @args
        other This method is useful to avoid excessive memory allocation in some cases. For managed
        memory languages such as Ruby, those cases will be rare. '''

    def to_s(self, ...):
        '''@brief Converts the edge pair collection to a string @args max_count This version allows
        specification of the maximum number of edge pairs contained in the string.'''

    def transform(self, ...):
        '''@brief Transform the edge pair collection with a complex transformation (modifies self)
        @args t

        Transforms the edge pair collection with the given transformation. This version modifies the
        edge pair collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge pair collection.'''

    def transform_icplx(self, ...):
        '''@brief Transform the edge pair collection with a complex transformation (modifies self)
        @args t

        Transforms the edge pair collection with the given transformation. This version modifies the
        edge pair collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge pair collection.'''

    def transformed(self, ...):
        '''@brief Transform the edge pair collection with a complex transformation @args t

        Transforms the edge pairs with the given complex transformation. Does not modify the edge
        pair collection but returns the transformed edge pairs.

        @param t The transformation to apply.

        @return The transformed edge pairs.'''

    def transformed_icplx(self, ...):
        '''@brief Transform the edge pair collection with a complex transformation @args t

        Transforms the edge pairs with the given complex transformation. Does not modify the edge
        pair collection but returns the transformed edge pairs.

        @param t The transformation to apply.

        @return The transformed edge pairs.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Default constructor

        This constructor creates an empty edge pair collection.'''


class EdgeProcessor:
    '''@brief The edge processor (boolean, sizing, merge)

    The edge processor implements the boolean and edge set operations (size, merge). Because the
    edge processor might allocate resources which can be reused in later operations, it is
    implemented as an object that can be used several times.

    Here is a simple example of how to use the edge processor:

    @code ep = RBA::EdgeProcessor::new # Prepare two boxes a = [ RBA::Polygon::new(RBA::Box::new(0,
    0, 300, 300)) ] b = [ RBA::Polygon::new(RBA::Box::new(100, 100, 200, 200)) ] # Run an XOR ->
    creates a polygon with a hole, since the 'resolve_holes' parameter # is false: out =
    ep.boolean_p2p(a, b, RBA::EdgeProcessor::ModeXor, false, false) out.to_s    # ->
    [(0,0;0,300;300,300;300,0/100,100;200,100;200,200;100,200)] @/code '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def boolean(self, ...):
        '''@brief Boolean operation for a set of given edges, creating edges @args a, b, mode

        This method computes the result for the given boolean operation on two sets of edges. The
        input edges must form closed contours where holes and hulls must be oriented differently.
        The input edges are processed with a simple non-zero wrap count rule as a whole.

        The result is presented as a set of edges forming closed contours. Hulls are oriented
        clockwise while holes are oriented counter-clockwise.

        Prior to version 0.21 this method was called 'boolean'. Is was renamed to avoid ambiguities
        for empty input arrays. The old version is still available but deprecated.

        @param a The input edges (first operand) @param b The input edges (second operand) @param
        mode The boolean mode (one of the Mode.. values) @return The output edges'''

    def boolean_e2e(self, ...):
        '''@brief Boolean operation for a set of given edges, creating edges @args a, b, mode

        This method computes the result for the given boolean operation on two sets of edges. The
        input edges must form closed contours where holes and hulls must be oriented differently.
        The input edges are processed with a simple non-zero wrap count rule as a whole.

        The result is presented as a set of edges forming closed contours. Hulls are oriented
        clockwise while holes are oriented counter-clockwise.

        Prior to version 0.21 this method was called 'boolean'. Is was renamed to avoid ambiguities
        for empty input arrays. The old version is still available but deprecated.

        @param a The input edges (first operand) @param b The input edges (second operand) @param
        mode The boolean mode (one of the Mode.. values) @return The output edges'''

    def boolean_e2p(self, ...):
        '''@brief Boolean operation for a set of given edges, creating polygons @args a, b, mode,
        resolve_holes, min_coherence

        This method computes the result for the given boolean operation on two sets of edges. The
        input edges must form closed contours where holes and hulls must be oriented differently.
        The input edges are processed with a simple non-zero wrap count rule as a whole.

        This method produces polygons on output and allows to fine-tune the parameters for that
        purpose.

        Prior to version 0.21 this method was called 'boolean_to_polygon'. Is was renamed to avoid
        ambiguities for empty input arrays. The old version is still available but deprecated.

        @param a The input polygons (first operand) @param b The input polygons (second operand)
        @param mode The boolean mode (one of the Mode.. values) @param resolve_holes true, if holes
        should be resolved into the hull @param min_coherence true, if touching corners should be
        resolved into less connected contours @return The output polygons'''

    def boolean_p2e(self, ...):
        '''@brief Boolean operation for a set of given polygons, creating edges @args a, b, mode

        This method computes the result for the given boolean operation on two sets of polygons. The
        result is presented as a set of edges forming closed contours. Hulls are oriented clockwise
        while holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with a Boolean
        operator and puts the result into an output vector.

        Prior to version 0.21 this method was called 'boolean'. Is was renamed to avoid ambiguities
        for empty input arrays. The old version is still available but deprecated.

        @param a The input polygons (first operand) @param b The input polygons (second operand)
        @param mode The boolean mode @return The output edges'''

    def boolean_p2p(self, ...):
        '''@brief Boolean operation for a set of given polygons, creating polygons @args a, b, mode,
        resolve_holes, min_coherence

        This method computes the result for the given boolean operation on two sets of polygons.
        This method produces polygons on output and allows to fine-tune the parameters for that
        purpose.

        This is a convenience method that bundles filling of the edges, processing with a Boolean
        operator and puts the result into an output vector.

        Prior to version 0.21 this method was called 'boolean_to_polygon'. Is was renamed to avoid
        ambiguities for empty input arrays. The old version is still available but deprecated.

        @param a The input polygons (first operand) @param b The input polygons (second operand)
        @param mode The boolean mode (one of the Mode.. values) @param resolve_holes true, if holes
        should be resolved into the hull @param min_coherence true, if touching corners should be
        resolved into less connected contours @return The output polygons'''

    def boolean_to_polygon(self, ...):
        '''@brief Boolean operation for a set of given edges, creating polygons @args a, b, mode,
        resolve_holes, min_coherence

        This method computes the result for the given boolean operation on two sets of edges. The
        input edges must form closed contours where holes and hulls must be oriented differently.
        The input edges are processed with a simple non-zero wrap count rule as a whole.

        This method produces polygons on output and allows to fine-tune the parameters for that
        purpose.

        Prior to version 0.21 this method was called 'boolean_to_polygon'. Is was renamed to avoid
        ambiguities for empty input arrays. The old version is still available but deprecated.

        @param a The input polygons (first operand) @param b The input polygons (second operand)
        @param mode The boolean mode (one of the Mode.. values) @param resolve_holes true, if holes
        should be resolved into the hull @param min_coherence true, if touching corners should be
        resolved into less connected contours @return The output polygons'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def disable_progress(self, ...):
        '''@brief Disable progress reporting Calling this method will stop the edge processor from
        showing a progress bar. See \\enable_progress.

        This method has been introduced in version 0.23.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def enable_progress(self, ...):
        '''@brief Enable progress reporting @args label After calling this method, the edge
        processor will report the progress through a progress bar. The label is a text which is put
        in front of the progress bar. Using a progress bar will imply a performance penalty of a few
        percent typically.

        This method has been introduced in version 0.23.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def merge(self, ...):
        '''@brief Merge the given polygons  @args in, min_wc

        In contrast to "simple_merge", this merge implementation considers each polygon individually
        before merging them. Thus self-overlaps are effectively removed before the output is
        computed and holes are correctly merged with the hull. In addition, this method allows to
        select areas with a higher wrap count which allows to compute overlaps of polygons on the
        same layer. Because this method merges the polygons before the overlap is computed, self-
        overlapping polygons do not contribute to higher wrap count areas.

        The result is presented as a set of edges forming closed contours. Hulls are oriented
        clockwise while holes are oriented counter-clockwise.

        Prior to version 0.21 this method was called 'merge'. Is was renamed to avoid ambiguities
        for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons @param min_wc The minimum wrap count for output (0: all
        polygons, 1: at least two overlapping) @return The output edges'''

    def merge_p2e(self, ...):
        '''@brief Merge the given polygons  @args in, min_wc

        In contrast to "simple_merge", this merge implementation considers each polygon individually
        before merging them. Thus self-overlaps are effectively removed before the output is
        computed and holes are correctly merged with the hull. In addition, this method allows to
        select areas with a higher wrap count which allows to compute overlaps of polygons on the
        same layer. Because this method merges the polygons before the overlap is computed, self-
        overlapping polygons do not contribute to higher wrap count areas.

        The result is presented as a set of edges forming closed contours. Hulls are oriented
        clockwise while holes are oriented counter-clockwise.

        Prior to version 0.21 this method was called 'merge'. Is was renamed to avoid ambiguities
        for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons @param min_wc The minimum wrap count for output (0: all
        polygons, 1: at least two overlapping) @return The output edges'''

    def merge_p2p(self, ...):
        '''@brief Merge the given polygons  @args in, min_wc, resolve_holes, min_coherence

        In contrast to "simple_merge", this merge implementation considers each polygon individually
        before merging them. Thus self-overlaps are effectively removed before the output is
        computed and holes are correctly merged with the hull. In addition, this method allows to
        select areas with a higher wrap count which allows to compute overlaps of polygons on the
        same layer. Because this method merges the polygons before the overlap is computed, self-
        overlapping polygons do not contribute to higher wrap count areas.

        This method produces polygons and allows to fine-tune the parameters for that purpose.

        Prior to version 0.21 this method was called 'merge_to_polygon'. Is was renamed to avoid
        ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons @param min_wc The minimum wrap count for output (0: all
        polygons, 1: at least two overlapping) @param resolve_holes true, if holes should be
        resolved into the hull @param min_coherence true, if touching corners should be resolved
        into less connected contours @return The output polygons'''

    def merge_to_polygon(self, ...):
        '''@brief Merge the given polygons  @args in, min_wc, resolve_holes, min_coherence

        In contrast to "simple_merge", this merge implementation considers each polygon individually
        before merging them. Thus self-overlaps are effectively removed before the output is
        computed and holes are correctly merged with the hull. In addition, this method allows to
        select areas with a higher wrap count which allows to compute overlaps of polygons on the
        same layer. Because this method merges the polygons before the overlap is computed, self-
        overlapping polygons do not contribute to higher wrap count areas.

        This method produces polygons and allows to fine-tune the parameters for that purpose.

        Prior to version 0.21 this method was called 'merge_to_polygon'. Is was renamed to avoid
        ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons @param min_wc The minimum wrap count for output (0: all
        polygons, 1: at least two overlapping) @param resolve_holes true, if holes should be
        resolved into the hull @param min_coherence true, if touching corners should be resolved
        into less connected contours @return The output polygons'''

    def simple_merge(self, ...):
        '''@brief Merge the given polygons and specify the merge mode @args in, mode

        The egdes provided must form valid closed contours. Contours oriented differently "cancel"
        each other.  Overlapping contours are merged when the orientation is the same.

        The result is presented as a set of edges forming closed contours. Hulls are oriented
        clockwise while holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with a
        SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-
        odd rule. A positive value specfies the wrap count threshold (postive only). A negative
        value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero
        rule).

        @param mode See description @param in The input edges @return The output edges'''

    def simple_merge_e2e(self, ...):
        '''@brief Merge the given polygons and specify the merge mode @args in, mode

        The egdes provided must form valid closed contours. Contours oriented differently "cancel"
        each other.  Overlapping contours are merged when the orientation is the same.

        The result is presented as a set of edges forming closed contours. Hulls are oriented
        clockwise while holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with a
        SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-
        odd rule. A positive value specfies the wrap count threshold (postive only). A negative
        value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero
        rule).

        @param mode See description @param in The input edges @return The output edges'''

    def simple_merge_e2p(self, ...):
        '''@brief Merge the given polygons and specify the merge mode @args in, resolve_holes,
        min_coherence, mode

        The egdes provided must form valid closed contours. Contours oriented differently "cancel"
        each other.  Overlapping contours are merged when the orientation is the same.

        This method produces polygons and allows to fine-tune the parameters for that purpose.

        This is a convenience method that bundles filling of the edges, processing with a
        SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-
        odd rule. A positive value specfies the wrap count threshold (postive only). A negative
        value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero
        rule).

        @param mode See description @param in The input edges @param resolve_holes true, if holes
        should be resolved into the hull @param min_coherence true, if touching corners should be
        resolved into less connected contours @return The output polygons'''

    def simple_merge_p2e(self, ...):
        '''@brief Merge the given polygons and specify the merge mode @args in, mode

        The wrapcount is computed over all polygons, i.e. overlapping polygons may "cancel" if they
        have different orientation (since a polygon is oriented by construction that is not easy to
        achieve). The other merge operation provided for this purpose is "merge" which normalizes
        each polygon individually before merging them. "simple_merge" is somewhat faster and
        consumes less memory.

        The result is presented as a set of edges forming closed contours. Hulls are oriented
        clockwise while holes are oriented counter-clockwise.

        This is a convenience method that bundles filling of the edges, processing with a
        SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-
        odd rule. A positive value specfies the wrap count threshold (postive only). A negative
        value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero
        rule).

        @param mode See description @param in The input polygons @return The output edges'''

    def simple_merge_p2p(self, ...):
        '''@brief Merge the given polygons and specify the merge mode @args in, resolve_holes,
        min_coherence, mode

        The wrapcount is computed over all polygons, i.e. overlapping polygons may "cancel" if they
        have different orientation (since a polygon is oriented by construction that is not easy to
        achieve). The other merge operation provided for this purpose is "merge" which normalizes
        each polygon individually before merging them. "simple_merge" is somewhat faster and
        consumes less memory.

        This method produces polygons and allows to fine-tune the parameters for that purpose.

        This is a convenience method that bundles filling of the edges, processing with a
        SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-
        odd rule. A positive value specfies the wrap count threshold (postive only). A negative
        value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero
        rule).

        @param mode See description @param in The input polygons @param resolve_holes true, if holes
        should be resolved into the hull @param min_coherence true, if touching corners should be
        resolved into less connected contours @return The output polygons'''

    def simple_merge_to_polygon(self, ...):
        '''@brief Merge the given polygons and specify the merge mode @args in, resolve_holes,
        min_coherence, mode

        The egdes provided must form valid closed contours. Contours oriented differently "cancel"
        each other.  Overlapping contours are merged when the orientation is the same.

        This method produces polygons and allows to fine-tune the parameters for that purpose.

        This is a convenience method that bundles filling of the edges, processing with a
        SimpleMerge operator and puts the result into an output vector.

        This method has been added in version 0.22.

        The mode specifies the rule to use when producing output. A value of 0 specifies the even-
        odd rule. A positive value specfies the wrap count threshold (postive only). A negative
        value specifies the threshold of the absolute value of the wrap count (i.e. -1 is non-zero
        rule).

        @param mode See description @param in The input edges @param resolve_holes true, if holes
        should be resolved into the hull @param min_coherence true, if touching corners should be
        resolved into less connected contours @return The output polygons'''

    def size(self, ...):
        '''@brief Size the given polygons (isotropic) @args in, d, mode

        This method is equivalent to calling the anisotropic version with identical dx and dy.

        Prior to version 0.21 this method was called 'size'. Is was renamed to avoid ambiguities for
        empty input arrays. The old version is still available but deprecated.

        @param in The input polygons @param d The sizing value in x direction @param mode The sizing
        mode @return The output edges'''

    def size_p2e(self, ...):
        '''@brief Size the given polygons (isotropic) @args in, d, mode

        This method is equivalent to calling the anisotropic version with identical dx and dy.

        Prior to version 0.21 this method was called 'size'. Is was renamed to avoid ambiguities for
        empty input arrays. The old version is still available but deprecated.

        @param in The input polygons @param d The sizing value in x direction @param mode The sizing
        mode @return The output edges'''

    def size_p2p(self, ...):
        '''@brief Size the given polygons into polygons (isotropic) @args in, d, mode,
        resolve_holes, min_coherence

        This method is equivalent to calling the anisotropic version with identical dx and dy.

        Prior to version 0.21 this method was called 'size_to_polygon'. Is was renamed to avoid
        ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons @param d The sizing value in x direction @param mode The sizing
        mode @param resolve_holes true, if holes should be resolved into the hull @param
        min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons'''

    def size_to_polygon(self, ...):
        '''@brief Size the given polygons into polygons (isotropic) @args in, d, mode,
        resolve_holes, min_coherence

        This method is equivalent to calling the anisotropic version with identical dx and dy.

        Prior to version 0.21 this method was called 'size_to_polygon'. Is was renamed to avoid
        ambiguities for empty input arrays. The old version is still available but deprecated.

        @param in The input polygons @param d The sizing value in x direction @param mode The sizing
        mode @param resolve_holes true, if holes should be resolved into the hull @param
        min_coherence true, if touching corners should be resolved into less connected contours
        @return The output polygons'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def mode_and(cls, ...):
        '''@brief boolean method's mode value for AND operation'''

    @classmethod
    def mode_anotb(cls, ...):
        '''@brief boolean method's mode value for A NOT B operation'''

    @classmethod
    def mode_bnota(cls, ...):
        '''@brief boolean method's mode value for B NOT A operation'''

    @classmethod
    def mode_or(cls, ...):
        '''@brief boolean method's mode value for OR operation'''

    @classmethod
    def mode_xor(cls, ...):
        '''@brief boolean method's mode value for XOR operation'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Edges:
    '''@brief A collection of edges (Not necessarily describing closed contours)

     This class was introduced to simplify operations on edges sets. See \\Edge for a description of
    the individual edge object. The edge collection contains an arbitrary number of edges and
    supports operations to select edges by various criteria, produce polygons from the edges by
    applying an extension, filtering edges against other edges collections and checking geometrical
    relations to other edges (DRC functionality).

    The edge collection is supposed to work closely with the \\Region polygon set. Both are related,
    although the edge collection has a lower rank since it potentially represents a disconnected
    collection of edges. Edge collections may form closed contours, for example immediately after
    they have been derived from a polygon set using \\Region#edges. But this state is volatile and
    can easily be destroyed by filtering edges. Hence the connected state does not play an important
    role in the edge collection's API.

    Edge collections may also contain points (degenerated edges with identical start and end
    points). Such point-like objects participate in some although not all methods of the edge
    collection class.  Edge collections can be used in two different flavors: in raw mode or merged
    semantics. With merged semantics (the default), connected edges are considered to belong
    together and are effectively merged. Overlapping parts are counted once in that mode. Dot-like
    edges are not considered in merged semantics. In raw mode (without merged semantics), each edge
    is considered as it is. Overlaps between edges may exists and merging has to be done explicitly
    using the \\merge method. The semantics can be selected using \\merged_semantics=.

     This class has been introduced in version 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets a flag indicating whether merged semantics is enabled See \\merged_semantics= for
    a description of this attribute.

     @brief Enable or disable merged semantics @args f If merged semantics is enabled (the default),
    colinear, connected or overlapping edges will be considered as single edges.'''
    merged_semantics = None

    # Methods
    def __add__(self, ...):
        '''@brief Returns the combined edge set of self and the other one

        @args other @return The resulting edge set

        This operator adds the edges of the other edge set to self and returns a new combined edge
        set. This usually creates unmerged edge sets and edges may overlap. Use \\merge if you want
        to ensure the result edge set is merged.'''

    def __and__(self, ...):
        '''@brief Returns the parts of the edges inside the given region

        @args other @return The edges inside the given region

        This operation returns the parts of the edges which are inside the given region. Edges on
        the borders of the polygons are included in the edge set. As a side effect, the edges are
        made non-intersecting by introducing cut points where edges intersect.

        This method has been introduced in version 0.24.'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __getitem__(self, ...):
        '''@brief Returns the nth edge of the edge collection @args n

        This method returns nil if the index is out of range.'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __iadd__(self, ...):
        '''@brief Adds the edges of the other edge collection to self

        @args other @return The edge set after modification (self)

        This operator adds the edges of the other edge set to self. This usually creates unmerged
        edge sets and edges may overlap. Use \\merge if you want to ensure the result edge set is
        merged.'''

    def __iand__(self, ...):
        '''@brief Selects the parts of the edges inside the given region

        @args other @return The edge collection after modification (self)

        This operation selects the parts of the edges which are inside the given region. Edges on
        the borders of the polygons are included in the edge set. As a side effect, the edges are
        made non-intersecting by introducing cut points where edges intersect.

        This method has been introduced in version 0.24.'''

    def __init__(self, ...):
        '''@brief Constructor from a hierarchical shape set with a transformation @args
        shape_iterator, trans, as_edges

        This constructor creates an edge collection from the shapes delivered by the given recursive
        shape iterator. It feeds the shapes from a hierarchy of cells into the edge set. The
        transformation is useful to scale to a specific database unit for example.

        Text objects are not inserted, because they cannot be converted to edges. Edge objects are
        inserted as such. If "as_edges" is true, "solid" objects (boxes, polygons, paths) are
        converted to edges which form the hull of these objects. If "as_edges" is false, solid
        objects are ignored.

        @code layout = ... # a layout cell   = ... # the index of the initial cell layer  = ... #
        the index of the layer from where to take the shapes from dbu    = 0.1 # the target database
        unit r = RBA::Edges::new(layout.begin_shapes(cell, layer), RBA::ICplxTrans::new(layout.dbu /
        dbu)) @/code'''

    def __ior__(self, ...):
        '''@brief Performs the boolean OR between self and the other redge set

        @args other @return The edge collection after modification (self)

        The boolean OR is implemented by merging the edges of both edge sets. To simply join the
        edge collections without merging, the + operator is more efficient.'''

    def __isub__(self, ...):
        '''@brief Selects the parts of the edges outside the given region

        @args other @return The edge collection after modification (self)

        This operation selects the parts of the edges which are outside the given region. Edges on
        the borders of the polygons are not included in the edge set. As a side effect, the edges
        are made non-intersecting by introducing cut points where edges intersect.

        This method has been introduced in version 0.24.'''

    def __iter__(self, ...):
        '''@brief Returns each edge of the region'''

    def __ixor__(self, ...):
        '''@brief Performs the boolean XOR between self and the other edge collection

        @args other @return The edge collection after modification (self)

        The boolean XOR operation will return all parts of the edges in this and the other
        collection except the parts where both are coincident. The result will be a merged edge
        collection.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __len__(self, ...):
        '''@brief Returns the number of edges in the edge collection'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __or__(self, ...):
        '''@brief Returns the boolean OR between self and the other edge set

        @args other @return The resulting edge collection

        The boolean OR is implemented by merging the edges of both edge sets. To simply join the
        edge collections without merging, the + operator is more efficient.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Converts the edge collection to a string @args max_count This version allows
        specification of the maximum number of edges contained in the string.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Converts the edge collection to a string @args max_count This version allows
        specification of the maximum number of edges contained in the string.'''

    def __sub__(self, ...):
        '''@brief Returns the parts of the edges outside the given region

        @args other @return The edges outside the given region

        This operation returns the parts of the edges which are outside the given region. Edges on
        the borders of the polygons are not included in the edge set. As a side effect, the edges
        are made non-intersecting by introducing cut points where edges intersect.

        This method has been introduced in version 0.24.'''

    def __xor__(self, ...):
        '''@brief Returns the boolean XOR between self and the other edge collection

        @args other @return The result of the boolean XOR operation

        The boolean XOR operation will return all parts of the edges in this and the other
        collection except the parts where both are coincident. The result will be a merged edge
        collection.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Returns the bounding box of the edge collection The bounding box is the box
        enclosing all points of all edges.'''

    def centers(self, ...):
        '''@brief Returns edges representing the center part of the edges @args length, fraction
        @return A new collection of edges representing the part around the center This method allows
        to specify the length of these segments in a twofold way: either as a fixed length or by
        specifying a fraction of the original length:

        @code edges = ...  # An edge collection edges.centers(100, 0.0)     # All segments have a
        length of 100 DBU edges.centers(0, 50.0)      # All segments have a length of half the
        original length edges.centers(100, 50.0)    # All segments have a length of half the
        original length                             # or 100 DBU, whichever is larger @/code

        It is possible to specify 0 for both values. In this case, degenerated edges (points) are
        delivered which specify the centers of the edges but can't participate in some functions.'''

    def clear(self, ...):
        '''@brief Clears the edge collection'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def disable_progress(self, ...):
        '''@brief Disable progress reporting Calling this method will disable progress reporting.
        See \\enable_progress.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each(self, ...):
        '''@brief Returns each edge of the region'''

    def each_merged(self, ...):
        '''@brief Returns each edge of the region

        In contrast to \\each, this method delivers merged edges if merge semantics applies while
        \\each delivers the original edges only.

        This method has been introduced in version 0.25.'''

    def enable_progress(self, ...):
        '''@brief Enable progress reporting @args label After calling this method, the edge
        collection will report the progress through a progress bar while expensive operations are
        running. The label is a text which is put in front of the progress bar. Using a progress bar
        will imply a performance penalty of a few percent typically.'''

    def enclosing_check(self, ...):
        '''@brief Performs an enclosing check with options @args other, d, whole_edges, metrics,
        ignore_angle, min_projection, max_projection @param d The minimum distance for which the
        edges are checked @param other The other edge collection against which to check @param
        whole_edges If true, deliver the whole edges @param metrics Specify the metrics type @param
        ignore_angle The threshold angle above which no check is performed @param min_projection The
        lower threshold of the projected length of one edge onto another @param max_projection The
        upper threshold of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal
        or above the given value, they will not contribute in the check. Setting this value to 90
        (the default) will exclude edges with an angle of 90 degree or more from the check. Use nil
        for this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one threshold, pass nil to the
        respective value.'''

    def end_segments(self, ...):
        '''@brief Returns edges representing a part of the edge before the end point @args length,
        fraction @return A new collection of edges representing the end part This method allows to
        specify the length of these segments in a twofold way: either as a fixed length or by
        specifying a fraction of the original length:

        @code edges = ...  # An edge collection edges.end_segments(100, 0.0)     # All segments have
        a length of 100 DBU edges.end_segments(0, 50.0)      # All segments have a length of half
        the original length edges.end_segments(100, 50.0)    # All segments have a length of half
        the original length                                   # or 100 DBU, whichever is larger
        @/code

        It is possible to specify 0 for both values. In this case, degenerated edges (points) are
        delivered which specify the end positions of the edges but can't participate in some
        functions.'''

    def extended(self, ...):
        '''@brief Returns a region with shapes representing the edges with the specified extensions
        @args b, e, o, i, join @param b the parallel extension at the start point of the edge @param
        e the parallel extension at the end point of the edge @param o the perpendicular extension
        to the "outside" (left side as seen in the direction of the edge) @param i the perpendicular
        extension to the "inside" (right side as seen in the dleftirection of the edge) @param join
        If true, connected edges are joined before the extension is applied @return A region
        containing the polygons representing these extended edges This is a generic version of
        \\extended_in and \\extended_out. It allows to specify extensions for all four directions of
        an edge and to join the edges before the extension is applied.

        For degenerated edges forming a point, a rectangle with the b, e, o and i used as left,
        right, top and bottom distance to the center point of this edge is created.

        If join is true and edges form a closed loop, the b and e parameters are ignored and a rim
        polygon is created that forms the loop with the outside and inside extension given by o and
        i.'''

    def extended_in(self, ...):
        '''@brief Returns a region with shapes representing the edges with the given width @args e
        @param e The extension width @return A region containing the polygons representing these
        extended edges The edges are extended to the "inside" by the given distance "e". The
        distance will be applied to the right side as seen in the direction of the edge. By
        definition, this is the side pointing to the inside of the polygon if the edge was derived
        from a polygon.

        Other versions of this feature are \\extended_out and \\extended.'''

    def extended_out(self, ...):
        '''@brief Returns a region with shapes representing the edges with the given width @args e
        @param e The extension width @return A region containing the polygons representing these
        extended edges The edges are extended to the "outside" by the given distance "e". The
        distance will be applied to the left side as seen in the direction of the edge. By
        definition, this is the side pointing to the outside of the polygon if the edge was derived
        from a polygon.

        Other versions of this feature are \\extended_in and \\extended.'''

    def extents(self, ...):
        '''@brief Returns a region with the enlarged bounding boxes of the edges @args dx, dy This
        method will return a region consisting of the bounding boxes of the edges enlarged by the
        given distance dx in x direction and dy in y direction. The enlargement is specified per
        edge, i.e the width will be increased by 2*dx. The boxes will not be merged, so it is
        possible to determine overlaps of these boxes for example.'''

    def in_(self, ...):
        '''@brief Returns all edges which are members of the other edge collection @args other This
        method returns all edges in self which can be found in the other edge collection as well
        with exactly the same geometry.'''

    def insert(self, ...):
        '''@brief Inserts all edges from the array into this edge collection @args array'''

    def inside_check(self, ...):
        '''@brief Performs an inside check with options @args other, d, whole_edges, metrics,
        ignore_angle, min_projection, max_projection @param d The minimum distance for which the
        edges are checked @param other The other edge collection against which to check @param
        whole_edges If true, deliver the whole edges @param metrics Specify the metrics type @param
        ignore_angle The threshold angle above which no check is performed @param min_projection The
        lower threshold of the projected length of one edge onto another @param max_projection The
        upper threshold of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal
        or above the given value, they will not contribute in the check. Setting this value to 90
        (the default) will exclude edges with an angle of 90 degree or more from the check. Use nil
        for this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one threshold, pass nil to the
        respective value.'''

    def inside_part(self, ...):
        '''@brief Returns the parts of the edges of this edge collection which are inside the
        polygons of the region

        @args other @return A new edge collection containing the edge parts inside the region

        This operation returns the parts of the edges which are inside the given region. This
        functionality is similar to the '&' operator, but edges on the borders of the polygons are
        not included in the edge set. As a side effect, the edges are made non-intersecting by
        introducing cut points where edges intersect.

        This method has been introduced in version 0.24.'''

    def interacting(self, ...):
        '''@brief Returns the edges from this region which overlap or touch polygons from the region

        @args other @return A new edge collection containing the edges overlapping or touching
        polygons from the region

        This method does not merge the edges before they are selected. If you want to select
        coherent edges, make sure the edge collection is merged before this method is used.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_empty(self, ...):
        '''@brief Returns true if the edge collection is empty'''

    def is_merged(self, ...):
        '''@brief Returns true if the edge collection is merged If the region is merged, coincident
        edges have been merged into single edges. You can ensure merged state by calling \\merge.'''

    def length(self, ...):
        '''@brief Returns the total length of all edges in the edge collection (restricted to a
        rectangle) @args rect This version will compute the total length of all edges in the
        collection, restricting the computation to the given rectangle. Edges along the border are
        handled in a special way: they are counted when they are oriented with their inside side
        toward the rectangle (in other words: outside edges must coincide with the rectangle's
        border in order to be counted).

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def members_of(self, ...):
        '''@brief Returns all edges which are members of the other edge collection @args other This
        method returns all edges in self which can be found in the other edge collection as well
        with exactly the same geometry.'''

    def merge(self, ...):
        '''@brief Merge the edges

        @return The edge collection after the edges have been merged (self).

        Merging joins parallel edges which overlap or touch. Crossing edges are not merged. If the
        edge collection is already merged, this method does nothing'''

    def merged(self, ...):
        '''@brief Returns the merged edge collection

        @return The edge collection after the edges have been merged.

        Merging joins parallel edges which overlap or touch. Crossing edges are not merged. In
        contrast to \\merge, this method does not modify the edge collection but returns a merged
        copy.'''

    def move(self, ...):
        '''@brief Moves the edge collection @args x,y

        Moves the edge collection by the given offset and returns the  moved edge collection. The
        edge collection is overwritten.

        @param x The x distance to move the edge collection. @param y The y distance to move the
        edge collection.

        @return The moved edge collection (self).'''

    def moved(self, ...):
        '''@brief Returns the moved edge collection (does not modify self) @args x,y

        Moves the edge collection by the given offset and returns the  moved edge collection. The
        edge collection is not modified.

        @param x The x distance to move the edge collection. @param y The y distance to move the
        edge collection.

        @return The moved edge collection.'''

    def not_in(self, ...):
        '''@brief Returns all edges which are not members of the other edge collection @args other
        This method returns all edges in self which can not be found in the other edge collection
        with exactly the same geometry.'''

    def not_interacting(self, ...):
        '''@brief Returns the edges from this region which do not overlap or touch polygons from the
        region

        @args other @return A new edge collection containing the edges not overlapping or touching
        polygons from the region

        This method does not merge the edges before they are selected. If you want to select
        coherent edges, make sure the edge collection is merged before this method is used.'''

    def not_members_of(self, ...):
        '''@brief Returns all edges which are not members of the other edge collection @args other
        This method returns all edges in self which can not be found in the other edge collection
        with exactly the same geometry.'''

    def outside_part(self, ...):
        '''@brief Returns the parts of the edges of this edge collection which are outside the
        polygons of the region

        @args other @return A new edge collection containing the edge parts outside the region

        This operation returns the parts of the edges which are not inside the given region. This
        functionality is similar to the '-' operator, but edges on the borders of the polygons are
        included in the edge set. As a side effect, the edges are made non-intersecting by
        introducing cut points where edges intersect.

        This method has been introduced in version 0.24.'''

    def overlap_check(self, ...):
        '''@brief Performs an overlap check with options @args other, d, whole_edges, metrics,
        ignore_angle, min_projection, max_projection @param d The minimum distance for which the
        edges are checked @param other The other edge collection against which to check @param
        whole_edges If true, deliver the whole edges @param metrics Specify the metrics type @param
        ignore_angle The threshold angle above which no check is performed @param min_projection The
        lower threshold of the projected length of one edge onto another @param max_projection The
        upper threshold of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal
        or above the given value, they will not contribute in the check. Setting this value to 90
        (the default) will exclude edges with an angle of 90 degree or more from the check. Use nil
        for this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one threshold, pass nil to the
        respective value.'''

    def select_inside_part(self, ...):
        '''@brief Selects the parts of the edges from this edge collection which are inside the
        polygons of the given region

        @args other @return The edge collection after the edges have been selected (self)

        This operation selects the parts of the edges which are inside the given region. This
        functionality is similar to the '&=' operator, but edges on the borders of the polygons are
        not included in the edge set. As a side effect, the edges are made non-intersecting by
        introducing cut points where edges intersect.

        This method has been introduced in version 0.24.'''

    def select_interacting(self, ...):
        '''@brief Selects the edges from this region which overlap or touch polygons from the region

        @args other @return The edge collection after the edges have been selected (self)

        This method does not merge the edges before they are selected. If you want to select
        coherent edges, make sure the edge collection is merged before this method is used.'''

    def select_not_interacting(self, ...):
        '''@brief Selects the edges from this region which do not overlap or touch polygons from the
        region

        @args other @return The edge collection after the edges have been selected (self)

        This method does not merge the edges before they are selected. If you want to select
        coherent edges, make sure the edge collection is merged before this method is used.'''

    def select_outside_part(self, ...):
        '''@brief Selects the parts of the edges from this edge collection which are outside the
        polygons of the given region

        @args other @return The edge collection after the edges have been selected (self)

        This operation selects the parts of the edges which are not inside the given region. This
        functionality is similar to the '-=' operator, but edges on the borders of the polygons are
        included in the edge set. As a side effect, the edges are made non-intersecting by
        introducing cut points where edges intersect.

        This method has been introduced in version 0.24.'''

    def separation_check(self, ...):
        '''@brief Performs an overlap check with options @args other, d, whole_edges, metrics,
        ignore_angle, min_projection, max_projection @param d The minimum distance for which the
        edges are checked @param other The other edge collection against which to check @param
        whole_edges If true, deliver the whole edges @param metrics Specify the metrics type @param
        ignore_angle The threshold angle above which no check is performed @param min_projection The
        lower threshold of the projected length of one edge onto another @param max_projection The
        upper threshold of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal
        or above the given value, they will not contribute in the check. Setting this value to 90
        (the default) will exclude edges with an angle of 90 degree or more from the check. Use nil
        for this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one threshold, pass nil to the
        respective value.'''

    def size(self, ...):
        '''@brief Returns the number of edges in the edge collection'''

    def space_check(self, ...):
        '''@brief Performs a space check with options @args d, whole_edges, metrics, ignore_angle,
        min_projection, max_projection @param d The minimum distance for which the edges are checked
        @param whole_edges If true, deliver the whole edges @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed @param
        min_projection The lower threshold of the projected length of one edge onto another @param
        max_projection The upper threshold of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the space check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal
        or above the given value, they will not contribute in the check. Setting this value to 90
        (the default) will exclude edges with an angle of 90 degree or more from the check. Use nil
        for this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one threshold, pass nil to the
        respective value.'''

    def start_segments(self, ...):
        '''@brief Returns edges representing a part of the edge after the start point @args length,
        fraction @return A new collection of edges representing the start part This method allows to
        specify the length of these segments in a twofold way: either as a fixed length or by
        specifying a fraction of the original length:

        @code edges = ...  # An edge collection edges.start_segments(100, 0.0)    # All segments
        have a length of 100 DBU edges.start_segments(0, 50.0)     # All segments have a length of
        half the original length edges.start_segments(100, 50.0)   # All segments have a length of
        half the original length                                   # or 100 DBU, whichever is larger
        @/code

        It is possible to specify 0 for both values. In this case, degenerated edges (points) are
        delivered which specify the start positions of the edges but can't participate in some
        functions.'''

    def swap(self, ...):
        '''@brief Swap the contents of this edge collection with the contents of another one @args
        other This method is useful to avoid excessive memory allocation in some cases. For managed
        memory languages such as Ruby, those cases will be rare. '''

    def to_s(self, ...):
        '''@brief Converts the edge collection to a string @args max_count This version allows
        specification of the maximum number of edges contained in the string.'''

    def transform(self, ...):
        '''@brief Transform the edge collection with a complex transformation (modifies self) @args
        t

        Transforms the edge collection with the given transformation. This version modifies the edge
        collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge collection.'''

    def transform_icplx(self, ...):
        '''@brief Transform the edge collection with a complex transformation (modifies self) @args
        t

        Transforms the edge collection with the given transformation. This version modifies the edge
        collection and returns a reference to self.

        @param t The transformation to apply.

        @return The transformed edge collection.'''

    def transformed(self, ...):
        '''@brief Transform the edge collection with a complex transformation @args t

        Transforms the edge collection with the given complex transformation. Does not modify the
        edge collection but returns the transformed edge collection.

        @param t The transformation to apply.

        @return The transformed edge collection.'''

    def transformed_icplx(self, ...):
        '''@brief Transform the edge collection with a complex transformation @args t

        Transforms the edge collection with the given complex transformation. Does not modify the
        edge collection but returns the transformed edge collection.

        @param t The transformation to apply.

        @return The transformed edge collection.'''

    def width_check(self, ...):
        '''@brief Performs a width check with options @args d, whole_edges, metrics, ignore_angle,
        min_projection, max_projection @param d The minimum width for which the edges are checked
        @param whole_edges If true, deliver the whole edges @param metrics Specify the metrics type
        @param ignore_angle The threshold angle above which no check is performed @param
        min_projection The lower threshold of the projected length of one edge onto another @param
        max_projection The upper threshold of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle threshold of two edges. If two edges form an angle equal
        or above the given value, they will not contribute in the check. Setting this value to 90
        (the default) will exclude edges with an angle of 90 degree or more from the check. Use nil
        for this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one threshold, pass nil to the
        respective value.'''

    def with_angle(self, ...):
        '''@brief Filter the edges by orientation @args min_angle, max_angle, inverse Filters the
        edges in the edge collection by orientation. If "inverse" is false, only edges which have an
        angle to the x-axis larger or equal to "min_angle" and less than "max_angle" are returned.
        If "inverse" is true, edges which do not conform to this criterion are returned.'''

    def with_length(self, ...):
        '''@brief Filter the edges by length @args min_length, max_length, inverse Filters the edges
        in the edge collection by length. If "inverse" is false, only edges which have a length
        larger or equal to "min_length" and less than "max_length" are returned. If "inverse" is
        true, edges not having a length less than "min_length" or larger or equal than "max_length"
        are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor from a hierarchical shape set with a transformation @args
        shape_iterator, trans, as_edges

        This constructor creates an edge collection from the shapes delivered by the given recursive
        shape iterator. It feeds the shapes from a hierarchy of cells into the edge set. The
        transformation is useful to scale to a specific database unit for example.

        Text objects are not inserted, because they cannot be converted to edges. Edge objects are
        inserted as such. If "as_edges" is true, "solid" objects (boxes, polygons, paths) are
        converted to edges which form the hull of these objects. If "as_edges" is false, solid
        objects are ignored.

        @code layout = ... # a layout cell   = ... # the index of the initial cell layer  = ... #
        the index of the layer from where to take the shapes from dbu    = 0.1 # the target database
        unit r = RBA::Edges::new(layout.begin_shapes(cell, layer), RBA::ICplxTrans::new(layout.dbu /
        dbu)) @/code'''


class ICplxTrans:
    '''@brief A complex transformation

    A complex transformation provides magnification, mirroring at the x-axis, rotation by an
    arbitary angle and a displacement. This is also the order, the operations are applied. This
    version can transform integer-coordinate objects into the same, which may involve rounding and
    can be inexact.

    Complex transformations are extensions of the simple transformation classes (\\Trans in that
    case) and behave similar.

    Transformations can be used to transform points or other objects. Transformations can be
    combined with the '*' operator to form the transformation which is equivalent to applying the
    second and then the first. Here is some code:

    @code # Create a transformation that applies a magnication of 1.5, a rotation by 90 degree # and
    displacement of 10 in x and 20 units in y direction: t = RBA::ICplxTrans::new(1.5, 90, false,
    10.0, 20.0) t.to_s            # r90 *1.5 10,20 # compute the inverse: t.inverted.to_s   # r270
    *0.666666667 -13,7 # Combine with another displacement (applied after that):
    (RBA::ICplxTrans::new(5, 5) * t).to_s    # r90 *1.5 15,25 # Transform a point:
    t.trans(RBA::Point::new(100, 200)).to_s  # -290,170 @/code

    This class has been introduced in version 0.18.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the angle

    Note that the simple transformation returns the angle in units of 90 degree. Hence for a simple
    trans (i.e. \\Trans), a rotation angle of 180 degree delivers a value of 2 for the angle
    attribute. The complex transformation, supporting any rotation angle returns the angle in
    degree.

    @return The rotation angle this transformation provides in degree units (0..360 deg).

     @brief Sets the angle @param a The new angle See \\angle for a description of that
    attribute.'''
    angle = None

    '''@brief Gets the displacement

     @brief Sets the displacement @param u The new displacement'''
    disp = None

    '''@brief Gets the magnification

     @brief Sets the magnification @args m @param m The new magnification'''
    mag = None

    '''@brief Sets the mirror flag "mirroring" describes a reflection at the x-axis which is
    included in the transformation prior to rotation.@param m The new mirror flag'''
    mirror = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Tests for equality'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis, rotation, application of
        displacement.

        @param mag The magnification @param rot The rotation angle in units of degree @param mirrx
        True, if mirrored at x axis @param x The x displacement @param y The y displacement'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Provides a 'less' criterion for sorting This method is provided to implement a
        sorting order. The definition of 'less' is opaque and might change in future versions.'''

    def __mul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __ne__(self, ...):
        '''@brief Tests for inequality'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def ctrans(self, ...):
        '''@brief Transforms a distance

        The "ctrans" method transforms the given distance. e = t(d). For the simple transformations,
        there is no magnification and no modification of the distance therefore.

        @param d The distance to transform @return The transformed distance'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def invert(self, ...):
        '''@brief Inverts the transformation (in place)

        Inverts the transformation and replaces this transformation by it's inverted one.

        @return The inverted transformation'''

    def inverted(self, ...):
        '''@brief Returns the inverted transformation

        Returns the inverted transformation. This method does not modify the transformation.

        @return The inverted transformation'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mag(self, ...):
        '''@brief Test, if the transformation is a magnifying one

        This is the recommended test for checking if the transformation represents a
        magnification.'''

    def is_mirror(self, ...):
        '''@brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis
        followed by a rotation by the angle given by the \\angle property. '''

    def is_ortho(self, ...):
        '''@brief Tests, if the transformation is an orthogonal transformation

        If the rotation is by a multiple of 90 degree, this method will return true.'''

    def is_unity(self, ...):
        '''@brief Tests, whether this is a unit transformation'''

    def rot(self, ...):
        '''@brief Returns the respective simple transformation equivalent rotation code if possible

        If this transformation is orthogonal (is_ortho () == true), then this method will return the
        corresponding fixpoint transformation, not taking into account magnification and
        displacement. If the transformation is not orthogonal, the result reflects the quadrant the
        rotation goes into.'''

    def s_trans(self, ...):
        '''@brief Extracts the simple transformation part

        The simple transformation part does not reflect magnification or arbitrary angles. Rotation
        angles are rounded down to multiples of 90 degree. Magnification is fixed to 1.0.'''

    def to_itrans(self, ...):
        '''@brief Converts the transformation to another transformation with floating-point input
        and output coordinates

        The database unit can be specified to translate the integer coordinate displacement in
        database units to a floating-point displacement in micron units. The displacement's'
        coordinates will be multiplied with the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def to_trans(self, ...):
        '''@brief Converts the transformation to another transformation with floating-point input
        coordinates

        This method has been introduced in version 0.25.'''

    def to_vtrans(self, ...):
        '''@brief Converts the transformation to another transformation with floating-point output
        coordinates

        The database unit can be specified to translate the integer coordinate displacement in
        database units to a floating-point displacement in micron units. The displacement's'
        coordinates will be multiplied with the database unit.

        This method has been introduced in version 0.25.'''

    def trans(self, ...):
        '''@brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform @return The transformed text

        This convenience method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_dtrans(cls, ...):
        '''@brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dtrans'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string Creates the object from a string representation
        (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def from_trans(cls, ...):
        '''@brief Creates a floating-point coordinate transformation from another coordinate flavour

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_trans'.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis, rotation, application of
        displacement.

        @param mag The magnification @param rot The rotation angle in units of degree @param mirrx
        True, if mirrored at x axis @param x The x displacement @param y The y displacement'''


class InstElement:
    '''@brief An element in an instantiation path

    This objects are used to reference a single instance in a instantiation path. The object is
    composed of a \\CellInstArray object (accessible through the \\cell_inst accessor) that
    describes the basic instance, which may be an array. The particular instance within the array
    can be further retrieved using the \\array_member_trans, \\specific_trans or
    \\specific_cplx_trans methods. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality of two InstElement objects @args b Note: this operator returns true if
        both instance elements refer to the same instance, not just identical ones.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Create an instance element from an array instance pointing into a certain array
        member @args inst, a_index, b_index Starting with version 0.15, this method takes an
        \\Instance object (an instance reference) as the first argument.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Provides an order criterion for two InstElement objects @args b Note: this
        operator is just provided to establish any order, not a particular one.'''

    def __ne__(self, ...):
        '''@brief Inequality of two InstElement objects @args b See the comments on the ==
        operator.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def array_member_trans(self, ...):
        '''@brief Returns the transformation for this array member

        The array member transformation is the one applicable in addition to the global
        transformation for the member selected from an array. If this instance is not an array
        instance, the specific transformation is a unit transformation without displacement.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def cell_inst(self, ...):
        '''@brief Accessor to the cell instance (array).

        This method is equivalent to "self.inst.cell_inst" and provided for convenience.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def ia(self, ...):
        '''@brief Returns the 'a' axis index for array instances For instance elements describing
        one member of an array, this attribute will deliver the a axis index addressed by this
        element. See \\ib and \\array_member_trans for further attributes applicable to array
        members. If the element is a plain instance and not an array member, this attribute is a
        negative value.

        This method has been introduced in version 0.25.'''

    def ib(self, ...):
        '''@brief Returns the 'b' axis index for array instances For instance elements describing
        one member of an array, this attribute will deliver the a axis index addressed by this
        element. See \\ia and \\array_member_trans for further attributes applicable to array
        members. If the element is a plain instance and not an array member, this attribute is a
        negative value.

        This method has been introduced in version 0.25.'''

    def inst(self, ...):
        '''@brief Gets the \\Instance object held in this instance path element.

        This method has been added in version 0.24.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def prop_id(self, ...):
        '''@brief Accessor to the property attached to this instance.

        This method is equivalent to "self.inst.prop_id" and provided for convenience.'''

    def specific_cplx_trans(self, ...):
        '''@brief Returns the specific complex transformation for this instance

        The specific transformation is the one applicable for the member selected from an array.
        This is the effective transformation applied for this array member. \\array_member_trans
        gives the transformation applied additionally to the instances' global transformation (in
        other words, specific_cplx_trans = array_member_trans * cell_inst.cplx_trans).'''

    def specific_trans(self, ...):
        '''@brief Returns the specific transformation for this instance

        The specific transformation is the one applicable for the member selected from an array.
        This is the effective transformation applied for this array member. \\array_member_trans
        gives the transformation applied additionally to the instances' global transformation (in
        other words, specific_trans = array_member_trans * cell_inst.trans). This method delivers a
        simple transformation that does not include magnification components. To get these as well,
        use \\specific_cplx_trans.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Create an instance element from an array instance pointing into a certain array
        member @args inst, a_index, b_index Starting with version 0.15, this method takes an
        \\Instance object (an instance reference) as the first argument.'''

    @classmethod
    def new_i(cls, ...):
        '''@brief Create an instance element from a single instance alone @args inst Starting with
        version 0.15, this method takes an \\Instance object (an instance reference) as the
        argument.'''

    @classmethod
    def new_iab(cls, ...):
        '''@brief Create an instance element from an array instance pointing into a certain array
        member @args inst, a_index, b_index Starting with version 0.15, this method takes an
        \\Instance object (an instance reference) as the first argument.'''


class Instance:
    '''@brief An instance proxy

    An instance proxy is basically a pointer to an instance of different kinds,  similar to \\Shape,
    the shape proxy. \\Instance objects can be duplicated without creating copies of the instances
    itself: the copy will still point to the same instance than the original.

    When the \\Instance object is modified, the actual instance behind it is modified. The
    \\Instance object acts as a simplified interface for single and array instances with or without
    properties.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Returns the displacement vector for the 'a' axis

    Starting with version 0.25 the displacement is of vector type.

    @brief Sets the displacement vector for the 'a' axis @args a

    If the instance was not an array instance before it is made one.

    This method has been introduced in version 0.23. Starting with version 0.25 the displacement is
    of vector type.

    @brief Sets the displacement vector for the 'a' axis in micrometer units

    Like \\a= with an integer displacement, this method will set the displacement vector but it
    accepts a vector in micrometer units that is of \\DVector type. The vector will be translated to
    database units internally.

    This method has been introduced in version 0.25.'''
    a = None

    '''@brief Returns the displacement vector for the 'b' axis

    Starting with version 0.25 the displacement is of vector type.

    @brief Sets the displacement vector for the 'b' axis @args b

    If the instance was not an array instance before it is made one.

    This method has been introduced in version 0.23. Starting with version 0.25 the displacement is
    of vector type.

    @brief Sets the displacement vector for the 'b' axis in micrometer units

    Like \\b= with an integer displacement, this method will set the displacement vector but it
    accepts a vector in micrometer units that is of \\DVector type. The vector will be translated to
    database units internally.

    This method has been introduced in version 0.25.'''
    b = None

    '''@brief Gets the \\Cell object of the cell this instance refers to

    Please note that before version 0.23 this method returned the cell the instance is contained in.
    For consistency, this method has been renamed \\parent_cell.

    This method has been introduced in version 0.23.

    @brief Gets the \\Cell object of the cell this instance refers to

    This is the const version of the \\cell method. It will return a const \\Cell object and itself
    can be called on a const \\Instance object.

    This variant has been introduced in version 0.25.

    @brief Sets the \\Cell object this instance refers to @args cell

    Setting the cell object to nil is equivalent to deleting the instance.

    This method has been introduced in version 0.23.'''
    cell = None

    '''@brief Get the index of the cell this instance refers to

     @brief Sets the index of the cell this instance refers to @args cell_index

    This method has been introduced in version 0.23.'''
    cell_index = None

    '''@brief Gets the basic \\CellInstArray object associated with this instance reference.

    @brief Changes the \\CellInstArray object to the given one. @args inst This method replaces the
    instance by the given CellInstArray object.

    This method has been introduced in version 0.22

    @brief Returns the basic cell instance array object by giving a micrometer unit object. This
    method replaces the instance by the given CellInstArray object and it internally transformed
    into database units.

    This method has been introduced in version 0.25'''
    cell_inst = None

    '''@brief Gets the complex transformation of the instance or the first instance in the array
    This method is always valid compared to \\trans, since simple transformations can be expressed
    as complex transformations as well.

    @brief Sets the complex transformation of the instance or the first instance in the array

    This method has been introduced in version 0.23.

    @brief Sets the complex transformation of the instance or the first instance in the array (in
    micrometer units) This method sets the transformation the same way as \\cplx_trans=, but the
    displacement of this transformation is given in micrometer units. It is internally translated
    into database units.

    This method has been introduced in version 0.25.'''
    cplx_trans = None

    '''@brief Returns the displacement vector for the 'a' axis in micrometer units

    Like \\a, this method returns the displacement, but it will be translated to database units
    internally.

    This method has been introduced in version 0.25.

    @brief Sets the displacement vector for the 'a' axis in micrometer units

    Like \\a= with an integer displacement, this method will set the displacement vector but it
    accepts a vector in micrometer units that is of \\DVector type. The vector will be translated to
    database units internally.

    This method has been introduced in version 0.25.'''
    da = None

    '''@brief Returns the displacement vector for the 'b' axis in micrometer units

    Like \\b, this method returns the displacement, but it will be translated to database units
    internally.

    This method has been introduced in version 0.25.

    @brief Sets the displacement vector for the 'b' axis in micrometer units

    Like \\b= with an integer displacement, this method will set the displacement vector but it
    accepts a vector in micrometer units that is of \\DVector type. The vector will be translated to
    database units internally.

    This method has been introduced in version 0.25.'''
    db = None

    '''@brief Returns the micrometer unit version of the basic cell instance array object.

    This method has been introduced in version 0.25

    @brief Returns the basic cell instance array object by giving a micrometer unit object. This
    method replaces the instance by the given CellInstArray object and it internally transformed
    into database units.

    This method has been introduced in version 0.25'''
    dcell_inst = None

    '''@brief Gets the complex transformation of the instance or the first instance in the array (in
    micrometer units) This method returns the same transformation as \\cplx_trans, but the
    displacement of this transformation is given in micrometer units. It is internally translated
    from database units into micrometers.

    This method has been introduced in version 0.25.

     @brief Sets the complex transformation of the instance or the first instance in the array (in
    micrometer units) This method sets the transformation the same way as \\cplx_trans=, but the
    displacement of this transformation is given in micrometer units. It is internally translated
    into database units.

    This method has been introduced in version 0.25.'''
    dcplx_trans = None

    '''@brief Gets the transformation of the instance or the first instance in the array (in
    micrometer units) This method returns the same transformation as \\cplx_trans, but the
    displacement of this transformation is given in micrometer units. It is internally translated
    from database units into micrometers.

    This method has been introduced in version 0.25.

     @brief Sets the transformation of the instance or the first instance in the array (in
    micrometer units) This method sets the transformation the same way as \\cplx_trans=, but the
    displacement of this transformation is given in micrometer units. It is internally translated
    into database units.

    This method has been introduced in version 0.25.'''
    dtrans = None

    '''@brief Returns the number of instances in the 'a' axis

     @brief Sets the number of instances in the 'a' axis @args na

    If the instance was not an array instance before it is made one.

    This method has been introduced in version 0.23.'''
    na = None

    '''@brief Returns the number of instances in the 'b' axis

     @brief Sets the number of instances in the 'b' axis @args nb

    If the instance was not an array instance before it is made one.

    This method has been introduced in version 0.23.'''
    nb = None

    '''@brief Gets the cell this instance is contained in

    Returns nil if the instance does not live inside a cell. This method was named "cell" previously
    which lead to confusion with \\cell_index. It was renamed to "parent_cell" in version 0.23.

     @brief Gets the cell this instance is contained in

    Returns nil if the instance does not live inside a cell.

    This const version of the \\parent_cell method has been introduced in version 0.25.

     @brief Moves the instance to a different cell

    Both the current and the target cell must live in the same layout.

    This method has been introduced in version 0.23.'''
    parent_cell = None

    '''@brief Gets the properties ID associated with the instance

     @brief Sets the properties ID associated with the instance @args id This method is provided, if
    a properties ID has been derived already. Usually it's more convenient to use \\delete_property,
    \\set_property or \\property.

    This method has been introduced in version 0.22.'''
    prop_id = None

    '''@brief Gets the transformation of the instance or the first instance in the array The
    transformation returned is only valid if the array does not represent a complex transformation
    array

    @brief Sets the transformation of the instance or the first instance in the array

    This method has been introduced in version 0.23.

    @brief Sets the transformation of the instance or the first instance in the array (in micrometer
    units) This method sets the transformation the same way as \\cplx_trans=, but the displacement
    of this transformation is given in micrometer units. It is internally translated into database
    units.

    This method has been introduced in version 0.25.'''
    trans = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Tests for equality of two Instance objects @args b See the hint on the <
        operator.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __getitem__(self, ...):
        '''@brief Gets the user property with the given key or, if available, the PCell parameter
        with the name given by the key Getting the PCell parameter has priority over the user
        property. This method has been introduced in version 0.25.'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __len__(self, ...):
        '''@brief Gets the number of single instances in the instance array If the instance
        represents a single instance, the count is 1. Otherwise it is na*nb.'''

    def __lt__(self, ...):
        '''@brief Provides an order criterion for two Instance objects @args b Warning: this
        operator is just provided to establish any order, not a particular one.'''

    def __ne__(self, ...):
        '''@brief Tests for inequality of two Instance objects @args b Warning: this operator
        returns true if both objects refer to the same instance, not just identical ones.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Creates a string showing the contents of the reference @args with_cellname

        Passing true to with_cellname makes the string contain the cellname instead of the cell
        index

        This method has been introduced with version 0.23.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Creates a string showing the contents of the reference @args with_cellname

        Passing true to with_cellname makes the string contain the cellname instead of the cell
        index

        This method has been introduced with version 0.23.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Gets the bounding box of the instance The bounding box incorporates all instances
        that the array represents. It gives the overall extension of the child cell as seen in the
        calling cell (or all array members if the instance forms an array).  This method has been
        introduced in version 0.23.'''

    def bbox_per_layer(self, ...):
        '''@brief Gets the bounding box of the instance for a given layer @param layer_index The
        index of the layer the bounding box will be computed for. The bounding box incorporates all
        instances that the array represents. It gives the overall extension of the child cell as
        seen in the calling cell (or all array members if the instance forms an array) for the given
        layer. If the layer is empty in this cell and all it's children', an empty bounding box will
        be returned.  This method has been introduced in version 0.25.'''

    def change_pcell_parameter(self, ...):
        '''@brief Changes a single parameter of a PCell instance to the given value @args name,value

        This method changes a parameter of a PCell instance to the given value. The name identifies
        the PCell parameter and must correspond to one parameter listed in the PCell declaration.

        This method has been introduced in version 0.24.'''

    def change_pcell_parameters(self, ...):
        '''@brief Changes the parameters of a PCell instance to the dictionary of parameters @args
        dict

        This method changes the parameters of a PCell instance to the given values. The values are
        specifies as a dictionary of names (keys) vs. values. Unknown names are ignored and only the
        parameters listed in the dictionary are changed.

        This method has been introduced in version 0.24.'''

    def convert_to_static(self, ...):
        '''@brief Converts a PCell instance to a static cell

        If the instance is a PCell instance, this method will convert the cell into a static cell
        and remove the PCell variant if required. A new cell will be created containing the PCell
        content but begin a static cell. If the instance is not a PCell instance, this method will
        not do anything.

        This method has been introduced in version 0.24.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def dbbox(self, ...):
        '''@brief Gets the bounding box of the instance in micron units Gets the bounding box (see
        \\bbox) of the instance, but will compute the micrometer unit box by multiplying \\bbox with
        the database unit.

        This method has been introduced in version 0.25.'''

    def dbbox_per_layer(self, ...):
        '''@brief Gets the bounding box of the instance in micron units @param layer_index The index
        of the layer the bounding box will be computed for. Gets the bounding box (see
        \\bbox_per_layer) of the instance, but will compute the micrometer unit box by multiplying
        \\bbox_per_layer with the database unit.

        This method has been introduced in version 0.25.'''

    def delete(self, ...):
        '''@brief Deletes this instance

        After this method was called, the instance object is pointing to nothing.

        This method has been introduced in version 0.23.'''

    def delete_property(self, ...):
        '''@brief Deletes the user property with the given key @args key This method is a
        convenience method that deletes the property with the given key. It does nothing if no
        property with that key exists. Using that method is more convenient than creating a new
        property set with a new ID and assigning that properties ID. This method may change the
        properties ID. Calling this method may invalidate any iterators. It should not be called
        inside a loop iterating over instances.

        This method has been introduced in version 0.22.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def explode(self, ...):
        '''@brief Explodes the instance array

        This method does nothing if the instance was not an array before. The instance object will
        point to the first instance of the array afterwards.

        This method has been introduced in version 0.23.'''

    def flatten(self, ...):
        '''@brief Flattens the instance @args levels

        This method will convert the instance to a number of shapes which are equivalent to the
        content of the cell. The instance itself will be removed. This version of the method allows
        specification of the number of hierarchy levels to remove. Specifying 1 for 'levels' will
        remove the instance and replace it by the contents of the cell. Specifying a negative value
        or zero for the number of levels will flatten the instance completely.

        This method has been introduced in version 0.24.'''

    def has_prop_id(self, ...):
        '''@brief Returns true, if the instance has properties'''

    def is_complex(self, ...):
        '''@brief Tests, if the array is a complex array

        Returns true if the array represents complex instances (that is, with magnification and
        arbitrary rotation angles).'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_null(self, ...):
        '''@brief Checks, if the instance is a valid one'''

    def is_pcell(self, ...):
        '''@brief Returns a value indicating whether the instance is a PCell instance

        This method has been introduced in version 0.24.'''

    def is_regular_array(self, ...):
        '''@brief Tests, if this instance is a regular array'''

    def is_valid(self, ...):
        '''@brief Tests if the \\Instance object is still pointing to a valid instance If the
        instance represented by the given reference has been deleted, this method returns false. If
        however, another instance has been inserted already that occupies the original instances
        position, this method will return true again.

        This method has been introduced in version 0.23 and is a shortcut for
        "inst.cell.is_valid?(inst)".'''

    def layout(self, ...):
        '''@brief Gets the layout this instance is contained in

        This const version of the method has been introduced in version 0.25.'''

    def pcell_declaration(self, ...):
        '''@brief Returns the PCell declaration object

        If the instance is a PCell instance, this method returns the PCell declaration object for
        that PCell. If not, this method will return nil. This method has been introduced in version
        0.24.'''

    def pcell_parameter(self, ...):
        '''@brief Gets a PCell parameter by the name of the parameter @return The parameter value or
        nil if the instance is not a PCell or does not have a parameter with given name

        This method has been introduced in version 0.25.'''

    def pcell_parameters(self, ...):
        '''@brief Gets the parameters of a PCell instance as a list of values @return A list of
        values

        If the instance is a PCell instance, this method will return an array of values where each
        value corresponds to one parameter. The order of the values is the order the parameters are
        declared in the PCell declaration. If the instance is not a PCell instance, this list
        returned will be empty.

        This method has been introduced in version 0.24.'''

    def pcell_parameters_by_name(self, ...):
        '''@brief Gets the parameters of a PCell instance as a dictionary of values vs. names
        @return A dictionary of values by parameter name

        If the instance is a PCell instance, this method will return a map of values vs. parameter
        names. The names are the ones defined in the PCell declaration.If the instance is not a
        PCell instance, the dictionary returned will be empty.

        This method has been introduced in version 0.24.'''

    def property(self, ...):
        '''@brief Gets the user property with the given key @args key This method is a convenience
        method that gets the property with the given key. If no property with that key exists, it
        will return nil. Using that method is more convenient than using the layout object and the
        properties ID to retrieve the property value.  This method has been introduced in version
        0.22.'''

    def set_property(self, ...):
        '''@brief Sets the user property with the given key to the given value @args key, value This
        method is a convenience method that sets the property with the given key to the given value.
        If no property with that key exists, it will create one. Using that method is more
        convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID. Calling this method may invalidate any iterators.
        It should not be called inside a loop iterating over instances.

        This method has been introduced in version 0.22.'''

    def size(self, ...):
        '''@brief Gets the number of single instances in the instance array If the instance
        represents a single instance, the count is 1. Otherwise it is na*nb.'''

    def to_s(self, ...):
        '''@brief Creates a string showing the contents of the reference @args with_cellname

        Passing true to with_cellname makes the string contain the cellname instead of the cell
        index

        This method has been introduced with version 0.23.'''

    def transform(self, ...):
        '''@brief Transforms the instance array with the given complex transformation (given in
        micrometer units) Transforms the instance like \\transform does, but with a transformation
        given in micrometer units. The displacement of this transformation is given in micrometers
        and is internally translated to database units.

        This method has been introduced in version 0.25.'''

    def transform_into(self, ...):
        '''@brief Transforms the instance array with the given complex transformation (given in
        micrometer units) Transforms the instance like \\transform_into does, but with a
        transformation given in micrometer units. The displacement of this transformation is given
        in micrometers and is internally translated to database units.

        This method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class LEFDEFReaderConfiguration:
    '''@brief Detailed LEF/DEF reader options This class is a aggregate belonging to the
    \\LoadLayoutOptions class. It provides options for the LEF/DEF reader. These options have been
    placed into a separate class to account for their complexity. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the blockage marker layer datatype value. See \\produce_via_geometry for details
    about the layer production rules.

    @brief Sets the blockage marker layer datatype value. See \\produce_via_geometry for details
    about the layer production rules.'''
    blockages_datatype = None

    '''@brief Gets the blockage marker layer name suffix. See \\produce_via_geometry for details
    about the layer production rules.

    @brief Sets the blockage marker layer name suffix. See \\produce_via_geometry for details about
    the layer production rules.'''
    blockages_suffix = None

    '''@brief Gets the layer on which to produce the cell outline. This attribute is a string
    correspondig to the string representation of \\LayerInfo. This string can be either a layer
    number, a layer/datatype pair, a name or a combination of both. See \\LayerInfo for details. The
    setter for this attribute is \\cell_outline_layer=. See also \\produce_cell_outlines.

    @brief Sets the layer on which to produce the cell outline. See \\cell_outline_layer for
    details.'''
    cell_outline_layer = None

    '''@brief Gets a value indicating whether layers not mapped in the layer map shall be created
    too See \\layer_map for details.

    @brief Sets a value indicating whether layers not mapped in the layer map shall be created too
    See \\layer_map for details.'''
    create_other_layers = None

    '''@brief Gets the database unit to use for producing the layout. This value specifies the
    database to be used for the layout that is read. When a DEF file is specified with a different
    database unit, the layout is translated into this database unit.

     @brief Sets the database unit to use for producing the layout. See \\dbu for details.'''
    dbu = None

    '''@brief Gets the labels layer datatype value. See \\produce_via_geometry for details about the
    layer production rules.

    @brief Sets the labels layer datatype value. See \\produce_via_geometry for details about the
    layer production rules.'''
    labels_datatype = None

    '''@brief Gets the label layer name suffix. See \\produce_via_geometry for details about the
    layer production rules.

    @brief Sets the label layer name suffix. See \\produce_via_geometry for details about the layer
    production rules.'''
    labels_suffix = None

    '''@brief Gets the layer map to be used for the LEF/DEF reader @return A reference to the layer
    map Because LEF/DEF layer mapping is substantially different than for normal layout files, the
    LEF/DEF reader employs a separate layer mapping table. The LEF/DEF specific layer mapping is
    stored within the LEF/DEF reader's configuration and can be accessed with this attribute. The
    layer mapping table of \\LoadLayoutOptions will be ignored for the LEF/DEF reader.

    The setter is \\layer_map=. \\create_other_layers= is available to control whether layers not
    specified in the layer mapping table shall be created automatically.

    @brief Sets the layer map to be used for the LEF/DEF reader See \\layer_map for details.'''
    layer_map = None

    '''@brief Gets the list technology LEF files to additionally import Returns a list of path names
    for technology LEF files to read in addition to the primary file. Relative paths are resolved
    relative to the file to read.

    The setter for this property is \\lef_files=.

    @brief Sets the list technology LEF files to additionally import See \\lef_files for details.'''
    lef_files = None

    '''@brief Gets a value indicating whether and how to produce net names as properties. If set to
    a value not nil, net names will be attached to the shapes and instances generated as user
    properties. This attribute then specifies the user property name to be used for attaching the
    net names. If set to nil, no net names will be produced.

    The corresponding setter is \\net_property_name=.

    @brief Sets a value indicating whether and how to produce net names as properties. See
    \\net_property_name for details.'''
    net_property_name = None

    '''@brief Gets the obstruction marker layer datatype value. See \\produce_via_geometry for
    details about the layer production rules.

    @brief Sets the obstruction marker layer datatype value. See \\produce_via_geometry for details
    about the layer production rules.'''
    obstructions_datatype = None

    '''@brief Gets the obstruction marker layer name suffix. See \\produce_via_geometry for details
    about the layer production rules.

    @brief Sets the obstruction marker layer name suffix. See \\produce_via_geometry for details
    about the layer production rules.'''
    obstructions_suffix = None

    '''@brief Gets the pin geometry layer datatype value. See \\produce_via_geometry for details
    about the layer production rules.

    @brief Sets the pin geometry layer datatype value. See \\produce_via_geometry for details about
    the layer production rules.'''
    pins_datatype = None

    '''@brief Gets the pin geometry layer name suffix. See \\produce_via_geometry for details about
    the layer production rules.

    @brief Sets the pin geometry layer name suffix. See \\produce_via_geometry for details about the
    layer production rules.'''
    pins_suffix = None

    '''@brief Gets the layer on which to produce the placement blockage. This attribute is a string
    correspondig to the string representation of \\LayerInfo. This string can be either a layer
    number, a layer/datatype pair, a name or a combination of both. See \\LayerInfo for details.The
    setter for this attribute is \\placement_blockage_layer=. See also
    \\produce_placement_blockages.

    @brief Sets the layer on which to produce the placement blockage. See \\placement_blockage_layer
    for details.'''
    placement_blockage_layer = None

    '''@brief Gets a value indicating whether routing blockage markers shall be produced. See
    \\produce_via_geometry for details about the layer production rules.

    @brief Sets a value indicating whether routing blockage markers shall be produced. See
    \\produce_via_geometry for details about the layer production rules.'''
    produce_blockages = None

    '''@brief Gets a value indicating whether to produce cell outlines. If set to true, cell
    outlines will be produced on the layer given by \\cell_outline_layer.

    @brief Sets a value indicating whether to produce cell outlines. See \\produce_cell_outlines for
    details.'''
    produce_cell_outlines = None

    '''@brief Gets a value indicating whether labels shall be produced. See \\produce_via_geometry
    for details about the layer production rules.

    @brief Sets a value indicating whether labels shall be produced. See \\produce_via_geometry for
    details about the layer production rules.'''
    produce_labels = None

    '''@brief Gets a value indicating whether obstruction markers shall be produced. See
    \\produce_via_geometry for details about the layer production rules.

    @brief Sets a value indicating whether obstruction markers shall be produced. See
    \\produce_via_geometry for details about the layer production rules.'''
    produce_obstructions = None

    '''@brief Gets a value indicating whether pin geometries shall be produced. See
    \\produce_via_geometry for details about the layer production rules.

    @brief Sets a value indicating whether pin geometries shall be produced. See
    \\produce_via_geometry for details about the layer production rules.'''
    produce_pins = None

    '''@brief Gets a value indicating whether to produce placement blockage regions. If set to true,
    polygons will be produced representing the placement blockage region on the layer given by
    \\placement_blockage_layer.

    @brief Sets a value indicating whether to produce placement blockage regions. See
    \\produce_placement_blockages for details.'''
    produce_placement_blockages = None

    '''@brief Gets a value indicating whether routing geometry shall be produced. See
    \\produce_via_geometry for details about the layer production rules.

    @brief Sets a value indicating whether routing geometry shall be produced. See
    \\produce_via_geometry for details about the layer production rules.'''
    produce_routing = None

    '''@brief Sets a value indicating whether via geometries shall be produced.

    If set to true, shapes will be produced for each via. The layer to be produced will be
    determined from the via layer's name using the suffix provided by \\via_geometry_suffix. If
    there is a specific mapping in the layer mapping table for the via layer including the suffix,
    the layer/datatype will be taken from the layer mapping table. If there is a mapping to the
    undecorated via layer, the datatype will be substituted with the \\via_geometry_datatype value.
    If no mapping is defined, a unique number will be assigned to the layer number and the datatype
    will be taken from the \\via_geometry_datatype value.

    For example: the via layer is 'V1', \\via_geometry_suffix is 'GEO' and \\via_geometry_datatype
    is 1. Then:

    @li @ul If there is a mapping for 'V1.GEO', the layer and datatype will be taken from there.
    @/ul @ul If there is a mapping for 'V1', the layer will be taken from there and the datatype
    will be taken from \\via_geometry_datatype.     The name of the produced layer will be 'V1.GEO'.
    @/ul @ul If there is no mapping for both, the layer number will be a unique value, the datatype
    will be taken from \\via_geometry_datatype     and the layer name will be 'V1.GEO'. @/ul@/li

     @brief Sets a value indicating whether via geometries shall be produced. See
    \\produce_via_geometry for details.'''
    produce_via_geometry = None

    '''@brief Gets the routing layer datatype value. See \\produce_via_geometry for details about
    the layer production rules.

    @brief Sets the routing layer datatype value. See \\produce_via_geometry for details about the
    layer production rules.'''
    routing_datatype = None

    '''@brief Gets the routing layer name suffix. See \\produce_via_geometry for details about the
    layer production rules.

    @brief Sets the routing layer name suffix. See \\produce_via_geometry for details about the
    layer production rules.'''
    routing_suffix = None

    '''@brief Gets the via geometry layer datatype value. See \\produce_via_geometry for details
    about this property.

     @brief Sets the via geometry layer datatype value. See \\produce_via_geometry for details about
    this property.'''
    via_geometry_datatype = None

    '''@brief Gets the via geometry layer name suffix. See \\produce_via_geometry for details about
    this property.

     @brief Sets the via geometry layer name suffix. See \\produce_via_geometry for details about
    this property.'''
    via_geometry_suffix = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class LayerInfo:
    '''@brief A structure encapsulating the layer properties

    The layer properties describe how a layer is stored in a GDS2 or OASIS file for example. The
    \\LayerInfo object represents the storage properties that are attached to a layer in the
    database.

    In general, a layer has either a layer and a datatype number (in GDS2), a name (for example in
    DXF or CIF) or both (in OASIS). In the latter case, the primary identification is through layer
    and datatype number and the name is some annotation attached to it. A \\LayerInfo object which
    specifies just a name returns true on \\is_named?. The \\LayerInfo object can also specify an
    anonymous layer (use \\LayerInfo#new without arguments). Such a layer will not be stored when
    saving the layout. They can be employed for temporary layers for example. Use
    \\LayerInfo#anonymous? to test whether a layer does not have a specification.

    The \\LayerInfo is used for example in \\Layout#insert_layer to specify the properties of the
    new layer that will be created. The \\is_equivalent? method compares two \\LayerInfo objects
    using the layer and datatype numbers with a higher priority over the name. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the datatype

     @brief Set the datatype @args datatype'''
    datatype = None

    '''@brief Gets the layer number

     @brief Sets the layer number @args layer'''
    layer = None

    '''@brief Gets the layer name

     @brief Set the layer name The name is set on OASIS input for example, if the layer has a name.
    @args name'''
    name = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Compares two layer info objects @return True, if both are equal @args b

        This method was added in version 0.18.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given layer info object. This
        method enables layer info objects as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief The constructor for a named layer with layer and datatype. @args
        layer,datatype,name Creates a \\LayerInfo object representing a named layer with layer and
        datatype. @param layer The layer number @param datatype The datatype number @param name The
        name

        This method was added in version 0.18.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''@brief Compares two layer info objects @return True, if both are not equal @args b

        This method was added in version 0.18.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert the layer info object to a string @return The string

        This method was added in version 0.18.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert the layer info object to a string @return The string

        This method was added in version 0.18.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def anonymous(self, ...):
        '''@brief Returns true, if the layer has no specification (i.e. is created by the default
        constructor). @return True, if the layer does not have any specification.

        This method was added in version 0.23.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given layer info object. This
        method enables layer info objects as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_equivalent(self, ...):
        '''@brief Equivalence of two layer info objects @return True, if both are equivalent @args b

        First, layer and datatype are compared. The name is of second order and used only if no
        layer or datatype is given. This is basically a weak comparison that reflects the search
        preferences.

        This method was added in version 0.18.'''

    def is_named(self, ...):
        '''@brief Returns true, if the layer is purely specified by name. @return True, if no layer
        or datatype is given.

        This method was added in version 0.18.'''

    def to_s(self, ...):
        '''@brief Convert the layer info object to a string @return The string

        This method was added in version 0.18.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_string(cls, ...):
        '''@brief Create a layer info object from a string @args s @param The string @return The
        LayerInfo object

        This method will take strings as produced by \\to_s and create a \\LayerInfo object from
        them. The format is either "layer", "layer/datatype", "name" or "name (layer/datatype)".

        This method was added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief The constructor for a named layer with layer and datatype. @args
        layer,datatype,name Creates a \\LayerInfo object representing a named layer with layer and
        datatype. @param layer The layer number @param datatype The datatype number @param name The
        name

        This method was added in version 0.18.'''


class LayerMap:
    '''@brief An object representing an arbitrary mapping of physical layers to logical layers

    "Physical" layers are stream layers or other separated layers in a CAD file. "Logical" layers
    are the layers present in a \\Layout object. Logical layers are represented by an integer index
    while physical layers are given by a layer and datatype number or name. A logical layer is
    created automatically in the layout on reading if it does not exist yet.

    The mapping describes an association of a set of physical layers to a set of logical ones, where
    multiple physical layers can be mapped to a single logical one, which effectively merges the
    layers.

    For each logical layer, a target layer can be specified. A target layer is the
    layer/datatype/name combination as which the logical layer appears in the layout. By using a
    target layer different from the source layer renaming a layer can be achieved while loading a
    layout. Another use case for that feature is to assign layer names to GDS layer/datatype
    combinations which are numerical only.

    LayerMap objects are used in two ways: as input for the reader (inside a \\LoadLayoutOptions
    class) and as output from the reader (i.e. Layout::read method). For layer map objects used as
    input, the layer indexes (logical layers) can be consecutive numbers. They do not need to
    correspond with real layer indexes from a layout object. When used as output, the layer map's
    logical layers correspond to the layer indexes inside the layout that the layer map was used
    upon.

    This is a sample how to use the LayerMap object. It maps all datatypes of layers 1, 2 and 3 to
    datatype 0 and assigns the names 'ONE', 'TWO' and 'THREE' to these layout layers:

    @codelm = RBA::LayerMap::new lm.map("1/0-255 : ONE (1/0)", 0) lm.map("2/0-255 : TWO (2/0)", 1)
    lm.map("3/0-255 : THREE (3/0)", 2)

    # read the layout using the layer map lo = RBA::LoadLayoutOptions::new lo.layer_map.assign(lm)
    ly = RBA::Layout::new ly.read("input.gds", lo) @/code

    The LayerMap class has been introduced in version 0.18. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def clear(self, ...):
        '''@brief Clears the map'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mapped(self, ...):
        '''@brief Check, if a given physical layer is mapped @args layer @param layer The physical
        layer specified with an \\LayerInfo object. @return True, if the layer is mapped.'''

    def logical(self, ...):
        '''@brief Returns the logical layer (the layer index in the layout object) for a given
        physical layer.n@args layer @param layer The physical layer specified with an \\LayerInfo
        object. @return The logical layer index or -1 if the layer is not mapped.'''

    def map(self, ...):
        '''@brief Maps a physical layer given by a string to a logical one @args map_expr,log_layer
        @param map_expr The string describing the physical layer to map. @param log_layer The
        logical layer to which the physical layers are mapped.

        The string expression is constructed using the syntax:  "list[/list][;..]" for
        layer/datatype pairs. "list" is a  sequence of numbers, separated by comma values or a range
        separated by a hyphen. Examples are: "1/2", "1-5/0", "1,2,5/0", "1/5;5/6".

        A target layer can be specified with the ":<target>" notation where the target is a valid
        layer specification string (i.e. "1/0").

        Target mapping has been added in version 0.20.'''

    def mapping(self, ...):
        '''@brief Returns the mapped physical (or target if one is specified) layer for a given
        logical layer @args log_layer @param log_layer The logical layer for which the mapping is
        requested. @return A \\LayerInfo object which is the physical layer mapped to the logical
        layer. In general, there may be more than one physical layer mapped to one logical layer.
        This method will return a single one of them. It will return the one with the lowest layer
        and datatype.'''

    def mapping_str(self, ...):
        '''@brief Returns the mapping string for a given logical layer @args log_layer @param
        log_layer The logical layer for which the mapping is requested. @return A string describing
        the mapping. The mapping string is compatible with the string that the "map" method
        accepts.'''

    def to_string(self, ...):
        '''@brief Converts a layer mapping object to a string This method is the inverse of the
        \\from_string method.

        This method has been introduced in version 0.23.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_string(cls, ...):
        '''@brief Creates a layer map from the given string The format of the string is that used in
        layer mapping files: one mapping entry per line, comments are allowed using '#' or '//'. The
        format of each line is that used in the 'map(string, index)' method.

        This method has been introduced in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class LayerMapping:
    '''@brief A layer mapping (source to target layout)

    A layer mapping is an association of layers in two layouts forming pairs of layers, i.e. one
    layer corresponds to another layer in the other layout. The LayerMapping object describes the
    mapping of layers of a source layout A to a target layout B.

    A layer mapping can be set up manually or using the methods \\create or \\create_full.

    @code lm = RBA::LayerMapping::new # explicit: lm.map(2, 1)  # map layer index 2 of source to 1
    of target lm.map(7, 3)  # map layer index 7 of source to 3 of target ... # or employing the
    specification identity: lm.create(target_layout, source_layout) # plus creating layers which
    don't exist in the target layout yet: new_layers = lm.create_full(target_layout, source_layout)
    @/code

    A layer might not be mapped to another layer which basically means that there is no
    corresponding layer. Such layers will be ignored in operations using the layer mapping. Use
    \\create_full to ensure all layers of the source layout are mapped.

    LayerMapping objects play a role mainly in the hierarchical copy or move operations of \\Layout.
    However, use is not restricted to these applications.

    This class has been introduced in version 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def clear(self, ...):
        '''@brief Clears the mapping.'''

    def create(self, ...):
        '''@brief Initialize the layer mapping from two layouts

        @args layout_a, layout_b @param layout_a The target layout @param layout_b The source layout

        The layer mapping is created by looking up each layer of layout_b in layout_a. All layers
        with matching specifications (\\LayerInfo) are mapped. Layouts without a layer/datatype/name
        specification will not be mapped. \\create_full is a version of this method which creates
        new layers in layout_a if no corresponding layer is found.'''

    def create_full(self, ...):
        '''@brief Initialize the layer mapping from two layouts

        @args layout_a, layout_b @param layout_a The target layout @param layout_b The source layout
        @return A list of layers created

        The layer mapping is created by looking up each layer of layout_b in layout_a. All layers
        with matching specifications (\\LayerInfo) are mapped. Layouts without a layer/datatype/name
        specification will not be mapped. Layers with a valid specification which are not found in
        layout_a are created there.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def has_mapping(self, ...):
        '''@brief Determine if a layer in layout_b has a mapping to a layout_a layer.

        @args layer_index_b

        @param layer_index_b The index of the layer in layout_b whose mapping is requested. @return
        true, if the layer has a mapping'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def layer_mapping(self, ...):
        '''@brief Determine layer mapping of a layout_b layer to the corresponding layout_a layer.

        @args layer_index_b

        @param layer_index_b The index of the layer in layout_b whose mapping is requested. @return
        The corresponding layer in layout_a.'''

    def map(self, ...):
        '''@brief Explicitly specify a mapping.

        @args layer_index_b, layer_index_a

        @param layer_index_b The index of the layer in layout B (the "source") @param layer_index_a
        The index of the layer in layout A (the "target")

        Beside using the mapping generator algorithms provided through \\create and \\create_full,
        it is possible to explicitly specify layer mappings using this method.'''

    def table(self, ...):
        '''@brief Returns the mapping table.

        The mapping table is a dictionary where the keys are source layout layer indexes and the
        values are the target layout layer indexes.

        This method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Layout:
    '''@brief The layout object

    This object represents a layout. The layout object contains the cell hierarchy and adds
    functionality for managing cell names and layer names. The cell hierarchy can be changed by
    adding cells and cell instances. Cell instances will virtually put the content of a cell into
    another cell. Many cell instances can be put into a cell thus forming repetitions of the cell
    content. This process can be repeated over multiple levels. In effect a cell graphs is created
    with parent cells and child cells. The graph must not be recursive, so there is at least one top
    cell, which does not have a parent cell. Multiple top cells can be present.

    \\Layout is the very basic class of the layout database. It has a rich set of methods to
    manipulate and query the layout hierarchy, the geometrical objects, the meta information and
    other features of the layout database. For a discussion of the basic API and the related classes
    see @<a href="/programming/database_api.xml">The Database API@</a>.

    Usually layout objects have already been created by KLayout's application core. You can address
    such a layout via the \\CellView object inside the \\LayoutView class. For example:

    @code active_layout = RBA::CellView::active.layout puts "Top cell of current layout is
    #{active_layout.top_cell.name}" @/code

    However, a layout can also be used standalone:

    @code layout = RBA::Layout::new cell = layout.create_cell("TOP") layer =
    layout.layer(RBA::LayerInfo::new(1, 0)) cell.shapes(layer).insert(RBA::Box::new(0, 0, 1000,
    1000)) layout.write("single_rect.gds") @/code '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the database unit

    The database unit is the value of one units distance in micrometers. For numerical reasons and
    to be compliant with the GDS2 format, the database objects use integer coordinates. The basic
    unit of these coordinates is the database unit. You can convert coordinates to micrometers by
    multiplying the integer value with the database unit. Typical values for the database unit are
    0.001 micrometer (one nanometer).

     @brief Sets the database unit @args dbu

    See \\dbu for a description of the database unit.'''
    dbu = None

    '''@brief Gets the properties ID associated with the layout

    This method has been introduced in version 0.24.

    @brief Sets the properties ID associated with the layout @args id This method is provided, if a
    properties ID has been derived already. Usually it's more convenient to use \\delete_property,
    \\set_property or \\property.

    This method has been introduced in version 0.24.'''
    prop_id = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a layout object @args editable

        This constructor specifies whether the layout is editable. In editable mode, some
        optimisations are disabled and the layout can be manipulated through a variety of methods.

        This method was introduced in version 0.22.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def add_cell(self, ...):
        '''@brief Adds a cell with the given name @args name @return The index of the newly created
        cell.

        From version 0.23 on this method is deprecated because another method exists which is more
        convenient because is returns a \\Cell object (\\create_cell).'''

    def add_lib_cell(self, ...):
        '''@brief Imports a cell from the library @args library, lib_cell_index @param library The
        reference to the library from which to import the cell @param lib_cell_index The index of
        the imported cell in the library @return The cell index of the new proxy cell in this layout
        This method imports the given cell from the library and creates a new proxy cell. The proxy
        cell acts as a pointer to the actual cell which still resides in the  library (precisely: in
        library.layout). The name of the new cell will be the name of library cell.

        This method has been introduced in version 0.22.'''

    def add_meta_info(self, ...):
        '''@brief Adds meta information to the layout See \\LayoutMetaInfo for details about layouts
        and meta information. This method has been introduced in version 0.25.'''

    def add_pcell_variant(self, ...):
        '''@brief Creates a PCell variant for a PCell located in an external library @args library,
        pcell_id, parameters @return The cell index of the new proxy cell in this layout This method
        will import a PCell from a library and create a variant for the  given parameter set.
        Technically, this method creates a proxy to the library and creates the variant inside that
        library.

        The parameters are a sequence of variants which correspond to the parameters declared by the
        \\PCellDeclaration object.

        The name of the new cell will be the name of the PCell.  If a cell with that name already
        exists, a new unique name is generated.

        This method has been introduced in version 0.22.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def begin_shapes(self, ...):
        '''@brief Delivers a recursive shape iterator for the shapes below the given cell on the
        given layer @args cell_index,layer @param cell_index The index of the initial (top) cell
        @param layer The layer from which to get the shapes @return A suitable iterator

        For details see the description of the \\RecursiveShapeIterator class.

        This method has been added in version 0.18.'''

    def begin_shapes_overlapping(self, ...):
        '''@brief Delivers a recursive shape iterator for the shapes below the given cell on the
        given layer using a region search, the region given in micrometer units @param cell The cell
        object for the starting cell @param layer The layer from which to get the shapes @param
        region The search region as a \\DBox object in micrometer units @return A suitable iterator

        For details see the description of the \\RecursiveShapeIterator class. This version gives an
        iterator delivering shapes whose bounding box overlaps the given region. It is convenience
        overload which takes a cell object instead of a cell index.

        This variant has been added in version 0.25.'''

    def begin_shapes_touching(self, ...):
        '''@brief Delivers a recursive shape iterator for the shapes below the given cell on the
        given layer using a region search, the region given in micrometer units @param cell The cell
        object for the starting cell @param layer The layer from which to get the shapes @param
        region The search region as a \\DBox object in micrometer units @return A suitable iterator

        For details see the description of the \\RecursiveShapeIterator class. This version gives an
        iterator delivering shapes whose bounding box touches the given region. It is convenience
        overload which takes a cell object instead of a cell index.

        This variant has been added in version 0.25.'''

    def cell(self, ...):
        '''@brief Gets a cell object from the cell index @args i

        @param i The cell index @return A reference to the cell (a \\Cell object)

        If the cell index is not a valid cell index, this method will raise an error. Use
        \\is_valid_cell_index? to test whether a given cell index is valid.'''

    def cell_by_name(self, ...):
        '''@brief Gets the cell index for a given name @args name Returns the cell index for the
        cell with the given name. If no cell with this name exists, an exception is thrown. From
        version 0.23 on, a version of the \\cell method is provided which returns a \\Cell object
        for the cell with the given name or "nil" if the name is not valid. This method replaces
        \\cell_by_name and \\has_cell?'''

    def cell_name(self, ...):
        '''@brief Gets the name for a cell with the given index @args index'''

    def cells(self, ...):
        '''@brief Returns the number of cells

        @return The number of cells (the maximum cell index)'''

    def cleanup(self, ...):
        '''@brief Cleans up the layout This method will remove proxy objects that are no longer in
        use. After changing PCell parameters such proxy objects may still be present in the layout
        and are cached for later reuse. Usually they are cleaned up automatically occasionally, but
        in a scripting context it may be useful to clean up these cells explicitly.

        This method has been introduced in version 0.25.'''

    def clear(self, ...):
        '''@brief Clears the layout

        Clears the layout completely.'''

    def clear_layer(self, ...):
        '''@brief Clears a layer @args layer_index

        Clears the layer: removes all shapes.

        This method was introduced in version 0.19.

        @param layer_index The index of the layer to delete.'''

    def clip(self, ...):
        '''@brief Clips the given cell by the given rectangle and produce a new cell with the clip
        @args cell, box @param cell The cell index of the cell to clip @param box The clip box in
        database units @return The index of the new cell

        This method will cut a rectangular region given by the box from the given cell. The clip
        will be stored in a new cell whose index is returned. The clip will be performed
        hierarchically. The resulting cell will hold a hierarchy of child cells, which are
        potentially clipped versions of child cells of the original cell. This method has been added
        in version 0.21.'''

    def clip_into(self, ...):
        '''@brief Clips the given cell by the given rectangle and produce a new cell with the clip
        @args cell, target, box @param cell The cell index of the cell to clip @param box The clip
        box in database units @param target The target layout @return The index of the new cell in
        the target layout

        This method will cut a rectangular region given by the box from the given cell. The clip
        will be stored in a new cell in the target layout. The clip will be performed
        hierarchically. The resulting cell will hold a hierarchy of child cells, which are
        potentially clipped versions of child cells of the original cell.

        Please note that it is important that the database unit of the target layout is identical to
        the database unit of the source layout to achieve the desired results.This method also
        assumes that the target layout holds the same layers than the source layout. It will copy
        shapes to the same layers than they have been on the original layout.  This method has been
        added in version 0.21.'''

    def convert_cell_to_static(self, ...):
        '''@brief Converts a PCell or library cell to a usual (static) cell @args cell_index @return
        The index of the new cell This method will create a new cell which contains the static
        representation of the PCell or library proxy given by "cell_index". If that cell is not a
        PCell or library proxy, it won't be touched and the input cell index is returned.

        This method has been added in version 0.23.'''

    def copy_layer(self, ...):
        '''@brief Copies a layer @args src, dest

        This method was introduced in version 0.19.

        Copy a layer from the source to the target. The target is not cleared before, so that this
        method  merges shapes from the source with the target layer.

        @param src The layer index of the source layer. @param dest The layer index of the
        destination layer.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def create_cell(self, ...):
        '''@brief Creates a cell with the given name @args name, lib_name, params @param name The
        name of the PCell and the name of the cell to create @param lib_name The name of the library
        where to take the PCell from @param params The PCell parameters (key/value dictionary)
        @return The \\Cell object of the newly created cell.

        This method will look up the PCell by the given name in the specified library and create a
        new PCell variant with the given parameters. The parameters are specified as a key/value
        dictionary with the names being the ones from the PCell declaration.

        If no PCell with the given name exists or the library name is not valid, nil is returned.

        This method has been introduce in version 0.24.'''

    def delete_cell(self, ...):
        '''@brief Deletes a cell  @args cell_index

        This deletes a cell but not the sub cells of the cell. These subcells will likely become new
        top cells unless they are used otherwise. All instances of this cell are deleted as well.
        Hint: to delete multiple cells, use "delete_cells" which is  far more efficient in this
        case.

        @param cell_index The index of the cell to delete

        This method has been introduced in version 0.20.'''

    def delete_cell_rec(self, ...):
        '''@brief Deletes a cell plus all subcells @args cell_index

        This deletes a cell and also all sub cells of the cell. In contrast to \\prune_cell, all
        cells are deleted together with their instances even if they are used otherwise.

        @param cell_index The index of the cell to delete

        This method has been introduced in version 0.20.'''

    def delete_cells(self, ...):
        '''@brief Deletes multiple cells @args cell_index_list

        This deletes the cells but not the sub cells of these cells. These subcells will likely
        become new top cells unless they are used otherwise. All instances of these cells are
        deleted as well.

        @param cell_index_list An array of cell indices of the cells to delete

        This method has been introduced in version 0.20.'''

    def delete_layer(self, ...):
        '''@brief Deletes a layer @args layer_index

        This method frees the memory allocated for the shapes of this layer and remembers the
        layer's index for reuse when the next layer is allocated.

        @param layer_index The index of the layer to delete.'''

    def delete_property(self, ...):
        '''@brief Deletes the user property with the given key @args key This method is a
        convenience method that deletes the property with the given key. It does nothing if no
        property with that key exists. Using that method is more convenient than creating a new
        property set with a new ID and assigning that properties ID. This method may change the
        properties ID.

        This method has been introduced in version 0.24.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dump_mem_statistics(self, ...):
        '''@hide'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_cell(self, ...):
        '''@brief Iterates the unsorted cell list'''

    def each_cell_bottom_up(self, ...):
        '''@brief Iterates the bottom-up sorted cell list

        In bottom-up traversal a cell is not delivered before the last child cell of this cell has
        been delivered. The bottom-up iterator does not deliver cells but cell indices actually.'''

    def each_cell_top_down(self, ...):
        '''@brief Iterates the top-down sorted cell list

        The top-down cell list has the property of delivering all cells before they are
        instantiated. In addition the first cells are all top cells. There is at least one top cell.
        The top-down iterator does not deliver cells but cell indices actually. @brief begin
        iterator of the top-down sorted cell list'''

    def each_meta_info(self, ...):
        '''@brief Iterates over the meta information of the layout See \\LayoutMetaInfo for details
        about layouts and meta information.

        This method has been introduced in version 0.25.'''

    def each_top_cell(self, ...):
        '''@brief Iterates the top cells A layout may have an arbitrary number of top cells. The
        usual case however is that there is one top cell.'''

    def end_changes(self, ...):
        '''@brief Cancels the "in changes" state (see "start_changes")'''

    def find_layer(self, ...):
        '''@brief Finds a layer with the given layer and datatype number and name @args layer,
        datatype, name

        If a layer with the given layer/datatype/name already exists, this method will return the
        index of that layer.If no such layer exists, it will return nil.

        This method has been introduced in version 0.23.'''

    def flatten(self, ...):
        '''@brief Flattens the given cell @args cell_index, levels, prune

        This method propagates all shapes and instances from the specified number of hierarchy
        levels below into the given cell. It also removes the instances of the cells from which the
        shapes came from, but does not remove the cells themselves if prune is set to false. If
        prune is set to true, these cells are removed if not used otherwise.

        @param cell_index The cell which should be flattened @param levels The number of hierarchy
        levels to flatten (-1: all, 0: none, 1: one level etc.) @param prune Set to true to remove
        orphan cells.

        This method has been introduced in version 0.20.'''

    def flatten_into(self, ...):
        '''@brief Flattens the given cell into another cell @args source_cell_index,
        target_cell_index, trans, levels

        This method works like 'flatten', but allows specification of a target cell which can be
        different from the source cell plus a transformation which is applied for all shapes and
        instances in the target cell.

        In contrast to the 'flatten' method, the source cell is not modified.

        @param source_cell_index The source cell which should be flattened @param target_cell_index
        The target cell into which the resulting objects are written @param trans The transformation
        to apply on the output shapes and instances @param levels The number of hierarchy levels to
        flatten (-1: all, 0: none, 1: one level etc.)

        This method has been introduced in version 0.24.'''

    def get_info(self, ...):
        '''@brief Gets the info structure for a specified layer @args index'''

    def guiding_shape_layer(self, ...):
        '''@brief Returns the index of the guiding shape layer The guiding shape layer is used to
        store guiding shapes for PCells.

        This method has been added in version 0.22.'''

    def has_cell(self, ...):
        '''@brief Returns true if a cell with a given name exists @args name Returns true, if the
        layout has a cell with the given name'''

    def has_prop_id(self, ...):
        '''@brief Returns true, if the layout has user properties

        This method has been introduced in version 0.24.'''

    def insert_layer(self, ...):
        '''@brief Inserts a new layer with the given properties @args props @return The index of the
        newly created layer'''

    def insert_layer_at(self, ...):
        '''@brief Inserts a new layer with the given properties at the given index @args index,
        props This method will associate the given layer info with the given layer index. If a layer
        with that index already exists, this method will change the properties of the layer with
        that index. Otherwise a new layer is created.'''

    def insert_special_layer(self, ...):
        '''@brief Inserts a new special layer with the given properties @args props

        Special layers can be used to represent objects that should not participate in normal
        viewing or other related operations. Special layers are not reported as valid layers.

        @return The index of the newly created layer'''

    def insert_special_layer_at(self, ...):
        '''@brief Inserts a new special layer with the given properties at the given index @args
        index, props

        See \\insert_special_layer for a description of special layers.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_editable(self, ...):
        '''@brief Returns a value indicating whether the layout is editable. @return True, if the
        layout is editable. If a layout is editable, in general manipulation methods are enabled and
        some optimisations are disabled (i.e. shape arrays are expanded).

        This method has been introduced in version 0.22.'''

    def is_special_layer(self, ...):
        '''@brief Returns true, if a layer index is a special layer index @args layer_index

        @return true, if this is the case'''

    def is_valid_cell_index(self, ...):
        '''@brief Returns true, if a cell index is a valid index @args cell_index

        @return true, if this is the case This method has been added in version 0.20.'''

    def is_valid_layer(self, ...):
        '''@brief Returns true, if a layer index is a valid index @args layer_index

        @return true, if this is the case'''

    def layer(self, ...):
        '''@brief Finds or creates a layer with the given layer and datatype number and name @args
        layer, datatype, name

        If a layer with the given layer/datatype/name already exists, this method will return the
        index of that layer.If no such layer exists, a new one with these properties will be created
        and its index will be returned.

        This method has been introduced in version 0.23.'''

    def layer_indexes(self, ...):
        '''@brief Gets a list of valid layer's indices This method returns an array with layer
        indices representing valid layers.

        This method has been introduced in version 0.19.'''

    def layer_indices(self, ...):
        '''@brief Gets a list of valid layer's indices This method returns an array with layer
        indices representing valid layers.

        This method has been introduced in version 0.19.'''

    def layer_infos(self, ...):
        '''@brief Gets a list of valid layer's properties The method returns an array with layer
        properties representing valid layers. The sequence and length of this list corresponds to
        that of \\layer_indexes.

        This method has been introduced in version 0.25.'''

    def layers(self, ...):
        '''@brief Returns the number of layers The number of layers reports the maximum (plus 1)
        layer index used so far. Not all of the layers with an index in the range of 0 to layers-1
        needs to be a valid layer. These layers can be either valid, special or unused. Use
        \\is_valid_layer? and \\is_special_layer? to test for the first two states.'''

    def meta_info_value(self, ...):
        '''@brief Gets the meta information value for a given name See \\LayoutMetaInfo for details
        about layouts and meta information.

        If no meta information with the given name exists, an empty string will be returned.

        This method has been introduced in version 0.25.'''

    def move_layer(self, ...):
        '''@brief Moves a layer @args src, dest

        This method was introduced in version 0.19.

        Move a layer from the source to the target. The target is not cleared before, so that this
        method  merges shapes from the source with the target layer. The source layer is empty after
        that operation.

        @param src The layer index of the source layer. @param dest The layer index of the
        destination layer.'''

    def multi_clip(self, ...):
        '''@brief Clips the given cell by the given rectangles and produce new cells with the clips,
        one for each rectangle. @args cell, boxes @param cell The cell index of the cell to clip
        @param boxes The clip boxes in database units @return The indexes of the new cells

        This method will cut rectangular regions given by the boxes from the given cell. The clips
        will be stored in a new cells whose indexed are returned. The clips will be performed
        hierarchically. The resulting cells will hold a hierarchy of child cells, which are
        potentially clipped versions of child cells of the original cell. This version is somewhat
        more efficient than doing individual clips because the clip cells may share clipped versions
        of child cells.

        This method has been added in version 0.21.'''

    def multi_clip_into(self, ...):
        '''@brief Clips the given cell by the given rectangles and produce new cells with the clips,
        one for each rectangle. @args cell, target, boxes @param cell The cell index of the cell to
        clip @param boxes The clip boxes in database units @param target The target layout @return
        The indexes of the new cells

        This method will cut rectangular regions given by the boxes from the given cell. The clips
        will be stored in a new cells in the given target layout. The clips will be performed
        hierarchically. The resulting cells will hold a hierarchy of child cells, which are
        potentially clipped versions of child cells of the original cell. This version is somewhat
        more efficient than doing individual clips because the clip cells may share clipped versions
        of child cells.

        Please note that it is important that the database unit of the target layout is identical to
        the database unit of the source layout to achieve the desired results. This method also
        assumes that the target layout holds the same layers than the source layout. It will copy
        shapes to the same layers than they have been on the original layout.

        This method has been added in version 0.21.'''

    def pcell_declaration(self, ...):
        '''@brief Gets a reference to the PCell declaration for the PCell with the given PCell ID.
        @args pcell_id Returns a reference to the local PCell declaration with the given PCell id.
        If the parameter is not a valid PCell ID, this method returns nil. The PCell ID is the
        number returned  by \\register_pcell for example.

        Usually this method is used on library layouts that define PCells. Note that this method
        cannot be used on the layouts using the PCell from  a library.

        This method has been introduced in version 0.22.'''

    def pcell_id(self, ...):
        '''@brief Gets the ID of the PCell with the given name @args name This method is equivalent
        to 'pcell_declaration(name).id'.

        This method has been introduced in version 0.22.'''

    def pcell_ids(self, ...):
        '''@brief Gets the IDs of the PCells registered in the layout Returns an array of PCell IDs.

        This method has been introduced in version 0.24.'''

    def pcell_names(self, ...):
        '''@brief Gets the names of the PCells registered in the layout Returns an array of PCell
        names.

        This method has been introduced in version 0.24.'''

    def properties(self, ...):
        '''@brief Gets the properties set for a given properties ID @args properties_id

        Basically performs the backward conversion of the 'properties_id' method. Given a properties
        ID, returns the properties set as an array of pairs of variants. In this array, each key and
        the value are stored as pairs (arrays with two elements). If the properties ID is not valid,
        an empty array is returned.

        @param properties_id The properties ID to get the properties for @return The array of
        variants (see \\properties_id)'''

    def properties_id(self, ...):
        '''@brief Gets the properties ID for a given properties set @args properties

        Before a set of properties can be attached to a shape, it must be converted into an ID that
        is unique for that set. The properties set must be given as a list of pairs of variants,
        each pair describing a name and a value. The name acts as the key for the property and does
        not need to be a string (it can be an integer or double value as well). The backward
        conversion can be performed with the 'properties' method.

        @param properties The array of pairs of variants (both elements can be integer, double or
        string) @return The unique properties ID for that set'''

    def property(self, ...):
        '''@brief Gets the user property with the given key @args key This method is a convenience
        method that gets the property with the given key. If no property with that key exists, it
        will return nil. Using that method is more convenient than using the properties ID to
        retrieve the property value.  This method has been introduced in version 0.24.'''

    def prune_cell(self, ...):
        '''@brief Deletes a cell plus subcells not used otherwise @args cell_index, levels

        This deletes a cell and also all sub cells of the cell which are not used otherwise. The
        number of hierarchy levels to consider can be specified as well. One level of hierarchy
        means that only the direct children of the cell are deleted with the cell itself. All
        instances of this cell are deleted as well.

        @param cell_index The index of the cell to delete @param levels The number of hierarchy
        levels to consider (-1: all, 0: none, 1: one level etc.)

        This method has been introduced in version 0.20.'''

    def prune_subcells(self, ...):
        '''@brief Deletes all sub cells of the cell which are not used otherwise down to the
        specified level of hierarchy @args cell_index, levels

        This deletes all sub cells of the cell which are not used otherwise. All instances of the
        deleted cells are deleted as well. It is possible to specify how many levels of hierarchy
        below the given root cell are considered.

        @param cell_index The root cell from which to delete a sub cells @param levels The number of
        hierarchy levels to consider (-1: all, 0: none, 1: one level etc.)

        This method has been introduced in version 0.20.'''

    def read(self, ...):
        '''@brief Load the layout from the given file with options @args filename,options The format
        of the file is determined automatically and automatic unzipping is provided. In this
        version, some reader options can be specified. @param filename The name of the file to load.
        @param options The options object specifying further options for the reader. @return A layer
        map that contains the mapping used by the reader including the layers that have been
        created. This method has been added in version 0.18.'''

    def register_pcell(self, ...):
        '''@brief Registers a PCell declaration under the given name @args name, declaration
        Registers a local PCell in the current layout. If a declaration with that name alreay
        exists, it is replaced with the new declaration.

        This method has been introduced in version 0.22.'''

    def remove_meta_info(self, ...):
        '''@brief Removes meta information from the layout See \\LayoutMetaInfo for details about
        layouts and meta information. This method has been introduced in version 0.25.'''

    def rename_cell(self, ...):
        '''@brief name @args index, name'''

    def set_info(self, ...):
        '''@brief Sets the info structure for a specified layer @args index, props'''

    def set_property(self, ...):
        '''@brief Set the user property with the given key to the given value @args key, value This
        method is a convenience method that sets the property with the given key to the given value.
        If no property with that key exists, it will create one. Using that method is more
        convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID.  This method has been introduced in version
        0.24.'''

    def start_changes(self, ...):
        '''@brief Signals the start of an operation bringing the layout into invalid state

        This method should be called whenever the layout is about to be brought into an invalid
        state. After calling this method, \\under_construction? returns true which  tells foreign
        code (i.e. the asynchronous painter or the cell tree view) not to use this layout object.

        This state is cancelled by the \\end_changes method. The start_changes method can be called
        multiple times and must be cancelled the same number of times.

        This method can be used to speed up certain operations. For example iterating over the
        layout with a \\RecursiveShapeIterator while modifying other layers of the layout can be
        very inefficient, because inside the loop the layout's state is invalidate and updated
        frequently. Putting a update and start_changes sequence before the loop (use both methods in
        that order!) and a end_changes call after the loop can improve the performance dramatically.

        In addition, it can be necessary to prevent redraw operations in certain cases by using
        start_changes .. end_changes, in particular when it is possible to put a layout object into
        an invalid state temporarily.

        While the layout is under construction \\update can be called to update the internal state
        explicitly if required. This for example might be necessary to update the cell bounding
        boxes or to redo the sorting for region queries.'''

    def swap_layers(self, ...):
        '''@brief Swap two layers @args a, b

        Swaps the shapes of both layers.

        This method was introduced in version 0.19.

        @param a The first of the layers to swap. @param b The second of the layers to swap.'''

    def top_cell(self, ...):
        '''@brief Returns the top cell object @return The \\Cell object of the top cell If the
        layout has a single top cell, this method returns the top cell's \\Cell object. If the
        layout does not have a top cell, this method returns "nil". If the layout has multiple top
        cells, this method raises an error.

        This method has been introduced in version 0.23.'''

    def top_cells(self, ...):
        '''@brief Returns the top cell objects @return The \\Cell objects of the top cells This
        method returns and array of \\Cell objects representing the top cells of the layout. This
        array can be empty, if the layout does not have a top cell (i.e. no cell at all).

        This method has been introduced in version 0.23.'''

    def transform(self, ...):
        '''@brief Transforms the layout with the given complex integer transformation, which is in
        micrometer units This variant will internally translate the transformation's displacement
        into database units. Apart from that, it behaves identical to the version with a
        \\ICplxTrans argument.

        This method has been introduced in version 0.23.'''

    def under_construction(self, ...):
        '''@brief Returns true if the layout object is under construction

        A layout object is either under construction if a transaction is ongoing or the layout is
        brought into invalid state by "start_changes".'''

    def update(self, ...):
        '''@brief Updates the internals of the layout This method updates the internal state of the
        layout. Usually this is done automatically This method is provided to ensure this
        explicitly. This can be useful while using \\start_changes and \\end_changes to wrap a
        performance-critical operation. See \\start_changes for more details.'''

    def write(self, ...):
        '''@brief Writes the layout to a stream file @args filename @param filename The file to
        which to write the layout'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a layout object @args editable

        This constructor specifies whether the layout is editable. In editable mode, some
        optimisations are disabled and the layout can be manipulated through a variety of methods.

        This method was introduced in version 0.22.'''


class LayoutDiff:
    '''@brief The layout compare tool

    The layout compare tool is a facility to quickly compare layouts and derive events that give
    details about the differences. The events are basically emitted following a certain order:

    @ul @li General configuration events (database units, layers ...) @/li @li \\on_begin_cell @/li
    @li \\on_begin_inst_differences (if the instances differ) @/li @li details about instance
    differences (if \\Verbose flag is given) @/li @li \\on_end_inst_differences (if the instances
    differ) @/li @li \\on_begin_layer @/li @li \\on_begin_polygon_differences (if the polygons
    differ) @/li @li details about polygon differences (if \\Verbose flag is given) @/li @li
    \\on_end_polygon_differences (if the polygons differ) @/li @li other shape difference events
    (paths, boxes, ...) @/li @li \\on_end_layer @/li @li repeated layer event groups @/li @li
    \\on_end_cell @/li @li repeated cell event groups @/li @/ul

    To use the diff facility, create a \\LayoutDiff object and call the \\compare_layout or
    \\compare_cell method:

    @code lya = ... # layout A lyb = ... # layout B

    diff = RBA::LayoutDiff::new diff.on_polygon_in_a_only do |poly|   puts "Polygon in A:
    #{diff.cell_a.name}@#{diff.layer_info_a.to_s}: #{poly.to_s}" end diff.on_polygon_in_b_only do
    |poly|   puts "Polygon in A: #{diff.cell_b.name}@#{diff.layer_info_b.to_s}: #{poly.to_s}" end
    diff.compare(lya, lyb, RBA::LayoutDiff::Verbose + RBA::LayoutDiff::NoLayerNames) @/code '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief This signal indicates a difference in the bounding boxes of two cells This signal is
    only emitted in non-verbose mode (without \\Verbose flag) as a summarizing cell property. In
    verbose mode detailed events will be issued indicating the differences.

     @brief This signal indicates a difference in the bounding boxes of two cells This signal is
    only emitted in non-verbose mode (without \\Verbose flag) as a summarizing cell property. In
    verbose mode detailed events will be issued indicating the differences.'''
    on_bbox_differs = None

    '''@brief This signal indicates differences in the boxes on the current layer The current layer
    is indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for boxes that are different between the two layouts.

    @brief This signal indicates differences in the boxes on the current layer The current layer is
    indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for boxes that are different between the two layouts.

    @brief This signal indicates differences in the boxes on the current layer The current layer is
    indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for boxes that are different between the two layouts.'''
    on_begin_box_differences = None

    '''@brief This signal initiates the sequence of events for a cell pair All cell specific events
    happen between \\begin_cell_event and \\end_cell_event signals.

    @brief This signal initiates the sequence of events for a cell pair All cell specific events
    happen between \\begin_cell_event and \\end_cell_event signals.'''
    on_begin_cell = None

    '''@brief This signal indicates differences in the edges on the current layer The current layer
    is indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for edges that are different between the two layouts.

    @brief This signal indicates differences in the edges on the current layer The current layer is
    indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for edges that are different between the two layouts.

    @brief This signal indicates differences in the edges on the current layer The current layer is
    indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for edges that are different between the two layouts.'''
    on_begin_edge_differences = None

    '''@brief This signal indicates differences in the cell instances In verbose mode (see
    \\Verbose) more events will follow that indicate the instances that are present only in the
    first and second layout (\\instance_in_a_only_event and \\instance_in_b_only_event).

    @brief This signal indicates differences in the cell instances In verbose mode (see \\Verbose)
    more events will follow that indicate the instances that are present only in the first and
    second layout (\\instance_in_a_only_event and \\instance_in_b_only_event).

    @brief This signal indicates differences in the cell instances In verbose mode (see \\Verbose)
    more events will follow that indicate the instances that are present only in the first and
    second layout (\\instance_in_a_only_event and \\instance_in_b_only_event). '''
    on_begin_inst_differences = None

    '''@brief This signal indicates differences on the given layer In verbose mode (see \\Verbose)
    more events will follow that indicate the instances that are present only in the first and
    second layout (\\polygon_in_a_only_event, \\polygon_in_b_only_event and similar).

    @brief This signal indicates differences on the given layer In verbose mode (see \\Verbose) more
    events will follow that indicate the instances that are present only in the first and second
    layout (\\polygon_in_a_only_event, \\polygon_in_b_only_event and similar). '''
    on_begin_layer = None

    '''@brief This signal indicates differences in the paths on the current layer The current layer
    is indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for paths that are different between the two layouts.

    @brief This signal indicates differences in the paths on the current layer The current layer is
    indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for paths that are different between the two layouts.

    @brief This signal indicates differences in the paths on the current layer The current layer is
    indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for paths that are different between the two layouts.'''
    on_begin_path_differences = None

    '''@brief This signal indicates differences in the polygons on the current layer The current
    layer is indicated by the \\begin_layer_event signal or can be obtained from the diff object
    through \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for polygons that are different between the two layouts.

    @brief This signal indicates differences in the polygons on the current layer The current layer
    is indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for polygons that are different between the two layouts.

    @brief This signal indicates differences in the polygons on the current layer The current layer
    is indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for polygons that are different between the two layouts.'''
    on_begin_polygon_differences = None

    '''@brief This signal indicates differences in the texts on the current layer The current layer
    is indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for texts that are different between the two layouts.

    @brief This signal indicates differences in the texts on the current layer The current layer is
    indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for texts that are different between the two layouts.

    @brief This signal indicates differences in the texts on the current layer The current layer is
    indicated by the \\begin_layer_event signal or can be obtained from the diff object through
    \\LayoutDiff#layer_info_a, \\LayoutDiff#layer_index_a, \\LayoutDiff#layer_info_b and
    \\LayoutDiff#layer_index_b. In verbose mode (see \\Verbose flag) more signals will be emitted
    for texts that are different between the two layouts.'''
    on_begin_text_differences = None

    '''@brief This signal indicates a box that is present in the first layout only

    @brief This signal indicates a box that is present in the first layout only'''
    on_box_in_a_only = None

    '''@brief This signal indicates a box that is present in the second layout only

    @brief This signal indicates a box that is present in the second layout only'''
    on_box_in_b_only = None

    '''@brief This signal indicates that the given cell is only present in the first layout

     @brief This signal indicates that the given cell is only present in the first layout'''
    on_cell_in_a_only = None

    '''@brief This signal indicates that the given cell is only present in the second layout

     @brief This signal indicates that the given cell is only present in the second layout'''
    on_cell_in_b_only = None

    '''@brief This signal indicates a difference in the cell names This signal is emitted in 'smart
    cell mapping' mode (see \\SmartCellMapping) if two cells are considered identical, but have
    different names.

    @brief This signal indicates a difference in the cell names This signal is emitted in 'smart
    cell mapping' mode (see \\SmartCellMapping) if two cells are considered identical, but have
    different names.'''
    on_cell_name_differs = None

    '''@brief This signal indicates a difference in the database units of the layouts

     @brief This signal indicates a difference in the database units of the layouts'''
    on_dbu_differs = None

    '''@brief This signal indicates an edge that is present in the first layout only

    @brief This signal indicates an edge that is present in the first layout only'''
    on_edge_in_a_only = None

    '''@brief This signal indicates an edge that is present in the second layout only

    @brief This signal indicates an edge that is present in the second layout only'''
    on_edge_in_b_only = None

    '''@brief This signal indicates the end of sequence of box differences

     @brief This signal indicates the end of sequence of box differences

     @brief This signal indicates the end of sequence of box differences'''
    on_end_box_differences = None

    '''@brief This signal indicates the end of a sequence of signals for a specific cell

     @brief This signal indicates the end of a sequence of signals for a specific cell

     @brief This signal indicates the end of a sequence of signals for a specific cell'''
    on_end_cell = None

    '''@brief This signal indicates the end of sequence of edge differences

     @brief This signal indicates the end of sequence of edge differences

     @brief This signal indicates the end of sequence of edge differences'''
    on_end_edge_differences = None

    '''@brief This signal finishes a sequence of detailed instance difference events

     @brief This signal finishes a sequence of detailed instance difference events

     @brief This signal finishes a sequence of detailed instance difference events'''
    on_end_inst_differences = None

    '''@brief This signal indicates the end of a sequence of signals for a specific layer

     @brief This signal indicates the end of a sequence of signals for a specific layer

     @brief This signal indicates the end of a sequence of signals for a specific layer'''
    on_end_layer = None

    '''@brief This signal indicates the end of sequence of path differences

     @brief This signal indicates the end of sequence of path differences

     @brief This signal indicates the end of sequence of path differences'''
    on_end_path_differences = None

    '''@brief This signal indicates the end of sequence of polygon differences

     @brief This signal indicates the end of sequence of polygon differences

     @brief This signal indicates the end of sequence of polygon differences'''
    on_end_polygon_differences = None

    '''@brief This signal indicates the end of sequence of text differences

     @brief This signal indicates the end of sequence of text differences

     @brief This signal indicates the end of sequence of text differences'''
    on_end_text_differences = None

    '''@brief This signal indicates an instance that is present only in the first layout This event
    is only emitted in verbose mode (\\Verbose flag).

    @brief This signal indicates an instance that is present only in the first layout This event is
    only emitted in verbose mode (\\Verbose flag).'''
    on_instance_in_a_only = None

    '''@brief This signal indicates an instance that is present only in the second layout This event
    is only emitted in verbose mode (\\Verbose flag).

    @brief This signal indicates an instance that is present only in the second layout This event is
    only emitted in verbose mode (\\Verbose flag).'''
    on_instance_in_b_only = None

    '''@brief This signal indicates a layer that is present only in the first layout

     @brief This signal indicates a layer that is present only in the first layout'''
    on_layer_in_a_only = None

    '''@brief This signal indicates a layer that is present only in the second layout

     @brief This signal indicates a layer that is present only in the second layout'''
    on_layer_in_b_only = None

    '''@brief This signal indicates a difference in the layer names

     @brief This signal indicates a difference in the layer names'''
    on_layer_name_differs = None

    '''@brief This signal indicates a path that is present in the first layout only

    @brief This signal indicates a path that is present in the first layout only'''
    on_path_in_a_only = None

    '''@brief This signal indicates a path that is present in the second layout only

    @brief This signal indicates a path that is present in the second layout only'''
    on_path_in_b_only = None

    '''@brief This signal indicates differences in the per-layer bounding boxes of the current cell

     @brief This signal indicates differences in the per-layer bounding boxes of the current cell'''
    on_per_layer_bbox_differs = None

    '''@brief This signal indicates a polygon that is present in the first layout only

     @brief This signal indicates a polygon that is present in the first layout only'''
    on_polygon_in_a_only = None

    '''@brief This signal indicates a polygon that is present in the second layout only

     @brief This signal indicates a polygon that is present in the second layout only'''
    on_polygon_in_b_only = None

    '''@brief This signal indicates a text that is present in the first layout only

    @brief This signal indicates a text that is present in the first layout only'''
    on_text_in_a_only = None

    '''@brief This signal indicates a text that is present in the second layout only

    @brief This signal indicates a text that is present in the second layout only'''
    on_text_in_b_only = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def cell_a(self, ...):
        '''@brief Gets the current cell for the first layout This attribute is the current cell and
        is set after \\on_begin_cell and reset after \\on_end_cell.'''

    def cell_b(self, ...):
        '''@brief Gets the current cell for the second layout This attribute is the current cell and
        is set after \\on_begin_cell and reset after \\on_end_cell.'''

    def compare(self, ...):
        '''@brief Compares two cells

        Compares layer definitions, cells, instances and shapes and properties of two layout
        hierarchies starting from the given cells. Cells are identified by name. Only layers with
        valid layer and datatype are compared. Several flags can be specified as a bitwise or
        combination of the constants.

        @param a The first top cell @param b The second top cell @param flags Flags to use for the
        comparison @param tolerance A coordinate tolerance to apply (0: exact match, 1: one DBU
        tolerance is allowed ...)

        @return True, if the cells are identical'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def layer_index_a(self, ...):
        '''@brief Gets the current layer for the first layout This attribute is the current cell and
        is set after \\on_begin_layer and reset after \\on_end_layer.'''

    def layer_index_b(self, ...):
        '''@brief Gets the current layer for the second layout This attribute is the current cell
        and is set after \\on_begin_layer and reset after \\on_end_layer.'''

    def layer_info_a(self, ...):
        '''@brief Gets the current layer properties for the first layout This attribute is the
        current cell and is set after \\on_begin_layer and reset after \\on_end_layer.'''

    def layer_info_b(self, ...):
        '''@brief Gets the current layer properties for the second layout This attribute is the
        current cell and is set after \\on_begin_layer and reset after \\on_end_layer.'''

    def layout_a(self, ...):
        '''@brief Gets the first layout the difference detector runs on'''

    def layout_b(self, ...):
        '''@brief Gets the second layout the difference detector runs on'''

    def on_bbox_differs_(self, ...):
        '''@brief This signal indicates a difference in the bounding boxes of two cells This signal
        is only emitted in non-verbose mode (without \\Verbose flag) as a summarizing cell property.
        In verbose mode detailed events will be issued indicating the differences.'''

    def on_begin_cell_(self, ...):
        '''@brief This signal initiates the sequence of events for a cell pair All cell specific
        events happen between \\begin_cell_event and \\end_cell_event signals.'''

    def on_begin_layer_(self, ...):
        '''@brief This signal indicates differences on the given layer In verbose mode (see
        \\Verbose) more events will follow that indicate the instances that are present only in the
        first and second layout (\\polygon_in_a_only_event, \\polygon_in_b_only_event and similar).
        '''

    def on_box_in_a_only_(self, ...):
        '''@brief This signal indicates a box that is present in the first layout only'''

    def on_box_in_b_only_(self, ...):
        '''@brief This signal indicates a box that is present in the second layout only'''

    def on_cell_in_a_only_(self, ...):
        '''@brief This signal indicates that the given cell is only present in the first layout'''

    def on_cell_in_b_only_(self, ...):
        '''@brief This signal indicates that the given cell is only present in the second layout'''

    def on_cell_name_differs_(self, ...):
        '''@brief This signal indicates a difference in the cell names This signal is emitted in
        'smart cell mapping' mode (see \\SmartCellMapping) if two cells are considered identical,
        but have different names.'''

    def on_dbu_differs_(self, ...):
        '''@brief This signal indicates a difference in the database units of the layouts'''

    def on_edge_in_a_only_(self, ...):
        '''@brief This signal indicates an edge that is present in the first layout only'''

    def on_edge_in_b_only_(self, ...):
        '''@brief This signal indicates an edge that is present in the second layout only'''

    def on_instance_in_a_only_(self, ...):
        '''@brief This signal indicates an instance that is present only in the first layout This
        event is only emitted in verbose mode (\\Verbose flag).'''

    def on_instance_in_b_only_(self, ...):
        '''@brief This signal indicates an instance that is present only in the second layout This
        event is only emitted in verbose mode (\\Verbose flag).'''

    def on_layer_in_a_only_(self, ...):
        '''@brief This signal indicates a layer that is present only in the first layout'''

    def on_layer_in_b_only_(self, ...):
        '''@brief This signal indicates a layer that is present only in the second layout'''

    def on_layer_name_differs_(self, ...):
        '''@brief This signal indicates a difference in the layer names'''

    def on_path_in_a_only_(self, ...):
        '''@brief This signal indicates a path that is present in the first layout only'''

    def on_path_in_b_only_(self, ...):
        '''@brief This signal indicates a path that is present in the second layout only'''

    def on_per_layer_bbox_differs_(self, ...):
        '''@brief This signal indicates differences in the per-layer bounding boxes of the current
        cell'''

    def on_polygon_in_a_only_(self, ...):
        '''@brief This signal indicates a polygon that is present in the first layout only'''

    def on_polygon_in_b_only_(self, ...):
        '''@brief This signal indicates a polygon that is present in the second layout only'''

    def on_text_in_a_only_(self, ...):
        '''@brief This signal indicates a text that is present in the first layout only'''

    def on_text_in_b_only_(self, ...):
        '''@brief This signal indicates a text that is present in the second layout only'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class LayoutMetaInfo:
    '''@brief A piece of layout meta information Layout meta information is basically additional
    data that can be attached to a layout. Layout readers may generate meta information and some
    writers will add layout information to the layout object. Some writers will also read meta
    information to determine certain attributes.

    Multiple layout meta information objects can be attached to one layout using \\Layout#add_meta.
    Meta information is identified by a unique name and carries a string value plus an optional
    description string. The description string is for information only and is not evaluated by code.

    See also \\Layout#each_meta_info and \\Layout#meta_info_value and \\Layout#remove_meta_info This
    class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the description of the layout meta info object

     @brief Sets the description of the layout meta info object'''
    description = None

    '''@brief Gets the name of the layout meta info object

     @brief Sets the name of the layout meta info object'''
    name = None

    '''@brief Gets the value of the layout meta info object

     @brief Sets the value of the layout meta info object'''
    value = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a layout meta info object @param name The name @param value The value
        @param description An optional description text'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a layout meta info object @param name The name @param value The value
        @param description An optional description text'''


class LayoutQuery:
    '''@brief A layout query Layout queries are the backbone of the "Search & replace" feature.
    Layout queries allow retrieval of data from layouts and manipulation of layouts. This object
    provides script binding for this feature. Layout queries are used by first creating a query
    object. Depending on the nature of the query, either \\execute or \\each can be used to execute
    the query. \\execute will run the query and return once the query is finished. \\execute is
    useful for running queries that don't return results such as "delete" or "with ... do" queries.
    \\each can be used when the results of the query need to be retrieved.

    The \\each method will call a block a of code for every result available. It will provide a
    \\LayoutQueryIterator object that allows accessing the results of the query. Depending on the
    query, different attributes of the iterator object will be available. For example, "select"
    queries will fill the "data" attribute with an array of values corresponding to the columns of
    the selection.

    Here is some sample code: @code ly = RBA::CellView::active.layout q =
    RBA::LayoutQuery::new("select cell.name, cell.bbox from *") q.each(ly) do |iter|   puts "cell
    name: #{iter.data[0]}, bounding box: #{iter.data[1]}" end @/code

    The LayoutQuery class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new query object from the given query string'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def each(self, ...):
        '''@brief Executes the query and delivered the results iteratively. The argument to the
        block is a \\LayoutQueryIterator object which can be asked for specific results.'''

    def execute(self, ...):
        '''@brief Executes the query

        This method can be used to execute "active" queries such as "delete" or "with ... do". It is
        basically equivalent to iterating over the query until it is done.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def property_names(self, ...):
        '''@brief Gets a list of property names available. The list of properties available from the
        query depends on the nature of the query. This method allows detection of the properties
        available. Within the query, all of these properties can be obtained from the query iterator
        using \\LayoutQueryIterator#get.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new query object from the given query string'''


class LayoutQueryIterator:
    '''@brief Provides the results of the query

    This object is used by \\LayoutQuery#each to deliver the results of a query in an iterative
    fashion. See \\LayoutQuery for a detailed description of the query interface.

    The LayoutQueryIterator class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def cell(self, ...):
        '''@brief A shortcut for 'get("cell")''''

    def cell_index(self, ...):
        '''@brief A shortcut for 'get("cell_index")''''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def data(self, ...):
        '''@brief A shortcut for 'get("data")''''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def get(self, ...):
        '''@brief Gets the query property with the given name The query properties available can be
        obtained from the query object using \\LayoutQuery#property_names. Some shortcut methods are
        available. For example, the \\data method provides a shortcut for 'get("data")'.

        If a property with the given name is not available, nil will be returned.'''

    def initial_cell(self, ...):
        '''@brief A shortcut for 'get("initial_cell")''''

    def initial_cell_index(self, ...):
        '''@brief A shortcut for 'get("initial_cell_index")''''

    def inst(self, ...):
        '''@brief A shortcut for 'get("inst")''''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def layer_index(self, ...):
        '''@brief A shortcut for 'get("layer_index")''''

    def layout(self, ...):
        '''@brief Gets the layout the query acts on'''

    def parent_cell(self, ...):
        '''@brief A shortcut for 'get("parent_cell")''''

    def parent_cell_index(self, ...):
        '''@brief A shortcut for 'get("parent_cell_index")''''

    def path_trans(self, ...):
        '''@brief A shortcut for 'get("path_trans")''''

    def query(self, ...):
        '''@brief Gets the query the iterator follows on'''

    def shape(self, ...):
        '''@brief A shortcut for 'get("shape")''''

    def trans(self, ...):
        '''@brief A shortcut for 'get("trans")''''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Library:
    '''@brief A Library

    A library is basically a wrapper around a layout object. The layout object provides cells and
    potentially PCells that can be imported into other layouts.

    The library provides a name which is used to identify the library and a description which is
    used for identifying the library in a user interface.

    After a library is created and the layout is filled, it must be registered using the register
    method.

    This class has been introduced in version 0.22. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Returns the libraries' description text

     @brief Sets the libraries' description text @args description'''
    description = None

    '''@brief Returns name of the technology the library is associated with If this attribute is a
    non-empty string, this library is only offered for selection if the current layout uses this
    technology.

    This attribute has been introduced in version 0.25.

    @brief sets the name of the technology the library is associated with @args technology

    See \\technology for details. This attribute has been introduced in version 0.25.'''
    technology = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new, empty library'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def delete(self, ...):
        '''@brief Deletes the library

        This method will delete the library object. Library proxies pointing to this library will
        become invalid and the library object cannot be used any more after calling this method.

        This method has been introduced in version 0.25.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def id(self, ...):
        '''@brief Returns the library's ID The ID is set when the library is registered and cannot
        be changed '''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def layout(self, ...):
        '''@brief The layout object where the cells reside that this library defines'''

    def layout_const(self, ...):
        '''@brief The layout object where the cells reside that this library defines (const
        version)'''

    def name(self, ...):
        '''@brief Returns the libraries' name The name is set when the library is registered and
        cannot be changed'''

    def register(self, ...):
        '''@brief Registers the library with the given name @args name

        This method can be called in the constructor to register the library after  the layout
        object has been filled with content. If a library with that name already exists, it will be
        replaced with this library.

        This method will set the libraries' name.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def library_by_name(cls, ...):
        '''@brief Gets a library by name @args name Returns the library object for the given name.
        If the name is not a valid library name, nil is returned.'''

    @classmethod
    def library_names(cls, ...):
        '''@brief Returns a list of the names of all libraries registered in the system.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new, empty library'''


class LoadLayoutOptions:
    '''@brief Layout reader options

    This object describes various layer reader options used for loading layouts.

    This class has been introduced in version 0.18. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets a value indicating whether other layers shall be created @return True, if other
    layers should be created.

    This method has been added in version 0.25 and replaces the respective global option in
    \\LoadLayoutOptions in a format-specific fashion.

    @brief Specifies whether other layers shall be created @param create True, if other layers
    should be created.

    This method has been added in version 0.25 and replaces the respective global option in
    \\LoadLayoutOptions in a format-specific fashion.'''
    cif_create_other_layers = None

    '''@brief Specifies the database unit which the reader uses and produces See \\cif_dbu= method
    for a description of this property. This property has been added in version 0.21.

     @brief Specifies the database unit which the reader uses and produces

    This property has been added in version 0.21.'''
    cif_dbu = None

    '''@brief Gets a value indicating whether layer names are kept @return True, if layer names are
    kept.

    When set to true, no attempt is made to translate layer names to GDS layer/datatype numbers. If
    set to false (the default), a layer named "L2D15" will be translated to GDS layer 2, datatype
    15.

    This method has been added in version 0.25.3.

    @brief Gets a value indicating whether layer names are kept @param keep True, if layer names are
    to be kept.

    See \\cif_keep_layer_names? for a description of this property.

    This method has been added in version 0.25.3.'''
    cif_keep_layer_names = None

    '''@brief Gets the layer map @return A reference to the layer map

    This method has been added in version 0.25 and replaces the respective global option in
    \\LoadLayoutOptions in a format-specific fashion.

    Python note: this method has been turned into a property in version 0.26.

    @brief Sets the layer map This sets a layer mapping for the reader. Unlike \\cif_set_layer_map,
    the 'create_other_layers' flag is not changed. @param map The layer map to set. This convenience
    method has been added in version 0.26.'''
    cif_layer_map = None

    '''@brief Specifies how to read 'W' objects See \\cif_wire_mode= method for a description of
    this mode. This property has been added in version 0.21 and was renamed to cif_wire_mode in
    0.25.

     @brief How to read 'W' objects

    This property specifies how to read 'W' (wire) objects. Allowed values are 0 (as square ended
    paths), 1 (as flush ended paths), 2 (as round paths)

    This property has been added in version 0.21.'''
    cif_wire_mode = None

    '''@brief Gets a value indicating whether other layers shall be created @return True, if other
    layers should be created.

    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats
    provide their own configuration.

    @brief Specifies whether other layers shall be created @param create True, if other layers
    should be created.

    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats
    provide their own configuration.'''
    create_other_layers = None

    '''@brief Gets the accuracy of the circle approximation

    This property has been added in version 0.24.9.

     @brief Specifies the accuracy of the circle approximation @args accuracy

    In addition to the number of points per circle, the circle accuracy can be specified. If set to
    a value larger than the database unit, the number of points per circle will be chosen such that
    the deviation from the ideal circle becomes less than this value.

    The actual number of points will not become bigger than the points specified through
    \\dxf_circle_points=. The accuracy value is given in the DXF file units (see \\dxf_unit) which
    is usually micrometers.

    \\dxf_circle_points and \\dxf_circle_accuracy also apply to other "round" structures such as
    arcs, ellipses and splines in the same sense than for circles.

     This property has been added in version 0.24.9.'''
    dxf_circle_accuracy = None

    '''@brief Gets the number of points used per full circle for arc interpolation

    This property has been added in version 0.21.6.

     @brief Specifies the number of points used per full circle for arc interpolation @args points
    See also \\dxf_circle_accuracy for how to specify the number of points based on an approximation
    accuracy.

    \\dxf_circle_points and \\dxf_circle_accuracy also apply to other "round" structures such as
    arcs, ellipses and splines in the same sense than for circles.

     This property has been added in version 0.21.6.'''
    dxf_circle_points = None

    '''@brief Gets the accuracy for contour closing

     This property has been added in version 0.25.3.

     @brief Specifies the accuracy for contour closing @args accuracy

    When polylines need to be connected or closed, this value is used to indicate the accuracy. This
    is the value (in DXF units) by which points may be separated and still be considered connected.
    The default is 0.0 which implies exact (within one DBU) closing.

    This value is effective in polyline mode 3 and 4.

     This property has been added in version 0.25.3.'''
    dxf_contour_accuracy = None

    '''@brief Gets a value indicating whether other layers shall be created @return True, if other
    layers should be created.

    This method has been added in version 0.25 and replaces the respective global option in
    \\LoadLayoutOptions in a format-specific fashion.

    @brief Specifies whether other layers shall be created @param create True, if other layers
    should be created.

    This method has been added in version 0.25 and replaces the respective global option in
    \\LoadLayoutOptions in a format-specific fashion.'''
    dxf_create_other_layers = None

    '''@brief Specifies the database unit which the reader uses and produces

    This property has been added in version 0.21.

     @brief Specifies the database unit which the reader uses and produces @args dbu

    This property has been added in version 0.21.'''
    dxf_dbu = None

    '''@brief Gets a value indicating whether layer names are kept @return True, if layer names are
    kept.

    When set to true, no attempt is made to translate layer names to GDS layer/datatype numbers. If
    set to false (the default), a layer named "L2D15" will be translated to GDS layer 2, datatype
    15.

    This method has been added in version 0.25.3.

    @brief Gets a value indicating whether layer names are kept @param keep True, if layer names are
    to be kept.

    See \\cif_keep_layer_names? for a description of this property.

    This method has been added in version 0.25.3.'''
    dxf_keep_layer_names = None

    '''@brief If this option is true, all cells are kept, not only the top cell and it's children

    This property has been added in version 0.21.15.

     @brief If this option is true, all cells are kept, not only the top cell and it's children

    This property has been added in version 0.21.15.

     @brief If this option is set to true, all cells are kept, not only the top cell and it's
    children @args value

    This property has been added in version 0.21.15.'''
    dxf_keep_other_cells = None

    '''@brief Gets the layer map @return A reference to the layer map

    This method has been added in version 0.25 and replaces the respective global option in
    \\LoadLayoutOptions in a format-specific fashion. Python note: this method has been turned into
    a property in version 0.26.

    @brief Sets the layer map This sets a layer mapping for the reader. Unlike \\dxf_set_layer_map,
    the 'create_other_layers' flag is not changed. @param map The layer map to set. This convenience
    method has been added in version 0.26.'''
    dxf_layer_map = None

    '''@brief Specifies whether closed POLYLINE and LWPOLYLINE entities with width 0 are converted
    to polygons. See \\dxf_polyline_mode= for a description of this property.

    This property has been added in version 0.21.3.

     @brief Specifies how to treat POLYLINE/LWPOLYLINE entities. @args mode The mode is 0
    (automatic), 1 (keep lines), 2 (create polygons from closed polylines with width = 0), 3 (merge
    all lines with width = 0 into polygons), 4 (as 3 plus auto-close open contours).

    This property has been added in version 0.21.3.'''
    dxf_polyline_mode = None

    '''@brief If this option is true, text objects are rendered as polygons

    This property has been added in version 0.21.15.

     @brief If this option is true, text objects are rendered as polygons

    This property has been added in version 0.21.15.

     @brief If this option is set to true, text objects are rendered as polygons @args value

    This property has been added in version 0.21.15.'''
    dxf_render_texts_as_polygons = None

    '''@brief Gets the text scaling factor (see \\dxf_text_scaling=)

    This property has been added in version 0.21.20.

     @brief Specifies the text scaling in percent of the default scaling @args unit

    The default value 100, meaning that the letter pitch is roughly 92 percent of the specified text
    height. Decrease this value to get smaller fonts and increase it to get larger fonts.

    This property has been added in version 0.21.20.'''
    dxf_text_scaling = None

    '''@brief Specifies the unit in which the DXF file is drawn

    This property has been added in version 0.21.3.

     @brief Specifies the unit in which the DXF file is drawn. @args unit

    This property has been added in version 0.21.3.'''
    dxf_unit = None

    '''@brief Gets a value specifying whether to allow big records with a length of 32768 to 65535
    bytes. See \\gds2_allow_big_records= method for a description of this property. This property
    has been added in version 0.18.

     @brief Gets a value specifying whether to allow big records with a length of 32768 to 65535
    bytes. See \\gds2_allow_big_records= method for a description of this property. This property
    has been added in version 0.18.

     @brief Allows big records with more than 32767 bytes

    Setting this property to true allows larger records by treating the record length as unsigned
    short, which for example allows larger polygons (~8000 points rather than ~4000 points) without
    using multiple XY records. For strict compatibility with the standard, this property should be
    set to false. The default is true.

    This property has been added in version 0.18.'''
    gds2_allow_big_records = None

    '''@brief Gets a value specifying whether to allow big polygons with multiple XY records. See
    \\gds2_allow_multi_xy_records= method for a description of this property. This property has been
    added in version 0.18.

     @brief Gets a value specifying whether to allow big polygons with multiple XY records. See
    \\gds2_allow_multi_xy_records= method for a description of this property. This property has been
    added in version 0.18.

     @brief Allows the use of multiple XY records in BOUNDARY elements for unlimited large polygons

    Setting this property to true allows big polygons that span over multiple XY records. For strict
    compatibility with the standard, this property should be set to false. The default is true.

    This property has been added in version 0.18.'''
    gds2_allow_multi_xy_records = None

    '''@brief Gets a value specifying how to treat BOX records See \\gds2_box_mode= method for a
    description of this mode. This property has been added in version 0.18.

     @brief Sets a value specifying how to treat BOX records This property specifies how BOX records
    are treated. Allowed values are 0 (ignore), 1 (treat as rectangles), 2 (treat as boundaries) or
    3 (treat as errors). The default is 1.

    This property has been added in version 0.18.'''
    gds2_box_mode = None

    '''@brief Gets the layer map @return A reference to the layer map

    Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats
    provide their own configuration. Python note: this method has been turned into a property in
    version 0.26.

    @brief Sets the layer map, but does not affect the "create_other_layers" flag. @param map The
    layer map to set. This convenience method has been introduced with version 0.26.'''
    layer_map = None

    '''@brief Gets a copy of the LEF/DEF reader configuration The LEF/DEF reader configuration is
    wrapped in a separate object of class \\LEFDEFReaderConfiguration. See there for details. This
    method will return a copy of the reader configuration. To modify the configuration, modify the
    copy and set the modified configuration with \\lefdef_config=.

     This method has been added in version 0.25.

     @brief Sets the LEF/DEF reader configuration

     This method has been added in version 0.25.'''
    lefdef_config = None

    '''@hide

    @hide'''
    oasis_expect_strict_mode = None

    '''@hide

    @hide'''
    oasis_read_all_properties = None

    '''@brief Gets a value indicating whether properties shall be read @return True, if properties
    should be read. Starting with version 0.25 this option only applies to GDS2 and OASIS format.
    Other formats provide their own configuration.

    @brief Specifies whether properties should be read @args enabled @param enabled True, if
    properties should be read. Starting with version 0.25 this option only applies to GDS2 and OASIS
    format. Other formats provide their own configuration.'''
    properties_enabled = None

    '''@brief Gets a value indicating whether text objects shall be read @return True, if text
    objects should be read. Starting with version 0.25 this option only applies to GDS2 and OASIS
    format. Other formats provide their own configuration.

    @brief Specifies whether text objects shall be read @param enabled True, if text objects should
    be read. Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other
    formats provide their own configuration.'''
    text_enabled = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def cif_select_all_layers(self, ...):
        '''@brief Selects all layers and disables the layer map

        This disables any layer map and enables reading of all layers. New layers will be created
        when required.

        This method has been added in version 0.25 and replaces the respective global option in
        \\LoadLayoutOptions in a format-specific fashion.'''

    def cif_set_layer_map(self, ...):
        '''@brief Sets the layer map This sets a layer mapping for the reader. The
        "create_other_layers" specifies whether to create layers that are not in the mapping and
        automatically assign layers to them. @param map The layer map to set.@param
        create_other_layers The flag telling whether other layer should be created also. Set to
        false if just the layers in the mapping table should be read.

        This method has been added in version 0.25 and replaces the respective global option in
        \\LoadLayoutOptions in a format-specific fashion.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def dxf_select_all_layers(self, ...):
        '''@brief Selects all layers and disables the layer map

        This disables any layer map and enables reading of all layers. New layers will be created
        when required.

        This method has been added in version 0.25 and replaces the respective global option in
        \\LoadLayoutOptions in a format-specific fashion.'''

    def dxf_set_layer_map(self, ...):
        '''@brief Sets the layer map This sets a layer mapping for the reader. The
        "create_other_layers" specifies whether to create layers that are not in the mapping and
        automatically assign layers to them. @param map The layer map to set.@param
        create_other_layers The flag telling whether other layer should be created also. Set to
        false if just the layers in the mapping table should be read.

        This method has been added in version 0.25 and replaces the respective global option in
        \\LoadLayoutOptions in a format-specific fashion.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_properties_enabled(self, ...):
        '''@brief Gets a value indicating whether properties shall be read @return True, if
        properties should be read. Starting with version 0.25 this option only applies to GDS2 and
        OASIS format. Other formats provide their own configuration.'''

    def is_text_enabled(self, ...):
        '''@brief Gets a value indicating whether text objects shall be read @return True, if text
        objects should be read. Starting with version 0.25 this option only applies to GDS2 and
        OASIS format. Other formats provide their own configuration.'''

    def select_all_layers(self, ...):
        '''@brief Selects all layers and disables the layer map

        This disables any layer map and enables reading of all layers. New layers will be created
        when required.

        Starting with version 0.25 this method only applies to GDS2 and OASIS format. Other formats
        provide their own configuration.'''

    def set_layer_map(self, ...):
        '''@brief Sets the layer map This sets a layer mapping for the reader. The
        "create_other_layers" specifies whether to create layers that are not in the mapping and
        automatically assign layers to them. @param map The layer map to set.@param
        create_other_layers The flag telling whether other layer should be created also. Set to
        false if just the layers in the mapping table should be read.

        Starting with version 0.25 this option only applies to GDS2 and OASIS format. Other formats
        provide their own configuration.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Manager:
    '''@brief A transaction manager class

    Manager objects control layout and potentially other objects in the layout database and allow to
    queue operations to form transactions. A transaction is a sequence of operations that can be
    undone or redone.

    In order to equip a layout object with undo/redo support, instantiate the layout object with a
    manager attached and embrace the operations to undo/redo with transaction/commit calls.

    The use of transactions is subject to certain constraints, i.e. transacted sequences may not be
    mixed with non-transacted ones.

    This class has been introduced in version 0.19. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def commit(self, ...):
        '''@brief Close a transaction.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def has_redo(self, ...):
        '''@brief Determine if a transaction is available for 'redo'

        @return True, if a transaction is available.'''

    def has_undo(self, ...):
        '''@brief Determine if a transaction is available for 'undo'

        @return True, if a transaction is available.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def redo(self, ...):
        '''@brief Redo the next available transaction

        The next transaction is redone with this method. The 'has_redo' method can be used to
        determine wether there are transactions to undo.'''

    def transaction(self, ...):
        '''@brief Begin a joined transaction

        @args description, join_with

        This call will open a new transaction and join if with the previous transaction. The ID of
        the previous transaction must be equal to the ID given with 'join_with'.

        This overload was introduced in version 0.22.

        @param description The description for this transaction (ignored if joined). @param
        description The ID of the previous transaction.

        @return The ID of the new transaction (can be used to join more)'''

    def transaction_for_redo(self, ...):
        '''@brief Return the description of the next transaction for 'redo''''

    def transaction_for_undo(self, ...):
        '''@brief Return the description of the next transaction for 'undo''''

    def undo(self, ...):
        '''@brief Undo the current transaction

        The current transaction is undone with this method. The 'has_undo' method can be used to
        determine wether there are transactions to undo.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Matrix2d:
    '''@brief A 2d matrix object used mainly for representing rotation and shear transformations.

    This object represents a 2x2 matrix. This matrix is used to represent affine transformations in
    the 2d space mainly. It can be decomposed into basic transformations: mirroring, rotation and
    shear. In that case, the assumed execution order of the basic transformations is mirroring at
    the x axis, rotation, magnification and shear.

    This class was introduced in version 0.22. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __add__(self, ...):
        '''@brief Sum of two matrices. @args m @param m The other matrix. @return The (element-wise)
        sum of self+m'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Create a new Matrix2d from the four coefficients @args m11, m12, m21, m22'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __mul__(self, ...):
        '''@brief Product of two matrices. @args m @param m The other matrix. @return The matrix
        product self*m'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert the matrix to a string. @return The string representing this matrix'''

    def __rmul__(self, ...):
        '''@brief Product of two matrices. @args m @param m The other matrix. @return The matrix
        product self*m'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert the matrix to a string. @return The string representing this matrix'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def angle(self, ...):
        '''@brief Returns the rotation angle of the rotation component of this matrix. @return The
        angle in degree. The matrix is decomposed into basic transformations assuming an execution
        order of mirroring at the x axis, rotation, magnification and shear.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def cplx_trans(self, ...):
        '''@brief Converts this matrix to a complex transformation (if possible). @return The
        complex transformation. This method is successful only if the matrix does not contain shear
        components and the magnification must be isotropic.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def inverted(self, ...):
        '''@brief The inverse of this matrix. @return The inverse of this matrix'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mirror(self, ...):
        '''@brief Returns the mirror flag of this matrix. @return True if this matrix has a mirror
        component. The matrix is decomposed into basic transformations assuming an execution order
        of mirroring at the x axis, rotation, magnification and shear.'''

    def m(self, ...):
        '''@brief Gets the m coefficient with the given index. @args i,j @return The coefficient
        [i,j]'''

    def m11(self, ...):
        '''@brief Gets the m11 coefficient. @return The value of the m11 coefficient'''

    def m12(self, ...):
        '''@brief Gets the m12 coefficient. @return The value of the m12 coefficient'''

    def m21(self, ...):
        '''@brief Gets the m21 coefficient. @return The value of the m21 coefficient'''

    def m22(self, ...):
        '''@brief Gets the m22 coefficient. @return The value of the m22 coefficient'''

    def mag_x(self, ...):
        '''@brief Returns the x magnification of the magnification component of this matrix. @return
        The magnification factor. The matrix is decomposed into basic transformations assuming an
        execution order of mirroring at the x axis, magnification, shear and rotation.'''

    def mag_y(self, ...):
        '''@brief Returns the y magnification of the magnification component of this matrix. @return
        The magnification factor. The matrix is decomposed into basic transformations assuming an
        execution order of mirroring at the x axis, magnification, shear and rotation.'''

    def shear_angle(self, ...):
        '''@brief Returns the magnitude of the shear component of this matrix. @return The shear
        angle in degree. The matrix is decomposed into basic transformations assuming an execution
        order of mirroring at the x axis, rotation, magnification and shear. The shear basic
        transformation will tilt the x axis towards the y axis and vice versa. The shear angle gives
        the tilt angle of the axes towards the other one. The possible range for this angle is -45
        to 45 degree.'''

    def to_s(self, ...):
        '''@brief Convert the matrix to a string. @return The string representing this matrix'''

    def trans(self, ...):
        '''@brief Transforms a point with this matrix. @args p @param p The point to transform.
        @return The product if self and the point p'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Create a new Matrix2d from the four coefficients @args m11, m12, m21, m22'''

    @classmethod
    def newc(cls, ...):
        '''@brief Create a new Matrix2d representing a shear, anisotropic magnification, rotation
        and mirroring @args shear, mx, my, rotation, mirror @param shear The shear angle @param mx
        The magnification in x direction @param my The magnification in y direction @param rotation
        The rotation angle (in degree) @param mirror The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, shear and rotation. This
        constructor is called 'newc' to distinguish it from the constructor taking the four matrix
        coefficients ('c' is for composite).'''


class Matrix3d:
    '''@brief A 3d matrix object used mainly for representing rotation, shear, displacement and
    perspective transformations.

    This object represents a 3x3 matrix. This matrix is used to represent geometrical
    transformations in the 2d space mainly. It can be decomposed into basic transformations:
    mirroring, rotation, shear, displacement and perspective distortion. In that case, the assumed
    execution order of the basic transformations is mirroring at the x axis, rotation,
    magnification, shear, displacement and perspective distortion.

    This class was introduced in version 0.22. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __add__(self, ...):
        '''@brief Sum of two matrices. @args m @param m The other matrix. @return The (element-wise)
        sum of self+m'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Create a new Matrix3d from the nine matrix coefficients @args m11, m12, m13, m21,
        m22, m23, m31, m32, m33'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __mul__(self, ...):
        '''@brief Transform a point. @args p @param p The point to transform. @return The
        transformed point'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert the matrix to a string. @return The string representing this matrix'''

    def __rmul__(self, ...):
        '''@brief Transform a point. @args p @param p The point to transform. @return The
        transformed point'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert the matrix to a string. @return The string representing this matrix'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def adjust(self, ...):
        '''@brief Adjust a 3d matrix to match the given set of landmarks

        This function tries to adjust the matrix such, that either the matrix is changed as little
        as possible (if few landmarks are given)  or that the "after" landmarks will match as close
        as possible to the "before" landmarks  (if the problem is overdetermined).

        @args landmarks_before, landmarks_after, flags, fixed_point @param landmarks_before The
        points before the transformation. @param landmarks_after The points after the
        transformation. @param mode Selects the adjustment mode. Must be one of the Adjust...
        constants. @param fixed_point The index of the fixed point (one that is definitly mapped to
        the target) or -1 if there is none'''

    def angle(self, ...):
        '''@brief Returns the rotation angle of the rotation component of this matrix. @return The
        angle in degree. See the description of this class for details about the basic
        transformations.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def cplx_trans(self, ...):
        '''@brief Converts this matrix to a complex transformation (if possible). @return The
        complex transformation. This method is successful only if the matrix does not contain shear
        or perspective distortion components and the magnification must be isotropic.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def disp(self, ...):
        '''@brief Returns the displacement vector of this transformation.

        Starting with version 0.25 this method returns a vector type instead of a point. @return The
        displacement vector.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def inverted(self, ...):
        '''@brief The inverse of this matrix. @return The inverse of this matrix'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mirror(self, ...):
        '''@brief Returns the mirror flag of this matrix. @return True if this matrix has a mirror
        component. See the description of this class for details about the basic transformations.'''

    def m(self, ...):
        '''@brief Gets the m coefficient with the given index. @args i,j @return The coefficient
        [i,j]'''

    def mag_x(self, ...):
        '''@brief Returns the x magnification of the magnification component of this matrix. @return
        The magnification factor.'''

    def mag_y(self, ...):
        '''@brief Returns the y magnification of the magnification component of this matrix. @return
        The magnification factor.'''

    def shear_angle(self, ...):
        '''@brief Returns the magnitude of the shear component of this matrix. @return The shear
        angle in degree. The shear basic transformation will tilt the x axis towards the y axis and
        vice versa. The shear angle gives the tilt angle of the axes towards the other one. The
        possible range for this angle is -45 to 45 degree.See the description of this class for
        details about the basic transformations.'''

    def to_s(self, ...):
        '''@brief Convert the matrix to a string. @return The string representing this matrix'''

    def trans(self, ...):
        '''@brief Transforms a point with this matrix. @args p @param p The point to transform.
        @return The product if self and the point p'''

    def tx(self, ...):
        '''@brief Returns the perspective tilt angle tx. @args z @param z The observer distance at
        which the tilt angle is computed. @return The tilt angle tx. The tx and ty parameters
        represent the perspective distortion. They denote a tilt of the xy plane around the y axis
        (tx) or the x axis (ty) in degree. The same effect is achieved for different tilt angles at
        different observer distances. Hence, the observer distance must be specified at which the
        tilt angle is computed. If the magnitude of the tilt angle is not important, z can be set to
        1.'''

    def ty(self, ...):
        '''@brief Returns the perspective tilt angle ty. @args z @param z The observer distance at
        which the tilt angle is computed. @return The tilt angle ty. The tx and ty parameters
        represent the perspective distortion. They denote a tilt of the xy plane around the y axis
        (tx) or the x axis (ty) in degree. The same effect is achieved for different tilt angles at
        different observer distances. Hence, the observer distance must be specified at which the
        tilt angle is computed. If the magnitude of the tilt angle is not important, z can be set to
        1.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Create a new Matrix3d from the nine matrix coefficients @args m11, m12, m13, m21,
        m22, m23, m31, m32, m33'''

    @classmethod
    def newc(cls, ...):
        '''@brief Create a new Matrix3d representing a perspective distortion, displacement, shear,
        anisotropic magnification, rotation and mirroring @args tx, ty, z, u, shear, mx, my,
        rotation, mirrx @param tx The perspective tilt angle x (around the y axis) @param ty The
        perspective tilt angle y (around the x axis) @param z The observer distance at which the
        tilt angles are given @param u The displacement @param shear The shear angle @param mx The
        magnification in x direction @param mx The magnification in y direction @param rotation The
        rotation angle (in degree) @param mirrx The mirror flag (at x axis)

        The order of execution of the operations is mirror, magnification, rotation, shear,
        perspective distortion and displacement. This constructor is called 'newc' to distinguish it
        from the constructor taking the four matrix coefficients ('c' is for composite).

        The tx and ty parameters represent the perspective distortion. They denote a tilt of the xy
        plane around the y axis (tx) or the x axis (ty) in degree. The same effect is achieved for
        different tilt angles for different observer distances. Hence, the observer distance must be
        given at which the tilt angles are given. If the magnitude of the tilt angle is not
        important, z can be set to 1.

        Starting with version 0.25 the displacement is of vector type.'''


class NetElement:
    '''@brief A net element for the NetTracer net tracing facility

    This object represents a piece of a net extracted by the net tracer. See the description of
    \\NetTracer for more details about the net tracer feature.

    The NetTracer object represents one shape of the net. The shape can be an original shape or a
    shape derived in a boolean operation. In the first case, the shape refers to a shape within a
    cell or a subcell of the original top cell. In the latter case, the shape is a synthesized one
    and outside the original layout hierarchy.

    In any case, the \\shape method will deliver the shape and \\trans the transformation of the
    shape into the original top cell. To obtain a flat representation of the net, the shapes need to
    be transformed by this transformation.

    \\layer will give the layer the shape is located at, \\cell_index will denote the cell that
    containes the shape.

    This class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Delivers the bounding box of the shape as seen from the original top cell'''

    def cell_index(self, ...):
        '''@brief Gets the index of the cell the shape is inside'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def layer(self, ...):
        '''@brief Gets the index of the layer the shape is on'''

    def shape(self, ...):
        '''@brief Gets the shape that makes up this net element See the class description for more
        details about this attribute.'''

    def trans(self, ...):
        '''@brief Gets the transformation to apply for rendering the shape in the original top cell
        See the class description for more details about this attribute.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class NetTracer:
    '''@brief The net tracer feature

    The net tracer class provides an interface to the net tracer feature. It is accompanied by the
    \\NetElement and \\NetTracerTechnology classes. The latter will provide the technology
    definition for the net tracer while the \\NetElement objects represent a piece of the net after
    it has been extracted.

    The technology definition is optional. The net tracer can be used with a predefined technology
    as well. The basic scheme of using the net tracer is to instantiate a net tracer object and run
    the extraction through the \\NetTracer#trace method. After this method was executed
    successfully, the resulting net can be obtained from the net tracer object by iterating over the
    \\NetElement objects of the net tracer.

    Here is some sample code:

    @code ly = RBA::CellView::active.layout

    tracer = RBA::NetTracer::new

    tech = RBA::NetTracerTechnology::new tech.connection("1/0", "2/0", "3/0")

    tracer.trace(tech, ly, ly.top_cell, RBA::Point::new(7000, 1500), ly.find_layer(1, 0))

    tracer.each_element do |e|   puts e.shape.polygon.transformed(e.trans) end @/code

    This class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def clear(self, ...):
        '''@brief Clears the data from the last extraction'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_element(self, ...):
        '''@brief Iterates over the elements found during extraction The elements are available only
        after the extraction has been performed.'''

    def incomplete(self, ...):
        '''@brief Returns a value indicating whether the net is incomplete A net may be incomplete
        if the extraction has been stopped by the user for example. This attribute is useful only
        after the extraction has been performed.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def name(self, ...):
        '''@brief Returns the name of the net found during extraction The net name is extracted from
        labels found during the extraction. This attribute is useful only after the extraction has
        been performed.'''

    def num_elements(self, ...):
        '''@brief Returns the number of elements found during extraction This attribute is useful
        only after the extraction has been performed.'''

    def trace(self, ...):
        '''@brief Runs a path extraction taking a predefined technology This method behaves
        identical as the version with a technology object, except that it will look for a technology
        with the given name to obtain the extraction setup.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class NetTracerTechnology:
    '''@brief A technology description for the net tracer

    This object represents the technology description for the net tracer (represented by the
    \\NetTracer class). A technology description basically consists of connection declarations. A
    connection is given by either two or three expressions describing two conductive materials. With
    two expressions, the connection describes a transition from one material to another one. With
    three expressions, the connection describes a transition from one material to another through a
    connection (a "via").

    The conductive material is derived from original layers either directly or through boolean
    expressions. These expressions can include symbols which are defined through the \\symbol
    method.

    For details about the expressions see the description of the net tracer feature.

    This class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def connection(self, ...):
        '''@brief Defines a connection between materials through a via See the class description for
        details about this method.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def description(self, ...):
        '''@brief Gets the human-readable description string of the technology component'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def name(self, ...):
        '''@brief Gets the formal name of the technology component This is the name by which the
        component can be obtained from a technology using \\Technology#component.'''

    def symbol(self, ...):
        '''@brief Defines a symbol for use in the material expressions. Defines a sub-expression to
        be used in further symbols or material expressions. For the detailed notation of the
        expression see the description of the net tracer feature.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class PCellDeclaration:
    '''@brief A PCell declaration providing the parameters and code to produce the PCell

    A PCell declaration is basically the recipe of how to create a PCell layout from a parameter
    set. The declaration includes

    @ul @li Parameters: names, types, default values @/li @li Layers: the layers the PCell wants to
    create @/li @li Code: a production callback that is called whenever a PCell is instantiated with
    a certain parameter set @/li @li Display name: the name that is shown for a given PCell instance
    @/li @/ul

    All these declarations are implemented by deriving from the PCellDeclaration class and
    reimplementing the specific methods. Reimplementing the \\display_name method is  optional. The
    default implementation creates a name from the PCell name plus the  parameters.

    By supplying the information about the layers it wants to create, KLayout is able to call the
    production callback with a defined set of the layer ID's which are already mapped to valid
    actual layout layers.

    This class has been introduced in version 0.22. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def can_create_from_shape(self, ...):
        '''@hide'''

    def coerce_parameters(self, ...):
        pass

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def display_text(self, ...):
        '''@hide'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def get_layers(self, ...):
        pass

    def get_parameters(self, ...):
        '''@hide'''

    def id(self, ...):
        '''@brief Gets the integer ID of the PCell declaration This ID is used to identify the PCell
        in the context of a Layout object for example'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def name(self, ...):
        '''@brief Gets the name of the PCell'''

    def parameters_from_shape(self, ...):
        '''@hide'''

    def produce(self, ...):
        '''@hide'''

    def transformation_from_shape(self, ...):
        '''@hide'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class PCellDeclarationHelper:
    '''A helper class that somewhat simplifies the implementation of a PCell '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def id(self, ...):
        '''@brief Gets the integer ID of the PCell declaration This ID is used to identify the PCell
        in the context of a Layout object for example'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def name(self, ...):
        '''@brief Gets the name of the PCell'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class PCellDeclaration_Native:
    '''@hide @alias PCellDeclaration '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def can_create_from_shape(self, ...):
        pass

    def coerce_parameters(self, ...):
        pass

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def display_text(self, ...):
        pass

    def get_layers(self, ...):
        pass

    def get_parameters(self, ...):
        pass

    def id(self, ...):
        '''@brief Gets the integer ID of the PCell declaration This ID is used to identify the PCell
        in the context of a Layout object for example'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def name(self, ...):
        '''@brief Gets the name of the PCell'''

    def parameters_from_shape(self, ...):
        pass

    def produce(self, ...):
        pass

    def transformation_from_shape(self, ...):
        pass

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class PCellParameterDeclaration:
    '''@brief A PCell parameter declaration

    This class declares a PCell parameter by providing a name, the type and a value  and additional
    information like description, unit string and default value. It is used in the
    \\PCellDeclaration class to  deliver the necessary information.

    This class has been introduced in version 0.22. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the default value

     @brief Sets the default value @args value If a default value is defined, it will be used to
    initialize the parameter value when a PCell is created.'''
    default = None

    '''@brief Gets the description text

     @brief Sets the description @args description'''
    description = None

    '''@brief Returns true, if the parameter is a hidden parameter that should not be shown in the
    user interface By making a parameter hidden, it is possible to create internal parameters which
    cannot be edited.

     @brief Makes the parameter hidden if this attribute is set to true @args flag'''
    hidden = None

    '''@brief Gets the name

     @brief Sets the name @args value'''
    name = None

    '''@brief Returns true, if the parameter is a read-only parameter By making a parameter read-
    only, it is shown but cannot be edited.

     @brief Makes the parameter read-only if this attribute is set to true @args flag'''
    readonly = None

    '''@brief Gets the type The type is one of the T... constants.

    @brief Sets the type @args type'''
    type = None

    '''@brief Gets the unit string

     @brief Sets the unit string The unit string is shown right to the edit fields for numeric
    parameters. @args unit'''
    unit = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Create a new parameter declaration with the given name, type, default value and
        unit string @args name, type, description, default @param name The parameter name @param
        type One of the Type... constants describing the type of the parameter @param description
        The description text @param default The default (initial) value @param unit The unit
        string'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def add_choice(self, ...):
        '''@brief Add a new value to the list of choices @args description, value This method will
        add the given value with the given description to the list of choices. If choices are
        defined, KLayout will show a drop-down box instead of an entry field in the parameter user
        interface.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def choice_descriptions(self, ...):
        '''@brief Returns a list of choice descriptions'''

    def choice_values(self, ...):
        '''@brief Returns a list of choice values'''

    def clear_choices(self, ...):
        '''@brief Clears the list of choices'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Create a new parameter declaration with the given name, type, default value and
        unit string @args name, type, description, default @param name The parameter name @param
        type One of the Type... constants describing the type of the parameter @param description
        The description text @param default The default (initial) value @param unit The unit
        string'''


class ParentInstArray:
    '''@brief A parent instance

    A parent instance is basically an inverse instance: instead of pointing to the child cell, it is
    pointing to the parent cell and the transformation is representing the shift of the parent cell
    relative to the child cell. For memory performance, a parent instance is not stored as a
    instance but rather as a reference to a child instance and a reference to the cell which is the
    parent. The parent instance itself is computed on the fly. It is representative for a set of
    instances belonging to the same cell index. The special parent instance iterator takes care of
    producing the right sequence (\\Cell#each_parent_inst).

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def child_inst(self, ...):
        '''@brief Retrieve the child instance associated with this parent instance

        Starting with version 0.15, this method returns an \\Instance object rather than a
        \\CellInstArray reference.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def inst(self, ...):
        '''@brief Compute the inverse instance by which the parent is seen from the child'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def parent_cell_index(self, ...):
        '''@brief Gets the index of the parent cell'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Path:
    '''@brief A path class

    A path consists of an sequence of line segments forming the 'spine' of the path and a width. In
    addition, the starting point can be drawn back by a certain extent (the 'begin extension') and
    the end point can be pulled forward somewhat (by the 'end extension').

    A path may have round ends for special purposes. In particular, a round-ended path with a single
    point can represent a circle. Round-ended paths should have being and end extensions equal to
    half the width. Non-round-ended paths with a single point are allowed but the definition of the
    resulting shape in not well defined and may differ in other tools.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Get the begin extension

     @brief Set the begin extension @args ext'''
    bgn_ext = None

    '''@brief Get the end extension

     @brief Set the end extension @args ext'''
    end_ext = None

    '''@brief Get the number of points

    @brief Set the points of the path @args p @param p An array of points to assign to the path's
    spine'''
    points = None

    '''@brief Set the 'round ends' flag @args round_ends_flag A path with round ends show half
    circles at the ends, instead of square or rectangular ends. Paths with this flag set should use
    a begin and end extension of half the width (see \\bgn_ext and \\end_ext). The interpretation of
    such paths in other tools may differ otherwise.'''
    round = None

    '''@brief Get the width

     @brief Set the width @args w'''
    width = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test @args p @param p The object to compare against'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor given the points of the path's spine, the width, the extensions and
        the round end flag

        @args pts, width, bgn_ext, end_ext, round

        @param pts The points forming the spine of the path @param width The width of the path
        @param bgn_ext The begin extension of the path @param end_ext The end extension of the path
        @param round If this flag is true, the path will get rounded ends'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args p @param p The object to compare against This operator is
        provided to establish some, not necessarily a certain sorting order'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test @args p @param p The object to compare against'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert to a string'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief Returns the approximate area of the path This method returns the approximate value
        of the area. It is computed from the length times the width. end extensions are taken into
        account correctly, but not effects of the corner interpolation. This method was added in
        version 0.22.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Returns the bounding box of the path'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_point(self, ...):
        '''@brief Get the points that make up the path's spine'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_round(self, ...):
        '''@brief Returns true, if the path has round ends'''

    def length(self, ...):
        '''@brief Returns the length of the path the length of the path is determined by summing the
        lengths of the segments and adding begin and end extensions. For round-ended paths the
        length of the paths between the tips of the ends.

        This method was added in version 0.23.'''

    def move(self, ...):
        '''@brief Moves the path. @args dx, dy

        Moves the path by the given offset and returns the  moved path. The path is overwritten.

        @param dx The x distance to move the path. @param dy The y distance to move the path.

        @return The moved path.

        This version has been added in version 0.23.'''

    def moved(self, ...):
        '''@brief Returns the moved path (does not change self) @args dx, dy

        Moves the path by the given offset and returns the  moved path. The path is not modified.

        @param dx The x distance to move the path. @param dy The y distance to move the path.

        @return The moved path.

        This version has been added in version 0.23.'''

    def num_points(self, ...):
        '''@brief Get the number of points'''

    def perimeter(self, ...):
        '''@brief Returns the approximate perimeter of the path This method returns the approximate
        value of the perimeter. It is computed from the length and the width. end extensions are
        taken into account correctly, but not effects of the corner interpolation. This method was
        added in version 0.24.4.'''

    def polygon(self, ...):
        '''@brief Convert the path to a polygon The returned polygon is not guaranteed to be non-
        self overlapping. This may happen if the path overlaps itself or contains very short
        segments.'''

    def round_corners(self, ...):
        '''@brief Creates a new path whose corners are interpolated with circular bends

        @param radius The radius of the bends @param npoints The number of points (per full circle)
        used for interpolating the bends

        This method has been introduced in version 0.25.'''

    def simple_polygon(self, ...):
        '''@brief Convert the path to a simple polygon The returned polygon is not guaranteed to be
        non-selfoverlapping. This may happen if the path overlaps itself or contains very short
        segments.'''

    def to_dtype(self, ...):
        '''@brief Converts the path to a floating-point coordinate path

        The database unit can be specified to translate the integer-coordinate path into a floating-
        point coordinate path in micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Convert to a string'''

    def transformed(self, ...):
        '''@brief Transform the path. @args t

        Transforms the path with the given complex transformation. Does not modify the path but
        returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path.'''

    def transformed_cplx(self, ...):
        '''@brief Transform the path. @args t

        Transforms the path with the given complex transformation. Does not modify the path but
        returns the transformed path.

        @param t The transformation to apply.

        @return The transformed path.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_dpath(cls, ...):
        '''@brief Creates an integer coordinate path from a floating-point coordinate path

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dpath'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor given the points of the path's spine, the width, the extensions and
        the round end flag

        @args pts, width, bgn_ext, end_ext, round

        @param pts The points forming the spine of the path @param width The width of the path
        @param bgn_ext The begin extension of the path @param end_ext The end extension of the path
        @param round If this flag is true, the path will get rounded ends'''

    @classmethod
    def new_pw(cls, ...):
        '''@brief Constructor given the points of the path's spine and the width

        @args pts, width

        @param pts The points forming the spine of the path @param width The width of the path'''

    @classmethod
    def new_pwx(cls, ...):
        '''@brief Constructor given the points of the path's spine, the width and the extensions

        @args pts, width, bgn_ext, end_ext

        @param pts The points forming the spine of the path @param width The width of the path
        @param bgn_ext The begin extension of the path @param end_ext The end extension of the
        path'''

    @classmethod
    def new_pwxr(cls, ...):
        '''@brief Constructor given the points of the path's spine, the width, the extensions and
        the round end flag

        @args pts, width, bgn_ext, end_ext, round

        @param pts The points forming the spine of the path @param width The width of the path
        @param bgn_ext The begin extension of the path @param end_ext The end extension of the path
        @param round If this flag is true, the path will get rounded ends'''


class Point:
    '''@brief An integer point class Points represent a coordinate in the two-dimensional coordinate
    space of layout. They are not geometrical objects by itself. But they are frequently used in the
    database API for various purposes.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Accessor to the x coordinate

     @brief Write accessor to the x coordinate @args coord'''
    x = None

    '''@brief Accessor to the y coordinate

     @brief Write accessor to the y coordinate @args coord'''
    y = None

    # Methods
    def __add__(self, ...):
        '''@brief Adds a vector to a point

        @args v

        Adds vector v to self by adding the coordinates.

        Starting with version 0.25, this method expects a vector argument.'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test operator

        @args p'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given point. This method
        enables points as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor for a point from two coordinate values

        @args x, y'''

    def __itruediv__(self, ...):
        '''@brief Division by some divisor

        @args d

        Divides the object in place. All coordinates are divided with the given divisor and if
        necessary rounded.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief "less" comparison operator

        @args p

        This operator is provided to establish a sorting order'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test operator

        @args p'''

    def __neg__(self, ...):
        '''@brief Compute the negative of a point

        @args p

        Returns a new point with -x, -y.

        This method has been added in version 0.23.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def __sub__(self, ...):
        '''@brief Subtract one point from another

        @args p

        Subtract point p from self by subtracting the coordinates. This renders a vector.

        Starting with version 0.25, this method renders a vector.'''

    def __truediv__(self, ...):
        '''@brief Division by some divisor

        @args d

        Returns the scaled object. All coordinates are divided with the given divisor and if
        necessary rounded.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def abs(self, ...):
        '''@brief The absolute value of the point (Euclidian distance to 0,0)

        The returned value is 'sqrt(x*x+y*y)'.

        This method has been introduced in version 0.23.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def distance(self, ...):
        '''@brief The Euclidian distance to another point

        @args d

        @param d The other point to compute the distance to.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given point. This method
        enables points as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def sq_abs(self, ...):
        '''@brief The square of the absolute value of the point (Euclidian distance to 0,0)

        The returned value is 'x*x+y*y'.

        This method has been introduced in version 0.23.'''

    def sq_distance(self, ...):
        '''@brief The square Euclidian distance to another point

        @args d

        @param d The other point to compute the distance to.'''

    def to_dtype(self, ...):
        '''@brief Converts the point to a floating-point coordinate point

        The database unit can be specified to translate the integer-coordinate point into a
        floating-point coordinate point in micron units. The database unit is basically a scaling
        factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def to_v(self, ...):
        '''@brief Turns the point into a vector This method returns a vector representing the
        distance from (0,0) to the point.This method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_dpoint(cls, ...):
        '''@brief Creates an integer coordinate point from a floating-point coordinate point

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dpoint'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor for a point from two coordinate values

        @args x, y'''


class Polygon:
    '''@brief A polygon class

    A polygon consists of an outer hull and zero to many holes. Each contour consists of several
    points. The point list is normalized such that the leftmost, lowest point is  the first one. The
    orientation is normalized such that the orientation of the hull contour is clockwise, while the
    orientation of the holes is counterclockwise.

    It is in no way checked that the contours are not overlapping. This must be ensured by the user
    of the object when filling the contours.

    A polygon can be asked for the number of holes using the \\holes method. \\each_point_hull
    delivers the points of the hull contour. \\each_point_hole delivers the points of a specific
    hole. \\each_edge delivers the edges (point-to-point connections) of both hull and holes. \\bbox
    delivers the bounding box, \\area the area and \\perimeter the perimeter of the polygon.

    Here's an example of how to create a polygon:

    @code hull =  [ RBA::Point::new(0, 0),       RBA::Point::new(6000, 0),
    RBA::Point::new(6000, 3000), RBA::Point::new(0, 3000) ] hole1 = [ RBA::Point::new(1000, 1000),
    RBA::Point::new(2000, 1000),            RBA::Point::new(2000, 2000), RBA::Point::new(1000, 2000)
    ] hole2 = [ RBA::Point::new(3000, 1000), RBA::Point::new(4000, 1000),
    RBA::Point::new(4000, 2000), RBA::Point::new(3000, 2000) ] poly = RBA::Polygon::new(hull)
    poly.insert_hole(hole1) poly.insert_hole(hole2)

    # ask the polygon for some properties poly.holes      # -> 2 poly.area       # -> 16000000
    poly.perimeter  # -> 26000 poly.bbox       # -> (0,0;6000,3000) @/code

    The \\Polygon class stores coordinates in integer format. A class that stores floating-point
    coordinates is \\DPolygon.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Set the points of the hull of polygon @args p @param p An array of points to assign to
    the polygon's hull The 'assign_hull' variant is provided in analogy to 'assign_hole'.'''
    hull = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test @args p @param p The object to compare against'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor converting a box to a polygon

        @args box

        @param box The box to convert to a polygon'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args p @param p The object to compare against This operator is
        provided to establish some, not necessarily a certain sorting order'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test @args p @param p The object to compare against'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert to a string'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief The area of the polygon The area is correct only if the polygon is not self-
        overlapping and the polygon is oriented clockwise.Orientation is ensured automatically in
        most cases.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def assign_hole(self, ...):
        '''@brief Set the box as the given hole of the polygon @args n,b @param n The index of the
        hole to which the points should be assigned @param b The box to assign to the polygon's hole
        If the hole index is not valid, this method does nothing. This method was introduced in
        version 0.23.'''

    def assign_hull(self, ...):
        '''@brief Set the points of the hull of polygon @args p @param p An array of points to
        assign to the polygon's hull @param raw If true, the points won't be compressed

        If the 'raw' argument is set to true, the points are taken as they are. Specifically no
        removal of redundant points or joining of coincident edges will take place. In effect,
        polygons consisting of a single point or two points can be constructed as well as polygons
        with duplicate points. Note that such polygons may cause problems in some applications.

        Regardless of raw mode, the point list will be adjusted such that the first point is the
        lowest-leftmost one and the orientation is clockwise always.

        The 'assign_hull' variant is provided in analogy to 'assign_hole'.

        The 'raw' argument was added in version 0.24.'''

    def bbox(self, ...):
        '''@brief Return the bounding box of the polygon The bounding box is the box enclosing all
        points of the polygon.'''

    def compress(self, ...):
        '''@brief Compress the polygon. @args remove_reflected

        This method removes redundant points from the polygon, such as points being on a line formed
        by two other points. If remove_reflected is true, points are also removed if the two
        adjacent edges form a spike.

        @param remove_reflected See description of the functionality.

        This method was introduced in version 0.18.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def decompose_convex(self, ...):
        '''@brief Decomposes the polygon into convex pieces

        This method returns a decomposition of the polygon that contains convex pieces only. If the
        polygon was convex already, the list returned has a single element which is the original
        polygon.

        @param preferred_orientation One of the PO_... constants

        This method was introduced in version 0.25.'''

    def decompose_trapezoids(self, ...):
        '''@brief Decomposes the polygon into trapezoids

        This method returns a decomposition of the polygon into trapezoid pieces. It supports
        different modes for various applications. See the TD_... constants for details.

        @param mode One of the TD_... constants

        This method was introduced in version 0.25.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_edge(self, ...):
        '''@brief Iterate over the edges of one contour of the polygon

        @args contour @param contour The contour number (0 for hull, 1 for first hole ...)

        This iterator will deliver all edges of the contour specified by the contour parameter. The
        hull has contour number 0, the first hole has contour 1 etc. Hole edges are oriented
        counterclockwise while hull egdes are oriented clockwise.

        This method was introduced in version 0.24.'''

    def each_point_hole(self, ...):
        '''@brief Iterate over the points that make up the nth hole @args n The hole number must be
        less than the number of holes (see \\holes)'''

    def each_point_hull(self, ...):
        '''@brief Iterate over the points that make up the hull'''

    def extract_rad(self, ...):
        '''@brief Extracts the corner radii from a rounded polygon

        Attempts to extract the radii of rounded corner polygon. This is essentially the inverse of
        the \\round_corners method. If this method succeeds, if will return an array of four
        elements: @ul @li The polygon with the rounded corners replaced by edgy ones @/li @li The
        radius of the inner corners @/li @li The radius of the outer corners @/li @li The number of
        points per full circle @/li @/ul

        This method is based on some assumptions and may fail. In this case, an empty array is
        returned.

        If successful, the following code will more or less render the original polygon and
        parameters

        @code p = ...   # some polygon p.round_corners(ri, ro, n) (p2, ri2, ro2, n2) = p.extract_rad
        # -> p2 == p, ro2 == ro, ri2 == ri, n2 == n (within some limits) @/code

        This method was introduced in version 0.25.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def holes(self, ...):
        '''@brief Returns the number of holes'''

    def insert_hole(self, ...):
        '''@brief Insert a hole from the given box @args b @param b The box to insert as a new hole
        This method was introduced in version 0.23.'''

    def inside(self, ...):
        '''@brief Test, if the given point is inside the polygon @args p If the given point is
        inside or on the edge of the polygon, true is returned. This tests works well only if the
        polygon is not self-overlapping and oriented clockwise. '''

    def is_box(self, ...):
        '''@brief Returns true, if the polygon is a simple box.

        A polygon is a box if it is identical to it's bounding box.

        @return True if the polygon is a box.

        This method was introduced in version 0.23.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_convex(self, ...):
        '''@brief Returns a value indicating whether the polygon is convex

        This method will return true, if the polygon is convex.

        This method was introduced in version 0.25.'''

    def minkowsky_sum(self, ...):
        '''@brief Computes the Minkowsky sum of the polygon and a contour of points (a trace) @args
        b, resolve_holes

        @param b The contour (a series of points forming the trace). @param resolve_holes If true,
        the output polygon will not contain holes, but holes are resolved by joining the holes with
        the hull.

        @return The new polygon representing the Minkowsky sum of self and the contour.

        This method was introduced in version 0.22.'''

    def move(self, ...):
        '''@brief Moves the polygon. @args x,y

        Moves the polygon by the given offset and returns the  moved polygon. The polygon is
        overwritten.

        @param x The x distance to move the polygon. @param y The y distance to move the polygon.

        @return The moved polygon (self).'''

    def moved(self, ...):
        '''@brief Returns the moved polygon (does not modify self) @args x,y

        Moves the polygon by the given offset and returns the  moved polygon. The polygon is not
        modified.

        @param x The x distance to move the polygon. @param y The y distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.'''

    def num_points(self, ...):
        '''@brief Get the total number of points (hull plus holes) This method was introduced in
        version 0.18.'''

    def num_points_hole(self, ...):
        '''@brief Get the number of points of the given hole @args n The argument gives the index of
        the hole of which the number of points are requested. The index must be less than the number
        of holes (see \\holes). '''

    def num_points_hull(self, ...):
        '''@brief Get the number of points of the hull'''

    def perimeter(self, ...):
        '''@brief The perimeter of the polygon The perimeter is sum of the lengths of all edges
        making up the polygon.

        This method has been introduce in version 0.23.'''

    def point_hole(self, ...):
        '''@brief Get a specific point of a hole @args n,p @param n The index of the hole to which
        the points should be assigned @param p The index of the point to get If the index of the
        point or of the hole is not valid, a default value is returned. This method was introduced
        in version 0.18.'''

    def point_hull(self, ...):
        '''@brief Get a specific point of the hull @args p @param p The index of the point to get If
        the index of the point is not a valid index, a default value is returned. This method was
        introduced in version 0.18.'''

    def resolve_holes(self, ...):
        '''@brief Resolve holes by inserting cut lines and joining the holes with the hull

        This method modifies the polygon. The out-of-place version is \\resolved_holes. This method
        was introduced in version 0.22.'''

    def resolved_holes(self, ...):
        '''@brief Returns a polygon without holes

        @return The new polygon without holes.

        This method does not modify the polygon but return a new polygon. This method was introduced
        in version 0.22.'''

    def round_corners(self, ...):
        '''@brief Rounds the corners of the polygon @args rinner, router, n

        Replaces the corners of the polygon with circle segments.

        @param rinner The circle radius of inner corners (in database units). @param router The
        circle radius of outer corners (in database units). @param n The number of points per full
        circle.

        @return The new polygon.

        This method was introduced in version 0.20 for integer coordinates and in 0.25 for all
        coordinate types.'''

    def size(self, ...):
        '''@brief Sizing (biasing) @args d

        Shifts the contour outwards (d>0) or inwards (d<0). This method is equivalent to @code
        size(d, d, 2) @/code

        See \\size for a detailed description.'''

    def sized(self, ...):
        '''@brief Sizing (biasing) @args d

        @brief Sizing (biasing) without modifying self This method is equivalent to @code sized(d,
        d, 2) @/code

        See \\size and \\sized for a detailed description.'''

    def smooth(self, ...):
        '''@brief Smoothes a polygon @args d

        Remove vertices that deviate by more than the distance d from the average contour. The value
        d is basically the roughness which is removed.

        @param d The smoothing "roughness".

        @return The smoothed polygon.

        This method was introduced in version 0.23.'''

    def split(self, ...):
        '''@brief Splits the polygon into two or more parts This method will break the polygon into
        parts. The exact breaking algorithm is unspecified, the result are smaller polygons of
        roughly equal number of points and 'less concave' nature. Usually the returned polygon set
        consists of two polygons, but there can be more. The merged region of the resulting polygons
        equals the original polygon with the exception of small snapping effects at new vertexes.

        The intended use for this method is a iteratively split polygons until the satisfy some
        maximum number of points limit.

        This method has been introduced in version 0.25.3.'''

    def to_dtype(self, ...):
        '''@brief Converts the polygon to a floating-point coordinate polygon

        The database unit can be specified to translate the integer-coordinate polygon into a
        floating-point coordinate polygon in micron units. The database unit is basically a scaling
        factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Convert to a string'''

    def to_simple_polygon(self, ...):
        '''@brief Converts a polygon to a simple polygon

        @return The simple polygon.

        If the polygon contains holes, these will be resolved. This operation requires a well-formed
        polygon. Reflecting edges, self-intersections and coincident points will be removed.

        This method was introduced in version 0.22.'''

    def touches(self, ...):
        '''@brief Returns true, if the polygon touches the other polygon. The polygons touch if they
        overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.'''

    def transform(self, ...):
        '''@brief Transforms the polygon (in-place) @args t

        Transforms the polygon with the given transformation. Modifies self and returns self. An
        out-of-place version which does not modify self is \\transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.'''

    def transformed(self, ...):
        '''@brief Transforms the polygon with a complex transformation @args t

        Transforms the polygon with the given complex transformation. Does not modify the polygon
        but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed'
        takes both simple and complex transformations.'''

    def transformed_cplx(self, ...):
        '''@brief Transforms the polygon with a complex transformation @args t

        Transforms the polygon with the given complex transformation. Does not modify the polygon
        but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed'
        takes both simple and complex transformations.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def ellipse(cls, ...):
        '''@brief Creates a simple polygon appoximating an ellipse

        @args box, n

        @param box The bounding box of the ellipse @param n The number of points that will be used
        to approximate the ellipse

        This method has been introduced in version 0.23.'''

    @classmethod
    def from_dpoly(cls, ...):
        '''@brief Creates an integer coordinate polygon from a floating-point coordinate polygon

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dpolygon'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor converting a box to a polygon

        @args box

        @param box The box to convert to a polygon'''


class RecursiveShapeIterator:
    '''@brief An iterator delivering shapes that touch or overlap the given region recursively

    The iterator can be obtained from a layout, specifying a starting cell, a layer and optionally a
    region. It simplifies retrieval of shapes from a geometrical region while considering subcells
    as well. Some options can be specified, i.e. the level to which to look into or shape classes
    and shape properties. The shapes are retrieved by using the \\shape method, \\next moves to the
    next shape and \\at_end tells, if the iterator has move shapes to deliver.

    This is some sample code:

    @code # print the polygon-like objects as seen from the initial cell "cell" iter =
    layout.begin_shapes(cell_index, layer) while !iter.at_end?   if iter.shape.renders_polygon?
    polygon = iter.shape.polygon.transformed(iter.itrans)     puts "In cell #{iter.cell.name}: " +
    polyon.to_s   end   iter.next end @/code

    \\Layout offers three methods to get these iterators: begin_shapes, begin_shapes_touching and
    begin_shapes_overlapping. \\Layout#begin_shapes will deliver a standard recursive shape iterator
    which starts from the given cell and iterates over all child cells.
    \\Layout#begin_shapes_touching delivers a RecursiveShapeIterator which delivers the shapes whose
    bounding boxed touch the given search box. \\Layout#begin_shapes_overlapping delivers all shapes
    whose bounding box overlaps the search box.

    A RecursiveShapeIterator object can also be created explicitly. This allows some more options,
    i.e. using multiple layers. A multi-layer recursive shape iterator can be created like this:

    @code iter = RBA::RecursiveShapeIterator::new(layout, cell, [ layer_index1, layer_index2 .. ])
    @/code

    "layout" is the layout object, "cell" the RBA::Cell object of the initial cell. layer_index1
    etc. are the layer indexes of the layers to get the shapes from. While iterating,
    \\RecursiveShapeIterator#layer delivers the layer index of the current shape.

    The recursive shape iterator can be confined to a maximum hierarchy depth. By using
    \\max_depth=, the iterator will restrict the search depth to the given depth in the cell tree.

    In addition, the recursive shape iterator supports selection and exclusion of subtrees. For that
    purpose it keeps flags per cell telling it for which cells to turn shape delivery on and off.
    The \\select_cells method sets the "start delivery" flag while \\unselect_cells sets the "stop
    delivery" flag. In effect, using \\unselect_cells will exclude that cell plus the subtree from
    delivery. Parts of that subtree can be turned on again using \\select_cells. For the cells
    selected that way, the shapes of these cells and their child cells are delivered, even if their
    parents was unselected.

    To get shapes from a specific cell, i.e. "MACRO" plus its child cells, unselect the top cell
    first and the select the desired cell again:

    @code # deliver all shapes inside "MACRO" and the sub-hierarchy: iter =
    RBA::RecursiveShapeIterator::new(layout, cell, layer) iter.unselect_cells(cell.cell_index)
    iter.select_cells("MACRO") @/code

    Note that if "MACRO" uses library cells for example which are used otherwise as well, the
    iterator will only deliver the shapes for those instances belonging to "MACRO" (directly or
    indirectly), not those for other instances of these library cells.

    The \\unselect_all_cells and \\select_all_cells methods turn on the "stop" and "start" flag for
    all cells respectively. If you use \\unselect_all_cells and use \\select_cells for a specific
    cell, the iterator will deliver only the shapes of the selected cell, not its children. Those
    are still unselected by \\unselect_all_cells:

    @code # deliver all shapes of "MACRO" but not of child cells: iter =
    RBA::RecursiveShapeIterator::new(layout, cell, layer) iter.unselect_all_cells
    iter.select_cells("MACRO") @/code

    Cell selection is done using cell indexes or glob pattern. Glob pattern are equivalent to the
    usual file name wildcards used on various command line shells. For example "A*" matches all
    cells starting with an "A". The curly brace notation and character classes are supported as
    well. For example "C{125,512}" matches "C125" and "C512" and "[ABC]*" matches all cells starting
    with an "A", a "B" or "C". "[^ABC]*" matches all cells not starting with one of that letters.

    The RecursiveShapeIterator class has been introduced in version 0.18 and has been extended
    substantially in 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the maximum hierarchy depth

    See \\max_depth= for a description of that attribute.

    This method has been introduced in version 0.23.

     @brief Specify the maximum hierarchy depth to look into @args depth

    A depth of 0 instructs the iterator to deliver only shapes from the initial cell. The depth must
    be specified before the shapes are being retrieved. Setting the depth resets the iterator.'''
    max_depth = None

    '''@brief Gets a flag indicating whether overlapping shapes are selected when a region is used

    This method has been introduced in version 0.23.

     @brief Sets a flag indicating whether overlapping shapes are selected when a region is used
    @args region

    If this flag is false, shapes touching the search region are returned.

    This method has been introduced in version 0.23.'''
    overlapping = None

    '''@brief Gets the basic region that is iterator is using The basic region is the overall box
    the region iterator iterates over. There may be an additional complex region that confines the
    region iterator. See \\complex_region for this attribute.

    This method has been introduced in version 0.23.

     @brief Sets the rectangular region that is iterator is iterating over @args box_region See
    \\region for a description of this attribute. Setting a simple region will reset the complex
    region to a rectangle and reset the iterator to the beginning of the sequence. This method has
    been introduced in version 0.23.

     @brief Sets the complex region that is iterator is using @args complex_region See
    \\complex_region for a description of this attribute. Setting the complex region will reset the
    basic region (see \\region) to the bounding box of the complex region and reset the iterator to
    the beginning of the sequence.

    This method overload has been introduced in version 0.25.'''
    region = None

    '''@brief Specifies the shape selection flags @args flags

    The flags are the same then being defined in \\Shapes (the default is RBA::Shapes::SAll). The
    flags must be specified before the shapes are being retrieved. Settings the shapes flags will
    reset the iterator.'''
    shape_flags = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Comparison of iterators - equality @args other

        Two iterators are equal if they point to the same shape.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a recursive, multi-layer shape iterator with a region. @args layout, cell,
        layers, region, overlapping @param layout The layout which shall be iterated @param cell The
        initial cell which shall be iterated (including it's children) @param layers The layer
        indexes from which the shapes are taken @param region The search region @param overlapping
        If set to true, shapes overlapping the search region are reported, otherwise touching is
        sufficient

        This constructor creates a new recursive shape iterator which delivers the shapes of the
        given cell plus it's children from the layers given by the layer indexes in the "layers"
        parameter. While iterating use the \\layer method to retrieve the layer of the current
        shape.

        The search is confined to the region given by the "region" parameter. The region needs to be
        a rectilinear region. If "overlapping" is true, shapes whose bounding box is overlapping the
        search region are reported. If "overlapping" is false, shapes whose bounding box touches the
        search region are reported.

        This constructor has been introduced in version 0.23.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''@brief Comparison of iterators - inequality @args other

        Two iterators are not equal if they do not point to the same shape.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def at_end(self, ...):
        '''@brief End of iterator predicate

        Returns true, if the iterator is at the end of the sequence'''

    def cell(self, ...):
        '''@brief Gets the current cell's object

        This method has been introduced in version 0.23.'''

    def cell_index(self, ...):
        '''@brief Gets the current cell's index '''

    def complex_region(self, ...):
        '''@brief Gets the complex region that is iterator is using The complex region is the
        effective region (a \\Region object) that the iterator is selecting from the layout layers.
        This region can be a single box or a complex region.

        This method has been introduced in version 0.25.'''

    def confine_region(self, ...):
        '''@brief Confines the region that is iterator is iterating over @args complex_region This
        method is similar to setting the region (see \\region=), but will confine any region
        (complex or simple) already set. Essentially it does a logical AND operation between the
        existing and given region. Hence this method can only reduce a region, not extend it.

        This method has been introduced in version 0.25.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dtrans(self, ...):
        '''@brief Gets the transformation into the initial cell applicable for floating point types

        This transformation corresponds to the one deliverd by \\trans, but is applicable for the
        floating-point shape types in micron unit space.

        This method has been introduced in version 0.25.3.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def itrans(self, ...):
        '''@brief Gets the current transformation by which the shapes must be transformed into the
        initial cell

        The shapes delivered are not transformed. Instead, this transformation must be applied to
        get the shape in the coordinate system of the top cell.

        Starting with version 0.25, this transformation is a int-to-int transformation the 'itrans'
        method which was providing this transformation before is deprecated.'''

    def layer(self, ...):
        '''@brief Returns the layer index where the current shape is coming from.

        This method has been introduced in version 0.23.'''

    def layout(self, ...):
        '''@brief Gets the layout this iterator is connected to

        This method has been introduced in version 0.23.'''

    def next(self, ...):
        '''@brief Increment the iterator This moves the iterator to the next shape inside the search
        scope.'''

    def path(self, ...):
        '''@brief Gets the instantatiation path of the shape addressed currently

        This attribute is a sequence of \\InstElement objects describing the cell instance path from
        the initial cell to the current cell containing the current shape.

        This method has been introduced in version 0.25.'''

    def reset(self, ...):
        '''@brief Resets the iterator to the initial state

        This method has been introduced in version 0.23.'''

    def reset_selection(self, ...):
        '''@brief Resets the selection to the default state

        In the initial state, the top cell and it's children are selected. Child cells can be
        switched on and off together with their sub-hierarchy using \\select_cells and
        \\unselect_cells.

        This method will also reset the iterator.

        This method has been introduced in version 0.23.'''

    def select_all_cells(self, ...):
        '''@brief Selects all cells.

        This method will set the "selected" mark on all cells. The effect is that subsequent calls
        of \\unselect_cells will unselect only the specified cells, not their children, because they
        are still unselected.

        This method will also reset the iterator.

        This method has been introduced in version 0.23.'''

    def select_cells(self, ...):
        '''@brief Unselects the given cells. @args cells

        This method will sets the "selected" mark on the given cells. That means that these cells or
        their child cells are visited, unless they are marked as "unselected" again with the
        \\unselect_cells method.

        The cells are given as a glob pattern. A glob pattern follows the syntax of file names on
        the shell (i.e. "A*" are all cells starting with a letter "A").

        This method will also reset the iterator.

        This method has been introduced in version 0.23.'''

    def shape(self, ...):
        '''@brief Gets the current shape

        Returns the shape currently referred to by the recursive iterator.  This shape is not
        transformed yet and is located in the current cell.'''

    def top_cell(self, ...):
        '''@brief Gets the top cell this iterator is connected to

        This method has been introduced in version 0.23.'''

    def trans(self, ...):
        '''@brief Gets the current transformation by which the shapes must be transformed into the
        initial cell

        The shapes delivered are not transformed. Instead, this transformation must be applied to
        get the shape in the coordinate system of the top cell.

        Starting with version 0.25, this transformation is a int-to-int transformation the 'itrans'
        method which was providing this transformation before is deprecated.'''

    def unselect_all_cells(self, ...):
        '''@brief Unselects all cells.

        This method will set the "unselected" mark on all cells. The effect is that subsequent calls
        of \\select_cells will select only the specified cells, not their children, because they are
        still unselected.

        This method will also reset the iterator.

        This method has been introduced in version 0.23.'''

    def unselect_cells(self, ...):
        '''@brief Unselects the given cells. @args cells

        This method will sets the "unselected" mark on the given cells. That means that these cells
        or their child cells will not be visited, unless they are marked as "selected" again with
        the \\select_cells method.

        The cells are given as a glob pattern. A glob pattern follows the syntax of file names on
        the shell (i.e. "A*" are all cells starting with a letter "A").

        This method will also reset the iterator.

        This method has been introduced in version 0.23.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a recursive, multi-layer shape iterator with a region. @args layout, cell,
        layers, region, overlapping @param layout The layout which shall be iterated @param cell The
        initial cell which shall be iterated (including it's children) @param layers The layer
        indexes from which the shapes are taken @param region The search region @param overlapping
        If set to true, shapes overlapping the search region are reported, otherwise touching is
        sufficient

        This constructor creates a new recursive shape iterator which delivers the shapes of the
        given cell plus it's children from the layers given by the layer indexes in the "layers"
        parameter. While iterating use the \\layer method to retrieve the layer of the current
        shape.

        The search is confined to the region given by the "region" parameter. The region needs to be
        a rectilinear region. If "overlapping" is true, shapes whose bounding box is overlapping the
        search region are reported. If "overlapping" is false, shapes whose bounding box touches the
        search region are reported.

        This constructor has been introduced in version 0.23.'''


class Region:
    '''@brief A region (a potentially complex area consisting of multiple polygons)

     This class was introduced to simplify operations on polygon sets like boolean or sizing
    operations. Regions consist of many polygons and thus are a generalisation of single polygons
    which describes a single coherence set of points. Regions support a variety of operations and
    have several states.

    The region's state can be empty (does not contain anything) or box-like, i.e. the region
    consists of a single box. In that case, some operations can be simplified. Regions can have
    merged state. In merged state, regions consist of merged (non-touching, non-self overlapping)
    polygons. Each polygon describes one coherent area in merged state.

    The preferred representation of polygons inside the region are polygons with holes.

    Regions are always expressed in database units. If you want to use regions from different
    database unit domains, scale the regions accordingly, i.e. by using the \\transformed method.

     Regions provide convenient operators for the boolean operations. Hence it is often no longer
    required to work with the \\EdgeProcessor class. For example:

    @code r1 = RBA::Region::new(RBA::Box::new(0, 0, 100, 100)) r2 =
    RBA::Region::new(RBA::Box::new(20, 20, 80, 80)) # compute the XOR: r1_xor_r2 = r1 ^ r2 @/code

    Regions can be used in two different flavors: in raw mode or merged semantics. With merged
    semantics (the default), connected polygons are considered to belong together and are
    effectively merged. Overlapping areas are counted once in that mode. Internal edges (i.e.
    arising from cut lines) are not considered. In raw mode (without merged semantics), each polygon
    is considered as it is. Overlaps between polygons may exists and merging has to be done
    explicitly using the \\merge method. The semantics can be selected using \\merged_semantics=.

     This class has been introduced in version 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets a flag indicating whether merged semantics is enabled See \\merged_semantics= for
    a description of this attribute.

     @brief Enables or disables merged semantics @args f If merged semantics is enabled (the
    default), coherent polygons will be considered as single regions and artificial edges such as
    cut-lines will not be considered. Merged semantics thus is equivalent to considering coherent
    areas rather than single polygons'''
    merged_semantics = None

    '''@brief Gets a flag indicating whether minimum coherence is selected See \\min_coherence= for
    a description of this attribute.

     @brief Enable or disable minimum coherence @args f If minimum coherence is set, the merge
    operations (explicit merge with \\merge or implicit merge through merged_semantics) are
    performed using minimum coherence mode. The coherence mode determines how kissing-corner
    situations are resolved. If minimum coherence is selected, they are resolved such that multiple
    polygons are  created which touch at a corner).

    The default setting is maximum coherence (min_coherence = false).'''
    min_coherence = None

    '''@brief Gets a flag indicating whether merged semantics is enabled See \\strict_handling= for
    a description of this attribute.

    This method has been introduced in version 0.23.2.

    @brief Enables or disables strict handling @args f

    Strict handling means to leave away some optimizations. Specifically the  output of boolean
    operations will be merged even if one input is empty. Without strict handling, the operation
    will be optimized and output  won't be merged.

    Strict handling is disabled by default and optimization is in place.

    This method has been introduced in version 0.23.2.'''
    strict_handling = None

    # Methods
    def __add__(self, ...):
        '''@brief Returns the combined region of self and the other region

        @args other @return The resulting region

        This operator adds the polygons of the other region to self and returns a new combined
        region. This usually creates unmerged regions and polygons may overlap. Use \\merge if you
        want to ensure the result region is merged.'''

    def __and__(self, ...):
        '''@brief Returns the boolean AND between self and the other region

        @args other @return The result of the boolean AND operation

        This method will compute the boolean AND (intersection) between two regions. The result is
        often but not necessarily always merged.'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __getitem__(self, ...):
        '''@brief Returns the nth polygon of the region @args n

        This method returns nil if the index is out of range. This returns the raw polygon (not
        merged polygons if merged semantics is enabled).

        Using this method may be costly in terms of memory since it will load the polygons into an
        array if they have been stored in an hierarchical layout before. It is recommended to use
        the \\each iterator instead if possible.'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __iadd__(self, ...):
        '''@brief Adds the polygons of the other region to self

        @args other @return The region after modification (self)

        This operator adds the polygons of the other region to self. This usually creates unmerged
        regions and polygons may overlap. Use \\merge if you want to ensure the result region is
        merged.'''

    def __iand__(self, ...):
        '''@brief Performs the boolean AND between self and the other region

        @args other @return The region after modification (self)

        This method will compute the boolean AND (intersection) between two regions. The result is
        often but not necessarily always merged.'''

    def __init__(self, ...):
        '''@brief Constructor from a text set

        @param shape_iterator The iterator from which to derive the texts @param expr The selection
        string @param as_pattern If true, the selection string is treated as a glob pattern.
        Otherwise the match is exact.

        This special constructor will create a region from the text objects delivered by the shape
        iterator. Each text object will deliver a small (non-empty) box that represents the text
        origin. Texts can be selected by their strings - either through a glob pattern or by exact
        comparison with the given string. The following options are available:

        @code region = RBA::Region::new(iter, "*")           # all texts region =
        RBA::Region::new(iter, "A*")          # all texts starting with an 'A' region =
        RBA::Region::new(iter, "A*", false)   # all texts exactly matchin 'A*' @/code

        This method has been introduced in version 0.25.'''

    def __ior__(self, ...):
        '''@brief Performs the boolean OR between self and the other region

        @args other @return The region after modification (self)

        The boolean OR is implemented by merging the polygons of both regions. To simply join the
        regions without merging, the + operator is more efficient.'''

    def __isub__(self, ...):
        '''@brief Performs the boolean NOT between self and the other region

        @args other @return The region after modification (self)

        This method will compute the boolean NOT (intersection) between two regions. The result is
        often but not necessarily always merged.'''

    def __iter__(self, ...):
        '''@brief Returns each polygon of the region

        This returns the raw polygons (not merged polygons if merged semantics is enabled).'''

    def __ixor__(self, ...):
        '''@brief Performs the boolean XOR between self and the other region

        @args other @return The region after modification (self)

        This method will compute the boolean XOR (intersection) between two regions. The result is
        often but not necessarily always merged.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __or__(self, ...):
        '''@brief Returns the boolean OR between self and the other region

        @args other @return The resulting region

        The boolean OR is implemented by merging the polygons of both regions. To simply join the
        regions without merging, the + operator is more efficient.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Converts the region to a string @args max_count This version allows specification
        of the maximum number of polygons contained in the string.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Converts the region to a string @args max_count This version allows specification
        of the maximum number of polygons contained in the string.'''

    def __sub__(self, ...):
        '''@brief Returns the boolean NOT between self and the other region

        @args other @return The result of the boolean NOT operation

        This method will compute the boolean NOT (intersection) between two regions. The result is
        often but not necessarily always merged.'''

    def __xor__(self, ...):
        '''@brief Returns the boolean NOT between self and the other region

        @args other @return The result of the boolean XOR operation

        This method will compute the boolean XOR (intersection) between two regions. The result is
        often but not necessarily always merged.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief The area of the region (restricted to a rectangle) @args rect This version will
        compute the area of the shapes, restricting the computation to the given rectangle.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics) If
        merged semantics is not enabled, overlapping areas are counted twice.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Return the bounding box of the region The bounding box is the box enclosing all
        points of all polygons.'''

    def clear(self, ...):
        '''@brief Clears the region'''

    def corners(self, ...):
        '''@brief This method will select all corners whose attached edges satisfy the angle
        condition.

        The angle values specify a range of angles: all corners whose attached edges form an angle
        between angle_start and angle_end will be reported as small (2x2 DBU) boxes. The angle is
        measured between the incoming and the outcoming edge in mathematical sense: a positive value
        is a turn left while a negative value is a turn right. Since polygon contours are oriented
        clockwise, positive angles will report concave corners while negative ones report convex
        ones.

        A similar function that reports corners as point-like edges is \\corners_dots.

        This function has been introduced in version 0.25.'''

    def corners_dots(self, ...):
        '''@brief This method will select all corners whose attached edges satisfy the angle
        condition.

        This method is similar to \\corners, but delivers an \\Edges collection with dot-like edges
        for each corner.

        This function has been introduced in version 0.25.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def decompose_convex(self, ...):
        '''@brief Decomposes the region into convex pieces.

        This method will return a \\Shapes container that holds a decomposition of the region into
        convex, simple polygons. See \\Polygon#decompose_convex for details. If you want \\Region
        output, you should use \\decompose_convex_to_region.

        This method has been introduced in version 0.25.'''

    def decompose_convex_to_region(self, ...):
        '''@brief Decomposes the region into convex pieces into a region.

        This method is identical to \\decompose_convex, but delivers a \\Region object.

        This method has been introduced in version 0.25.'''

    def decompose_trapezoids(self, ...):
        '''@brief Decomposes the region into trapezoids.

        This method will return a \\Shapes container that holds a decomposition of the region into
        trapezoids. See \\Polygon#decompose_trapezoids for details. If you want \\Region output, you
        should use \\decompose_trapezoids_to_region.

        This method has been introduced in version 0.25.'''

    def decompose_trapezoids_to_region(self, ...):
        '''@brief Decomposes the region into trapezoids.

        This method is identical to \\decompose_trapezoids, but delivers a \\Region object.

        This method has been introduced in version 0.25.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def disable_progress(self, ...):
        '''@brief Disable progress reporting Calling this method will disable progress reporting.
        See \\enable_progress.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each(self, ...):
        '''@brief Returns each polygon of the region

        This returns the raw polygons (not merged polygons if merged semantics is enabled).'''

    def each_merged(self, ...):
        '''@brief Returns each merged polygon of the region

        This returns the raw polygons if merged semantics is disabled or the merged ones if merged
        semantics is enabled.'''

    def edges(self, ...):
        '''@brief Returns an edge collection representing all edges of the polygons in this region
        This method will decompose the polygons into the individual edges. Edges making up the hulls
        of the polygons are oriented clockwise while edges making up the holes are oriented
        counterclockwise.

        The edge collection returned can be manipulated in various ways. See \\Edges for a
        description of the possibilities of the edge collection.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def enable_progress(self, ...):
        '''@brief Enable progress reporting @args label After calling this method, the region will
        report the progress through a progress bar while expensive operations are running. The label
        is a text which is put in front of the progress bar. Using a progress bar will imply a
        performance penalty of a few percent typically.'''

    def enclosing_check(self, ...):
        '''@brief Performs an enclosing check with options @args other, d, whole_edges, metrics,
        ignore_angle, min_projection, max_projection @param d The minimum enclosing distance for
        which the polygons are checked @param other The other region against which to check @param
        whole_edges If true, deliver the whole edges @param metrics Specify the metrics type @param
        ignore_angle The angle above which no check is performed @param min_projection The lower
        threshold of the projected length of one edge onto another @param max_projection The upper
        limit of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or
        above the given value, they will not contribute in the check. Setting this value to 90 (the
        default) will exclude edges with an angle of 90 degree or more from the check. Use nil for
        this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one limit, pass nil to the
        respective value.

        Merged semantics applies for the input of this method (see \\merged_semantics= of merged
        semantics)'''

    def extent_refs(self, ...):
        '''@hide This method is provided for DRC implementation.'''

    def extent_refs_edges(self, ...):
        '''@hide This method is provided for DRC implementation.'''

    def extents(self, ...):
        '''@brief Returns a region with the enlarged bounding boxes of the polygons @args dx, dy
        This method will return a region consisting of the bounding boxes of the polygons enlarged
        by the given distance dx in x direction and dy in y direction. The enlargement is specified
        per edge, i.e the width will be increased by 2*dx. The boxes will not be merged, so it is
        possible to determine overlaps of these boxes for example.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def grid_check(self, ...):
        '''@brief Returns a marker for all vertices not being on the given grid @args gx, gy This
        method will return an edge pair object for every vertex whose x coordinate is not a multiple
        of gx or whose y coordinate is not a multiple of gy. The edge pair objects contain two edges
        consisting of the same single point - the original vertex.

        If gx or gy is 0 or less, the grid is not checked in that direction.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def holes(self, ...):
        '''@brief Returns the holes of the region This method returns all holes as filled polygons.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics) If
        merge semantics is not enabled, the holes may not be detected if the polygons are taken from
        a hole-less representation (i.e. GDS2 file). Use explicit merge (\\merge method) in order to
        merge the polygons and detect holes.'''

    def hulls(self, ...):
        '''@brief Returns the hulls of the region This method returns all hulls as polygons. The
        holes will be removed (filles).  Merged semantics applies for this method (see
        \\merged_semantics= of merged semantics) If merge semantics is not enabled, the hull may
        also enclose holes if the polygons are taken from a hole-less representation (i.e. GDS2
        file). Use explicit merge (\\merge method) in order to merge the polygons and detect
        holes.'''

    def in_(self, ...):
        '''@brief Returns all polygons which are members of the other region @args other This method
        returns all polygons in self which can be found in the other region as well with exactly the
        same geometry.'''

    def insert(self, ...):
        '''@brief Inserts all polygons from the shape collection into this region with complex
        transformation @args shapes This method takes each "polygon-like" shape from the shape
        collection and insertes this shape into the region after applying the given complex
        transformation. Paths and boxes are converted to polygons during this process. Edges and
        text objects are ignored.

        This method has been introduced in version 0.25.'''

    def inside(self, ...):
        '''@brief Returns the polygons of this region which are completely inside polygons from the
        other region

        @args other @return A new region containing the polygons which are inside polygons from the
        other region

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def inside_check(self, ...):
        '''@brief Performs an inside check with options @args other, d, whole_edges, metrics,
        ignore_angle, min_projection, max_projection @param d The minimum distance for which the
        polygons are checked @param other The other region against which to check @param whole_edges
        If true, deliver the whole edges @param metrics Specify the metrics type @param ignore_angle
        The angle above which no check is performed @param min_projection The lower threshold of the
        projected length of one edge onto another @param max_projection The upper limit of the
        projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or
        above the given value, they will not contribute in the check. Setting this value to 90 (the
        default) will exclude edges with an angle of 90 degree or more from the check. Use nil for
        this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one limit, pass nil to the
        respective value.

        Merged semantics applies for the input of this method (see \\merged_semantics= of merged
        semantics)'''

    def interacting(self, ...):
        '''@brief Returns the polygons of this region which overlap or touch edges from the edge
        collection

        @args other @return A new region containing the polygons overlapping or touching edges from
        the edge collection

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)

        This method has been introduced in version 0.25'''

    def is_box(self, ...):
        '''@brief Returns true, if the region is a simple box

        @return True if the region is a box.

        This method does not apply implicit merging if merge semantics is enabled. If the region is
        not merged, this method may return false even if the merged region would be a box.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_empty(self, ...):
        '''@brief Returns true if the region is empty'''

    def is_merged(self, ...):
        '''@brief Returns true if the region is merged If the region is merged, polygons will not
        touch or overlap. You can ensure merged state by calling \\merge.'''

    def isolated_check(self, ...):
        '''@brief Performs a space check between edges of different polygons with options @args d,
        whole_edges, metrics, ignore_angle, min_projection, max_projection @param d The minimum
        space for which the polygons are checked @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type @param ignore_angle The angle above which no check
        is performed @param min_projection The lower threshold of the projected length of one edge
        onto another @param max_projection The upper limit of the projected length of one edge onto
        another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the space check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or
        above the given value, they will not contribute in the check. Setting this value to 90 (the
        default) will exclude edges with an angle of 90 degree or more from the check. Use nil for
        this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one limit, pass nil to the
        respective value.

        Merged semantics applies for the input of this method (see \\merged_semantics= of merged
        semantics)'''

    def members_of(self, ...):
        '''@brief Returns all polygons which are members of the other region @args other This method
        returns all polygons in self which can be found in the other region as well with exactly the
        same geometry.'''

    def merge(self, ...):
        '''@brief Merge the region with options

        @args min_coherence, min_wc @param min_coherence A flag indicating whether the resulting
        polygons shall have minimum coherence @param min_wc Overlap selection @return The region
        after is has been merged (self).

        Merging removes overlaps and joins touching polygons. This version provides two additional
        options: if "min_coherence" is set to true, "kissing corners" are resolved by producing
        separate polygons. "min_wc" controls whether output is only produced if multiple polygons
        overlap. The value specifies the number of polygons that need to overlap. A value of 2 means
        that output is only produced if two or more polygons overlap.'''

    def merged(self, ...):
        '''@brief Returns the merged region (with options)

        @args min_coherence, min_wc @param min_coherence A flag indicating whether the resulting
        polygons shall have minimum coherence @param min_wc Overlap selection @return The region
        after is has been merged (self).

        Merging removes overlaps and joins touching polygons. This version provides two additional
        options: if "min_coherence" is set to true, "kissing corners" are resolved by producing
        separate polygons. "min_wc" controls whether output is only produced if multiple polygons
        overlap. The value specifies the number of polygons that need to overlap. A value of 2 means
        that output is only produced if two or more polygons overlap.

        In contrast to \\merge, this method does not modify the region but returns a merged copy.'''

    def minkowsky_sum(self, ...):
        '''@brief Compute the Minkowsky sum of the region and a contour of points (a trace) @args b

        @param b The contour (a series of points forming the trace).

        @return The new polygons representing the Minkowsky sum of self and the contour.

        The Minkowsky sum of a region and a contour basically results in the area covered when
        "dragging" the region along the contour. The effect is similar to drawing the contour with a
        pencil that has the shape of the given region.

        The resulting polygons are not merged. In order to remove overlaps, use the \\merge or
        \\merged method.Merged semantics applies for the input of this method (see
        \\merged_semantics= of merged semantics)'''

    def move(self, ...):
        '''@brief Moves the region @args x,y

        Moves the region by the given offset and returns the  moved region. The region is
        overwritten.

        @param x The x distance to move the region. @param y The y distance to move the region.

        @return The moved region (self).'''

    def moved(self, ...):
        '''@brief Returns the moved region (does not modify self) @args x,y

        Moves the region by the given offset and returns the  moved region. The region is not
        modified.

        @param x The x distance to move the region. @param y The y distance to move the region.

        @return The moved region.'''

    def non_rectangles(self, ...):
        '''@brief Returns all polygons which are not rectangles This method returns all polygons in
        self which are not rectangles.Merged semantics applies for this method (see
        \\merged_semantics= of merged semantics)'''

    def non_rectilinear(self, ...):
        '''@brief Returns all polygons which are not rectilinear This method returns all polygons in
        self which are not rectilinear.Merged semantics applies for this method (see
        \\merged_semantics= of merged semantics)'''

    def not_in(self, ...):
        '''@brief Returns all polygons which are not members of the other region @args other This
        method returns all polygons in self which can not be found in the other region with exactly
        the same geometry.'''

    def not_inside(self, ...):
        '''@brief Returns the polygons of this region which are not completely inside polygons from
        the other region

        @args other @return A new region containing the polygons which are not inside polygons from
        the other region

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def not_interacting(self, ...):
        '''@brief Returns the polygons of this region which do not overlap or touch edges from the
        edge collection

        @args other @return A new region containing the polygons not overlapping or touching edges
        from the edge collection

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)

        This method has been introduced in version 0.25'''

    def not_members_of(self, ...):
        '''@brief Returns all polygons which are not members of the other region @args other This
        method returns all polygons in self which can not be found in the other region with exactly
        the same geometry.'''

    def not_outside(self, ...):
        '''@brief Returns the polygons of this region which are not completely outside polygons from
        the other region

        @args other @return A new region containing the polygons which are not outside polygons from
        the other region

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def not_overlapping(self, ...):
        '''@brief Returns the polygons of this region which do not overlap polygons from the other
        region

        @args other @return A new region containing the polygons not overlapping polygons from the
        other region

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def notch_check(self, ...):
        '''@brief Performs a space check between edges of the same polygon with options @args d,
        whole_edges, metrics, ignore_angle, min_projection, max_projection @param d The minimum
        space for which the polygons are checked @param whole_edges If true, deliver the whole edges
        @param metrics Specify the metrics type @param ignore_angle The angle above which no check
        is performed @param min_projection The lower threshold of the projected length of one edge
        onto another @param max_projection The upper limit of the projected length of one edge onto
        another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the space check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or
        above the given value, they will not contribute in the check. Setting this value to 90 (the
        default) will exclude edges with an angle of 90 degree or more from the check. Use nil for
        this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one limit, pass nil to the
        respective value.

        Merged semantics applies for the input of this method (see \\merged_semantics= of merged
        semantics)'''

    def outside(self, ...):
        '''@brief Returns the polygons of this region which are completely outside polygons from the
        other region

        @args other @return A new region containing the polygons which are outside polygons from the
        other region

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def overlap_check(self, ...):
        '''@brief Performs an overlap check with options @args other, d, whole_edges, metrics,
        ignore_angle, min_projection, max_projection @param d The minimum overlap for which the
        polygons are checked @param other The other region against which to check @param whole_edges
        If true, deliver the whole edges @param metrics Specify the metrics type @param ignore_angle
        The angle above which no check is performed @param min_projection The lower threshold of the
        projected length of one edge onto another @param max_projection The upper limit of the
        projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or
        above the given value, they will not contribute in the check. Setting this value to 90 (the
        default) will exclude edges with an angle of 90 degree or more from the check. Use nil for
        this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one limit, pass nil to the
        respective value.

        Merged semantics applies for the input of this method (see \\merged_semantics= of merged
        semantics)'''

    def overlapping(self, ...):
        '''@brief Returns the polygons of this region which overlap polygons from the other region

        @args other @return A new region containing the polygons overlapping polygons from the other
        region

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def perimeter(self, ...):
        '''@brief The total perimeter of the polygons (restricted to a rectangle) @args rect This
        version will compute the perimeter of the polygons, restricting the computation to the given
        rectangle. Edges along the border are handled in a special way: they are counted when they
        are oriented with their inside side toward the rectangle (in other words: outside edges must
        coincide with the rectangle's border in order to be counted).

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics) If
        merged semantics is not enabled, internal edges are counted as well.'''

    def rectangles(self, ...):
        '''@brief Returns all polygons which are rectangles This method returns all polygons in self
        which are rectangles.Merged semantics applies for this method (see \\merged_semantics= of
        merged semantics)'''

    def rectilinear(self, ...):
        '''@brief Returns all polygons which are rectilinear This method returns all polygons in
        self which are rectilinear.Merged semantics applies for this method (see \\merged_semantics=
        of merged semantics)'''

    def round_corners(self, ...):
        '''@brief Corner rounding @args r_inner, r_outer, n @param r_inner Inner corner radius (in
        database units) @param r_outer Outer corner radius (in database units) @param n The number
        of points per circle

        This method rounds the corners of the polygons in the region. Inner corners will be rounded
        with a radius of r_inner and outer corners with a radius of r_outer. The circles will be
        approximated by segments using n segments per full circle.

        This method modifies the region. \\rounded_corners is a method that does the same but
        returns a new region without modifying self. Merged semantics applies for this method.'''

    def rounded_corners(self, ...):
        '''@brief Corner rounding @args r_inner, r_outer, n @param r_inner Inner corner radius (in
        database units) @param r_outer Outer corner radius (in database units) @param n The number
        of points per circle

        See \\round_corners for a description of this method. This version returns a new region
        instead of modifying self (out-of-place).'''

    def select_inside(self, ...):
        '''@brief Selects the polygons of this region which are completely inside polygons from the
        other region

        @args other @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def select_interacting(self, ...):
        '''@brief Selects the polygons from this region which overlap or touch edges from the edge
        collection

        @args other @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)

        This method has been introduced in version 0.25'''

    def select_not_inside(self, ...):
        '''@brief Selects the polygons of this region which are not completely inside polygons from
        the other region

        @args other @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def select_not_interacting(self, ...):
        '''@brief Selects the polygons from this region which do not overlap or touch edges from the
        edge collection

        @args other @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)

        This method has been introduced in version 0.25'''

    def select_not_outside(self, ...):
        '''@brief Selects the polygons of this region which are not completely outside polygons from
        the other region

        @args other @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def select_not_overlapping(self, ...):
        '''@brief Selects the polygons from this region which do not overlap polygons from the other
        region

        @args other @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def select_outside(self, ...):
        '''@brief Selects the polygons of this region which are completely outside polygons from the
        other region

        @args other @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def select_overlapping(self, ...):
        '''@brief Selects the polygons from this region which overlap polygons from the other region

        @args other @return The region after the polygons have been selected (self)

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def separation_check(self, ...):
        '''@brief Performs a separation check with options @args other, d, whole_edges, metrics,
        ignore_angle, min_projection, max_projection @param d The minimum separation for which the
        polygons are checked @param other The other region against which to check @param whole_edges
        If true, deliver the whole edges @param metrics Specify the metrics type @param ignore_angle
        The angle above which no check is performed @param min_projection The lower threshold of the
        projected length of one edge onto another @param max_projection The upper limit of the
        projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or
        above the given value, they will not contribute in the check. Setting this value to 90 (the
        default) will exclude edges with an angle of 90 degree or more from the check. Use nil for
        this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one limit, pass nil to the
        respective value.

        Merged semantics applies for the input of this method (see \\merged_semantics= of merged
        semantics)'''

    def size(self, ...):
        '''@brief Returns the number of polygons in the region

        This returns the number of raw polygons (not merged polygons if merged semantics is
        enabled).'''

    def sized(self, ...):
        '''@brief Isotropic sizing (biasing)

        @args d, mode @return The region after the sizing has applied (self)

        This method is equivalent to "sized(d, d, 2)".

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def smooth(self, ...):
        '''@brief Smoothing @args d @param d The smoothing tolerance (in database units)

        This method will simplify the merged polygons of the region by removing vertexes if the
        resulting polygon stays equivalent with the original polygon. Equivalence is measured in
        terms of a deviation which is guaranteed to not become larger than \\d. This method modifies
        the region. \\smoothed is a method that does the same but returns a new region without
        modifying self. Merged semantics applies for this method.'''

    def smoothed(self, ...):
        '''@brief Smoothing @args d @param d The smoothing tolerance (in database units)

        See \\smooth for a description of this method. This version returns a new region instead of
        modifying self (out-of-place). It has been introduced in version 0.25.'''

    def snap(self, ...):
        '''@brief Snaps the region to the given grid @args gx, gy This method will snap the region
        to the given grid - each x or y coordinate is brought on the gx or gy grid by rounding to
        the nearest value which is a multiple of gx or gy.

        If gx or gy is 0 or less, no snapping happens in that direction.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def snapped(self, ...):
        '''@brief Returns the snapped region @args gx, gy This method will snap the region to the
        given grid and return the snapped region (see \\snap). The original region is not
        modified.'''

    def space_check(self, ...):
        '''@brief Performs a space check with options @args d, whole_edges, metrics, ignore_angle,
        min_projection, max_projection @param d The minimum space for which the polygons are checked
        @param whole_edges If true, deliver the whole edges @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed @param min_projection The
        lower threshold of the projected length of one edge onto another @param max_projection The
        upper limit of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the space check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or
        above the given value, they will not contribute in the check. Setting this value to 90 (the
        default) will exclude edges with an angle of 90 degree or more from the check. Use nil for
        this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one limit, pass nil to the
        respective value.

        Merged semantics applies for the input of this method (see \\merged_semantics= of merged
        semantics)'''

    def strange_polygon_check(self, ...):
        '''@brief Returns a region containing those parts of polygons which are "strange" Strange
        parts of polygons are self-overlapping parts or non-orientable parts (i.e. in the "8"
        configuration).

        Merged semantics does not apply for this method (see \\merged_semantics= of merged
        semantics)'''

    def swap(self, ...):
        '''@brief Swap the contents of this region with the contents of another region @args other
        This method is useful to avoid excessive memory allocation in some cases. For managed memory
        languages such as Ruby, those cases will be rare. '''

    def texts(self, ...):
        '''@hide This method is provided for DRC implementation only.'''

    def texts_dots(self, ...):
        '''@hide This method is provided for DRC implementation only.'''

    def to_s(self, ...):
        '''@brief Converts the region to a string @args max_count This version allows specification
        of the maximum number of polygons contained in the string.'''

    def transform(self, ...):
        '''@brief Transform the region with a complex transformation (modifies self) @args t

        Transforms the region with the given transformation. This version modifies the region and
        returns a reference to self.

        @param t The transformation to apply.

        @return The transformed region.'''

    def transform_icplx(self, ...):
        '''@brief Transform the region with a complex transformation (modifies self) @args t

        Transforms the region with the given transformation. This version modifies the region and
        returns a reference to self.

        @param t The transformation to apply.

        @return The transformed region.'''

    def transformed(self, ...):
        '''@brief Transform the region with a complex transformation @args t

        Transforms the region with the given complex transformation. Does not modify the region but
        returns the transformed region.

        @param t The transformation to apply.

        @return The transformed region.'''

    def transformed_icplx(self, ...):
        '''@brief Transform the region with a complex transformation @args t

        Transforms the region with the given complex transformation. Does not modify the region but
        returns the transformed region.

        @param t The transformation to apply.

        @return The transformed region.'''

    def width_check(self, ...):
        '''@brief Performs a width check with options @args d, whole_edges, metrics, ignore_angle,
        min_projection, max_projection @param d The minimum width for which the polygons are checked
        @param whole_edges If true, deliver the whole edges @param metrics Specify the metrics type
        @param ignore_angle The angle above which no check is performed @param min_projection The
        lower threshold of the projected length of one edge onto another @param max_projection The
        upper limit of the projected length of one edge onto another

        This version is similar to the simple version with one parameter. In addition, it allows to
        specify many more options.

        If "whole_edges" is true, the resulting \\EdgePairs collection will receive the whole edges
        which contribute in the width check.

        "metrics" can be one of the constants \\Euclidian, \\Square or \\Projection. See there for a
        description of these constants. Use nil for this value to select the default (Euclidian
        metrics).

        "ignore_angle" specifies the angle limit of two edges. If two edges form an angle equal or
        above the given value, they will not contribute in the check. Setting this value to 90 (the
        default) will exclude edges with an angle of 90 degree or more from the check. Use nil for
        this value to select the default.

        "min_projection" and "max_projection" allow to select edges by their projected value upon
        each other. It is sufficient if the projection of one edge on the other matches the
        specified condition. The projected length must be larger or equal to "min_projection" and
        less than "max_projection". If you don't want to specify one limit, pass nil to the
        respective value.

        Merged semantics applies for the input of this method (see \\merged_semantics= of merged
        semantics)'''

    def with_angle(self, ...):
        '''@brief Returns markers on every corner with an angle of more than amin and less than amax
        (or the opposite) @args amin, amax, inverse If the inverse flag is false, this method
        returns an error marker (an \\EdgePair object) for every corner whose connected edges form
        an angle whose value is more or equal to amin (in degree) or less (but not equal to) amax.
        If the inverse flag is true, the method returns markers for every corner whose angle is not
        matching that criterion.

        The edge pair objects returned will contain both edges forming the angle.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def with_area(self, ...):
        '''@brief Filter the polygons by area @args min_area, max_area, inverse Filters the polygons
        inside the region by area. If "inverse" is false, only polygons which have an area larger or
        equal to "min_area" and less than "max_area" are returned. If "inverse" is true, polygons
        having an area less than "min_area" or larger or equal than "max_area" are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def with_bbox_height(self, ...):
        '''@brief Filter the polygons by bounding box height @args min_height, max_height, inverse
        Filters the polygons inside the region by the height of their bounding box. If "inverse" is
        false, only polygons whose bounding box has a height larger or equal to "min_height" and
        less than "max_height" are returned. If "inverse" is true, all polygons not matching this
        criterion are returned. If you don't want to specify a lower or upper limit, pass nil to
        that parameter.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def with_bbox_max(self, ...):
        '''@brief Filter the polygons by bounding box width or height, whichever is larger @args
        min_dim, max_dim, inverse Filters the polygons inside the region by the minimum dimension of
        their bounding box. If "inverse" is false, only polygons whose bounding box's larger
        dimension is larger or equal to "min_dim" and less than "max_dim" are returned. If "inverse"
        is true, all polygons not matching this criterion are returned. If you don't want to specify
        a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def with_bbox_min(self, ...):
        '''@brief Filter the polygons by bounding box width or height, whichever is smaller @args
        min_dim, max_dim, inverse Filters the polygons inside the region by the minimum dimension of
        their bounding box. If "inverse" is false, only polygons whose bounding box's smaller
        dimension is larger or equal to "min_dim" and less than "max_dim" are returned. If "inverse"
        is true, all polygons not matching this criterion are returned. If you don't want to specify
        a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def with_bbox_width(self, ...):
        '''@brief Filter the polygons by bounding box width @args min_width, max_width, inverse
        Filters the polygons inside the region by the width of their bounding box. If "inverse" is
        false, only polygons whose bounding box has a width larger or equal to "min_width" and less
        than "max_width" are returned. If "inverse" is true, all polygons not matching this
        criterion are returned. If you don't want to specify a lower or upper limit, pass nil to
        that parameter.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    def with_perimeter(self, ...):
        '''@brief Filter the polygons by perimeter @args min_perimeter, max_perimeter, inverse
        Filters the polygons inside the region by perimeter. If "inverse" is false, only polygons
        which have a perimeter larger or equal to "min_perimeter" and less than "max_perimeter" are
        returned. If "inverse" is true, polygons having a perimeter less than "min_perimeter" or
        larger or equal than "max_perimeter" are returned.

        If you don't want to specify a lower or upper limit, pass nil to that parameter.

        Merged semantics applies for this method (see \\merged_semantics= of merged semantics)'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor from a text set

        @param shape_iterator The iterator from which to derive the texts @param expr The selection
        string @param as_pattern If true, the selection string is treated as a glob pattern.
        Otherwise the match is exact.

        This special constructor will create a region from the text objects delivered by the shape
        iterator. Each text object will deliver a small (non-empty) box that represents the text
        origin. Texts can be selected by their strings - either through a glob pattern or by exact
        comparison with the given string. The following options are available:

        @code region = RBA::Region::new(iter, "*")           # all texts region =
        RBA::Region::new(iter, "A*")          # all texts starting with an 'A' region =
        RBA::Region::new(iter, "A*", false)   # all texts exactly matchin 'A*' @/code

        This method has been introduced in version 0.25.'''


class SaveLayoutOptions:
    '''@brief Options for saving layouts

    This class describes the various options for saving a layout to a stream file (GDS2, OASIS and
    others). There are: layers to be saved, cell or cells to be saved, scale factor, format,
    database unit and format specific options.

    Usually the default constructor provides a suitable object. Please note, that the format written
    is "GDS2" by default. Either explicitly set a format using \\format= or derive the format from
    the file name using \\set_format_from_filename.

    The layers are specified by either selecting all layers or by defining layer by layer using the
    \\add_layer method. \\select_all_layers will explicitly select all layers for saving,
    \\deselect_all_layers will explicitly clear the list of layers.

    Cells are selected in a similar fashion: by default, all cells are selected. Using \\add_cell,
    specific cells can be selected for saving. All these cells plus their hierarchy will then be
    written to the stream file. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets a flag indicating whether blanks shall be used as x/y separator characters See
    \\cif_blank_separator= method for a description of that property. This property has been added
    in version 0.23.10.

    The predicate version (cif_blank_separator?) has been added in version 0.25.1.

     @brief Gets a flag indicating whether blanks shall be used as x/y separator characters See
    \\cif_blank_separator= method for a description of that property. This property has been added
    in version 0.23.10.

    The predicate version (cif_blank_separator?) has been added in version 0.25.1.

     @brief Sets a flag indicating whether blanks shall be used as x/y separator characters If this
    property is set to true, the x and y coordinates are separated with blank characters rather than
    comma characters. This property has been added in version 0.23.10.'''
    cif_blank_separator = None

    '''@brief Gets a flag indicating whether dummy calls shall be written See \\cif_dummy_calls=
    method for a description of that property. This property has been added in version 0.23.10.

    The predicate version (cif_blank_separator?) has been added in version 0.25.1.

     @brief Gets a flag indicating whether dummy calls shall be written See \\cif_dummy_calls=
    method for a description of that property. This property has been added in version 0.23.10.

    The predicate version (cif_blank_separator?) has been added in version 0.25.1.

     @brief Sets a flag indicating whether dummy calls shall be written If this property is set to
    true, dummy calls will be written in the top level entity of the CIF file calling every top
    cell. This option is useful for enhanced compatibility with other tools.

    This property has been added in version 0.23.10.'''
    cif_dummy_calls = None

    '''@brief Get the explicit database unit if one is set

    See \\dbu= for a description of that attribute.

     @brief Set the database unit to be used in the stream file @args dbu

    By default, the database unit of the layout is used. This method allows to explicitly use a
    different database unit. A scale factor is introduced automatically which scales all layout
    objects accordingly so their physical dimensions remain the same. When scaling to a larger
    database unit or one that is not an integer fraction of the original one, rounding errors may
    occur and the layout may become slightly distorted.'''
    dbu = None

    '''@brief Specifies how to write polygons. See \\dxf_polygon_mode= for a description of this
    property.

    This property has been added in version 0.21.3.

     @brief Specifies how to write polygons. @args mode The mode is 0 (write POLYLINE entities), 1
    (write LWPOLYLINE entities), 2 (decompose into SOLID entities), 3 (write HATCH entities), or 4
    (write LINE entities).

    This property has been added in version 0.21.3. '4', in version 0.25.6.'''
    dxf_polygon_mode = None

    '''@brief Gets the format name

    See \\format= for a description of that method.

     @brief Select a format @args format The format string can be either "GDS2", "OASIS", "CIF" or
    "DXF". Other formats may be available if a suitable plugin is installed.'''
    format = None

    '''@brief Get the library name See \\gds2_libname= method for a description of the library name.
    This property has been added in version 0.18.

     @brief Set the library name @args libname

    The library name is the string written into the LIBNAME records of the GDS file. The library
    name should not be an empty string and is subject to certain limitations in the character
    choice.

    This property has been added in version 0.18.'''
    gds2_libname = None

    '''@brief Get the maximum length of cell names See \\gds2_max_cellname_length= method for a
    description of the maximum cell name length. This property has been added in version 0.18.

     @brief Maximum length of cell names @args length

    This property describes the maximum number of characters for cell names.  Longer cell names will
    be shortened.

    This property has been added in version 0.18.'''
    gds2_max_cellname_length = None

    '''@brief Get the maximum number of vertices for polygons to write See \\gds2_max_vertex_count=
    method for a description of the maximum vertex count. This property has been added in version
    0.18.

     @brief Set the maximum number of vertices for polygons to write @args count This property
    describes the maximum number of point for polygons in GDS2 files. Polygons with more points will
    be split. The minimum value for this property is 4. The maximum allowed value is about 4000 or
    8000, depending on the GDS2 interpretation. If \\gds2_multi_xy_records is true, this property is
    not used. Instead, the number of points is unlimited.

    This property has been added in version 0.18.'''
    gds2_max_vertex_count = None

    '''@brief Get the property enabling multiple XY records for BOUNDARY elements See
    \\gds2_multi_xy_records= method for a description of this property. This property has been added
    in version 0.18.

     @brief Use multiple XY records in BOUNDARY elements for unlimited large polygons @args flag

    Setting this property to true allows to produce unlimited polygons  at the cost of incompatible
    formats. Setting it to true disables the \\gds2_max_vertex_count setting.

    This property has been added in version 0.18.'''
    gds2_multi_xy_records = None

    '''@brief Gets a value indicating whether zero-length paths are eliminated

    This property has been added in version 0.23.

     @brief Gets a value indicating whether zero-length paths are eliminated

    This property has been added in version 0.23.

     @brief Eliminates zero-length paths if true @args flag

    If this property is set to true, paths with zero length will be converted to BOUNDARY objects.

     This property has been added in version 0.23.'''
    gds2_no_zero_length_paths = None

    '''@brief Get the user units See \\gds2_user_units= method for a description of the user units.
    This property has been added in version 0.18.

     @brief Set the users units to write into the GDS file @args uu

    The user units of a GDS file are rarely used and usually are set to 1 (micron). The intention of
    the user units is to specify the display units. KLayout ignores the user unit and uses microns
    as the display unit. The user unit must be larger than zero.

    This property has been added in version 0.18.'''
    gds2_user_units = None

    '''@brief Gets a value indicating whether cell properties are written

    This property has been added in version 0.23.

     @brief Gets a value indicating whether cell properties are written

    This property has been added in version 0.23.

     @brief Enables writing of cell properties if set to true @args flag

    If this property is set to true, cell properties will be written as PROPATTR/PROPVALUE records
    immediately following the BGNSTR records. This is a non-standard extension and is therefore
    disabled by default.

     This property has been added in version 0.23.'''
    gds2_write_cell_properties = None

    '''@brief Gets a value indicating whether layout properties are written

    This property has been added in version 0.24.

     @brief Gets a value indicating whether layout properties are written

    This property has been added in version 0.24.

     @brief Enables writing of file properties if set to true @args flag

    If this property is set to true, layout properties will be written as PROPATTR/PROPVALUE records
    immediately following the BGNLIB records. This is a non-standard extension and is therefore
    disabled by default.

     This property has been added in version 0.24.'''
    gds2_write_file_properties = None

    '''@brief Gets a value indicating whether the current time is written into the GDS2 timestamp
    fields

    This property has been added in version 0.21.16.

     @brief Write the current time into the GDS2 timestamps if set to true @args flag

    If this property is set to false, the time fields will all be zero. This somewhat simplifies
    compare and diff applications.

     This property has been added in version 0.21.16.'''
    gds2_write_timestamps = None

    '''@brief Gets a flag indicating whether instances will be kept even if the target cell is
    dropped

    See \\keep_instances= for details about this flag.

    This method was introduced in version 0.23.

     @brief Enables or disables instances for dropped cells @args flag

    If this flag is set to true, instances for cells will be written, even if the cell is dropped.
    That may happen, if cells are selected with \\select_this_cell or \\add_this_cell or
    \\no_empty_cells is used. Even if cells called by such cells are not selected, instances will be
    written for that cell if "keep_instances" is true. That feature is supported by the GDS format
    currently and results in "ghost cells" which have instances but no cell definition.

    The default value is false (instances of dropped cells are not written).

    This method was introduced in version 0.23.'''
    keep_instances = None

    '''@brief Returns a flag indicating whether empty cells are not written.

     @brief Don't write empty cells if this flag is set @args flag

    By default, all cells are written (no_empty_cells is false). This applies to empty cells which
    do not contain shapes for the specified layers as well as cells which are empty because they
    reference empty cells only.'''
    no_empty_cells = None

    '''@brief Get the OASIS compression level See \\oasis_compression_level= method for a
    description of the OASIS compression level.

    @brief Set the OASIS compression level @args level The OASIS compression level is an integer
    number between 0 and 10. 0 basically is no compression, 1 produces shape arrays in a simple
    fashion. 2 and higher compression levels will use a more elaborate algorithm to find shape
    arrays which uses 2nd and futher neighbor distances. The higher the level, the higher the memory
    requirements and run times.'''
    oasis_compression_level = None

    '''@brief Gets the OASIS permissive mode See \\oasis_permissive= method for a description of
    this predicate. This method has been introduced in version 0.25.1.

    @brief Sets OASIS permissive mode @args flag If this flag is true, certain shapes which cannot
    be written to OASIS are reported as warnings, not as errors. For example, paths with odd width
    (are rounded) or polygons with less than three points (are skipped).

    This method has been introduced in version 0.25.1.'''
    oasis_permissive = None

    '''@brief Gets the OASIS recompression mode See \\oasis_recompress= method for a description of
    this predicate. This method has been introduced in version 0.23.

    @brief Sets OASIS recompression mode @args flag If this flag is true, shape arrays already
    existing will be resolved and compression is applied to the individual shapes again. If this
    flag is false (the default), shape arrays already existing will be written as such.

    This method has been introduced in version 0.23.'''
    oasis_recompress = None

    '''@brief Gets a value indicating whether to write strict-mode OASIS files

     @brief Sets a value indicating whether to write strict-mode OASIS files @args flag Setting this
    property clears all format specific options for other formats such as GDS.'''
    oasis_strict_mode = None

    '''@brief Gets the substitution character

    See \\oasis_substitution_char for details. This attribute has been introduced in version 0.23.

     @brief Sets the substitution character for a-strings and n-strings @args char The substitution
    character is used in place of invalid characters. The value of this attribute is a string which
    is either empty or a single character. If the string is empty, no substitution is made at the
    risk of producing invalid OASIS files.

    This attribute has been introduce in version 0.23.'''
    oasis_substitution_char = None

    '''@brief Gets a value indicating whether to write compressed CBLOCKS per cell

     @brief Sets a value indicating whether to write compressed CBLOCKS per cell @args flag Setting
    this property clears all format specific options for other formats such as GDS.'''
    oasis_write_cblocks = None

    '''@brief Gets a value indicating whether cell bounding boxes are written See
    \\oasis_write_cell_bounding_boxes= method for a description of this flag. This method has been
    introduced in version 0.24.3.

    @brief Sets a value indicating whether cell bounding boxes are written @args flag If this value
    is set to true, cell bounding boxes are written (S_BOUNDING_BOX). The S_BOUNDING_BOX properties
    will be attached to the CELLNAME records.

    Setting this value to true will also enable writing of other standard properties like S_TOP_CELL
    (see \\oasis_write_std_properties=). By default, cell bounding boxes are not written, but
    standard properties are.

    This method has been introduced in version 0.24.3.'''
    oasis_write_cell_bounding_boxes = None

    '''@brief Gets a value indicating whether standard properties will be written See
    \\oasis_write_std_properties= method for a description of this flag. This method has been
    introduced in version 0.24.

    @brief Sets a value indicating whether standard properties will be written @args flag If this
    value is false, no standard properties are written. If true, S_TOP_CELL and some other global
    standard properties are written. In addition, \\oasis_write_cell_bounding_boxes= can be used to
    write cell bounding boxes using S_BOUNDING_BOX.

    By default, this flag is true and standard properties are written.

    Setting this property to false clears the oasis_write_cell_bounding_boxes flag too.

    This method has been introduced in version 0.24.'''
    oasis_write_std_properties = None

    '''@hide

    @hide'''
    oasis_write_std_properties_ext = None

    '''@brief Gets the scaling factor currently set

     @brief Set the scaling factor for the saving  @args scale_factor

    Using a scaling factor will scale all objects accordingly. This scale factor adds to a potential
    scaling implied by using an explicit database unit.

    Be aware that rounding effects may occur if fractional scaling factors are used.

    By default, no scaling is applied.'''
    scale_factor = None

    '''@brief Gets a flag indicating whether context information will be stored

    See \\write_context_info= for details about this flag.

    This method was introduced in version 0.23.

     @brief Enables or disables context information @args flag

    If this flag is set to false, no context information for PCell or library cell instances is
    written. Those cells will be converted to plain cells and KLayout will not be able to restore
    the identity of those cells. Use this option to enforce compatibility with other tools that
    don't understand the context information of KLayout.

    The default value is true (context information is stored). Not all formats support context
    information, hence that flag has no effect for formats like CIF or DXF.

    This method was introduced in version 0.23.'''
    write_context_info = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Default constructor

        This will initialize the scale factor to 1.0, the database unit is set to "same as original"
        and all layers are selected as well as all cells. The default format is GDS2.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def add_cell(self, ...):
        '''@brief Add a cell (plus hierarchy) to be saved

        @args cell_index

        The index of the cell must be a valid index in the context of the layout that will be saved.
        This method clears the 'select all cells' flag.

        This method also implicitly adds the children of that cell. A method that does not add the
        children in \\add_this_cell.'''

    def add_layer(self, ...):
        '''@brief Add a layer to be saved

        @args layer_index, properties

        Adds the layer with the given index to the layer list that will be written. If all layers
        have been selected previously, all layers will  be unselected first and only the new layer
        remains.

        The 'properties' argument can be used to assign different layer properties than the ones
        present in the layout. Pass a default \\LayerInfo object to this argument to use the
        properties from the layout object. Construct a valid \\LayerInfo object with explicit layer,
        datatype and possibly a name to override the properties stored in the layout.'''

    def add_this_cell(self, ...):
        '''@brief Adds a cell to be saved

        @args cell_index

        The index of the cell must be a valid index in the context of the layout that will be saved.
        This method clears the 'select all cells' flag. Unlike \\add_cell, this method does not
        implicitly add all children of that cell.

        This method has been added in version 0.23.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def clear_cells(self, ...):
        '''@brief Clears all cells to be saved

        This method can be used to ensure that no cell is selected before \\add_cell is called to
        specify a cell. This method clears the 'select all cells' flag.

        This method has been added in version 0.22.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def deselect_all_layers(self, ...):
        '''@brief Unselect all layers: no layer will be saved

        This method will clear all layers selected with \\add_layer so far and clear the 'select all
        layers' flag. Using this method is the only way to save a layout without any layers.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def select_all_cells(self, ...):
        '''@brief Select all cells to save

        This method will clear all cells specified with \\add_cells so far and set the 'select all
        cells' flag. This is the default.'''

    def select_all_layers(self, ...):
        '''@brief Select all layers to be saved

        This method will clear all layers selected with \\add_layer so far and set the 'select all
        layers' flag. This is the default.'''

    def select_cell(self, ...):
        '''@brief Selects a cell to be saved (plus hierarchy below)

        @args cell_index

        This method is basically a convenience method that combines \\clear_cells and \\add_cell.
        This method clears the 'select all cells' flag.

        This method has been added in version 0.22.'''

    def select_this_cell(self, ...):
        '''@brief Selects a cell to be saved

        @args cell_index

        This method is basically a convenience method that combines \\clear_cells and
        \\add_this_cell. This method clears the 'select all cells' flag.

        This method has been added in version 0.23.'''

    def set_format_from_filename(self, ...):
        '''@brief Select a format from the given file name @args filename

        This method will set the format according to the file's extension.

        This method has been introduced in version 0.22. Beginning with version 0.23, this method
        always returns true, since the only consumer for the return value, Layout#write, now ignores
        that parameter and automatically determines the compression mode from the file name.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Default constructor

        This will initialize the scale factor to 1.0, the database unit is set to "same as original"
        and all layers are selected as well as all cells. The default format is GDS2.'''


class Shape:
    '''@brief An object representing a shape in the layout database

    The shape proxy is basically a pointer to a shape of different kinds. No copy of the shape is
    created: if the shape proxy is copied the copy still points to the original shape. If the
    original shape is modified or deleted, the shape proxy will also point to a modified or invalid
    shape. The proxy can be "null" which indicates an invalid reference.

    Shape objects are used together with the \\Shapes container object which stores the actual shape
    objects and uses Shape references as pointers inside the actual data storage. Shape references
    are used in various places, i.e. when removing or transforming objects inside a \\Shapes
    container. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the box object

    Starting with version 0.23, this method returns nil, if the shape does not represent a box.

    @brief Replaces the shape by the given box @args box This method replaces the shape by the given
    box. This method can only be called for editable layouts. It does not change the user properties
    of the shape. Calling this method will invalidate any iterators. It should not be called inside
    a loop iterating over shapes.

    This method has been introduced in version 0.22.

    @brief Replaces the shape by the given box (in micrometer units) This method replaces the shape
    by the given box, like \\box= with a \\Box argument does. This version translates the box from
    micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    box = None

    '''@brief Returns the center of the box

    Applies to boxes only. Returns the center of the box and throws an exception if the shape is not
    a box.

    This method has been introduced in version 0.23.

     @brief Sets the center of the box

    Applies to boxes only. Changes the center of the box and throws an exception if the shape is not
    a box.

    This method has been introduced in version 0.23.

     @brief Sets the center of the box with the point being given in micrometer units

    Applies to boxes only. Changes the center of the box and throws an exception if the shape is not
    a box. Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.'''
    box_center = None

    '''@brief Returns the center of the box as a \\DPoint object in micrometer units

    Applies to boxes only. Returns the center of the box and throws an exception if the shape is not
    a box. Conversion from database units to micrometers is done internally.

    This method has been introduced in version 0.25.

     @brief Sets the center of the box with the point being given in micrometer units

    Applies to boxes only. Changes the center of the box and throws an exception if the shape is not
    a box. Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.'''
    box_dcenter = None

    '''@brief Returns the height of the box in micrometer units

    Applies to boxes only. Returns the height of the box in micrometers and throws an exception if
    the shape is not a box.

    This method has been introduced in version 0.25.

     @brief Sets the height of the box

    Applies to boxes only. Changes the height of the box to the value given in micrometer units and
    throws an exception if the shape is not a box. Translation to database units happens internally.

    This method has been introduced in version 0.25.'''
    box_dheight = None

    '''@brief Returns the lower left point of the box as a \\DPoint object in micrometer units

    Applies to boxes only. Returns the lower left point of the box and throws an exception if the
    shape is not a box. Conversion from database units to micrometers is done internally.

    This method has been introduced in version 0.25.

     @brief Sets the lower left corner of the box with the point being given in micrometer units

    Applies to boxes only. Changes the lower left point of the box and throws an exception if the
    shape is not a box. Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.'''
    box_dp1 = None

    '''@brief Returns the upper right point of the box as a \\DPoint object in micrometer units

    Applies to boxes only. Returns the upper right point of the box and throws an exception if the
    shape is not a box. Conversion from database units to micrometers is done internally.

    This method has been introduced in version 0.25.

     @brief Sets the upper right corner of the box with the point being given in micrometer units

    Applies to boxes only. Changes the upper right point of the box and throws an exception if the
    shape is not a box. Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.'''
    box_dp2 = None

    '''@brief Returns the width of the box in micrometer units

    Applies to boxes only. Returns the width of the box in micrometers and throws an exception if
    the shape is not a box.

    This method has been introduced in version 0.25.

     @brief Sets the width of the box in micrometer units @args w

    Applies to boxes only. Changes the width of the box to the value given in micrometer units and
    throws an exception if the shape is not a box. Translation to database units happens internally.

    This method has been introduced in version 0.25.'''
    box_dwidth = None

    '''@brief Returns the height of the box

    Applies to boxes only. Returns the height of the box and throws an exception if the shape is not
    a box.

    This method has been introduced in version 0.23.

     @brief Sets the height of the box @args h

    Applies to boxes only. Changes the height of the box and throws an exception if the shape is not
    a box.

    This method has been introduced in version 0.23.'''
    box_height = None

    '''@brief Returns the lower left point of the box

    Applies to boxes only. Returns the lower left point of the box and throws an exception if the
    shape is not a box.

    This method has been introduced in version 0.23.

     @brief Sets the lower left point of the box

    Applies to boxes only. Changes the lower left point of the box and throws an exception if the
    shape is not a box.

    This method has been introduced in version 0.23.

     @brief Sets the lower left corner of the box with the point being given in micrometer units

    Applies to boxes only. Changes the lower left point of the box and throws an exception if the
    shape is not a box. Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.'''
    box_p1 = None

    '''@brief Returns the upper right point of the box

    Applies to boxes only. Returns the upper right point of the box and throws an exception if the
    shape is not a box.

    This method has been introduced in version 0.23.

     @brief Sets the upper right point of the box

    Applies to boxes only. Changes the upper right point of the box and throws an exception if the
    shape is not a box.

    This method has been introduced in version 0.23.

     @brief Sets the upper right corner of the box with the point being given in micrometer units

    Applies to boxes only. Changes the upper right point of the box and throws an exception if the
    shape is not a box. Translation from micrometer units to database units is done internally.

    This method has been introduced in version 0.25.'''
    box_p2 = None

    '''@brief Returns the width of the box

    Applies to boxes only. Returns the width of the box and throws an exception if the shape is not
    a box.

    This method has been introduced in version 0.23.

     @brief Sets the width of the box @args w

    Applies to boxes only. Changes the width of the box and throws an exception if the shape is not
    a box.

    This method has been introduced in version 0.23.'''
    box_width = None

    '''@brief Gets a reference to the cell the shape belongs to

    This reference can be nil, if the Shape object is not living inside a cell

    This method has been introduced in version 0.22.

    @brief Moves the shape to a different cell @args cell

    Both the current and the target cell must reside in the same layout.

    This method has been introduced in version 0.23.'''
    cell = None

    '''@brief Gets the box object in micrometer units See \\box for a description of this method.
    This method returns the box after translation to micrometer units.

    This method has been added in version 0.25.

     @brief Replaces the shape by the given box (in micrometer units) This method replaces the shape
    by the given box, like \\box= with a \\Box argument does. This version translates the box from
    micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    dbox = None

    '''@brief Returns the path object as a \\DEdge object in micrometer units See \\edge for a
    description of this method. This method returns the edge after translation to micrometer units.

    This method has been added in version 0.25.

     @brief Replaces the shape by the given edge (in micrometer units) This method replaces the
    shape by the given edge, like \\edge= with a \\Edge argument does. This version translates the
    edge from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    dedge = None

    '''@brief Returns the path object as a \\DPath object in micrometer units See \\path for a
    description of this method. This method returns the path after translation to micrometer units.

    This method has been added in version 0.25.

     @brief Replaces the shape by the given path (in micrometer units) This method replaces the
    shape by the given path, like \\path= with a \\Path argument does. This version translates the
    path from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    dpath = None

    '''@brief Returns the polygon object in micrometer units

    Returns the polygon object that this shape refers to or converts the object to a polygon. The
    method returns the same object than \\polygon, but translates it to micrometer units internally.

    This method has been introduced in version 0.25.

     @brief Replaces the shape by the given polygon (in micrometer units) This method replaces the
    shape by the given polygon, like \\polygon= with a \\Polygon argument does. This version
    translates the polygon from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    dpolygon = None

    '''@brief Returns the simple polygon object in micrometer units

    Returns the simplep olygon object that this shape refers to or converts the object to a
    simplepolygon. The method returns the same object than \\simple_polygon, but translates it to
    micrometer units internally.

    This method has been introduced in version 0.25.

     @brief Replaces the shape by the given simple polygon (in micrometer units) This method
    replaces the shape by the given text, like \\simple_polygon= with a \\SimplePolygon argument
    does. This version translates the polygon from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    dsimple_polygon = None

    '''@brief Returns the path object as a \\DText object in micrometer units See \\edge for a
    description of this method. This method returns the text after translation to micrometer units.

    This method has been added in version 0.25.

     @brief Replaces the shape by the given text (in micrometer units) This method replaces the
    shape by the given text, like \\text= with a \\Text argument does. This version translates the
    text from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    dtext = None

    '''@brief Returns the edge object

    Starting with version 0.23, this method returns nil, if the shape does not represent an edge.

    @brief Replaces the shape by the given edge @args box This method replaces the shape by the
    given edge. This method can only be called for editable layouts. It does not change the user
    properties of the shape. Calling this method will invalidate any iterators. It should not be
    called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.

    @brief Replaces the shape by the given edge (in micrometer units) This method replaces the shape
    by the given edge, like \\edge= with a \\Edge argument does. This version translates the edge
    from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    edge = None

    '''@brief Returns the layer index of the layer the shape is on Throws an exception if the shape
    does not reside inside a cell.

    This method has been added in version 0.23.

     @brief Moves the shape to a layer given by the layer index object @args layer_index

    This method has been added in version 0.23.'''
    layer = None

    '''@brief Returns the \\LayerInfo object of the layer the shape is on If the shape does not
    reside inside a cell, an empty layer is returned.

    This method has been added in version 0.23.

     @brief Moves the shape to a layer given by a \\LayerInfo object @args layer_info If no layer
    with the given properties exists, an exception is thrown.

    This method has been added in version 0.23.'''
    layer_info = None

    '''@brief Returns the path object

    Starting with version 0.23, this method returns nil, if the shape does not represent a path.

    @brief Replaces the shape by the given path object @args box This method replaces the shape by
    the given path object. This method can only be called for editable layouts. It does not change
    the user properties of the shape. Calling this method will invalidate any iterators. It should
    not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.

    @brief Replaces the shape by the given path (in micrometer units) This method replaces the shape
    by the given path, like \\path= with a \\Path argument does. This version translates the path
    from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    path = None

    '''@brief Gets the path's starting vertex extension

    Applies to paths only. Will throw an exception if the object is not a path.

     @brief Sets the path's starting vertex extension Applies to paths only. Will throw an exception
    if the object is not a path.

    This method has been introduced in version 0.23.'''
    path_bgnext = None

    '''@brief Gets the path's starting vertex extension in micrometer units

    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.25.

    @brief Sets the path's starting vertex extension in micrometer units Applies to paths only. Will
    throw an exception if the object is not a path.

    This method has been introduced in version 0.25.'''
    path_dbgnext = None

    '''@brief Gets the path's end vertex extension in micrometer units

    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.25.

    @brief Sets the path's end vertex extension in micrometer units Applies to paths only. Will
    throw an exception if the object is not a path.

    This method has been introduced in version 0.25.'''
    path_dendext = None

    '''@brief Gets the path width in micrometer units

    Applies to paths only. Will throw an exception if the object is not a path.

    This method has been introduced in version 0.25.

    @brief Sets the path width in micrometer units Applies to paths only. Will throw an exception if
    the object is not a path. Conversion to database units is done internally.

    This method has been introduced in version 0.25.'''
    path_dwidth = None

    '''@brief Obtain the path's end vertex extension

    Applies to paths only. Will throw an exception if the object is not a path.

     @brief Sets the path's end vertex extension Applies to paths only. Will throw an exception if
    the object is not a path.

    This method has been introduced in version 0.23.'''
    path_endext = None

    '''@brief Gets the path width

    Applies to paths only. Will throw an exception if the object is not a path.

     @brief Sets the path width Applies to paths only. Will throw an exception if the object is not
    a path.

    This method has been introduced in version 0.23.'''
    path_width = None

    '''@brief Returns the polygon object

    Returns the polygon object that this shape refers to or converts the object to a polygon. Paths,
    boxes and simple polygons are converted to polygons. For paths this operation renders the path's
    hull contour.

    Starting with version 0.23, this method returns nil, if the shape does not represent a
    geometrical primitive that can be converted to a polygon.

     @brief Replaces the shape by the given polygon object @args box This method replaces the shape
    by the given polygon object. This method can only be called for editable layouts. It does not
    change the user properties of the shape. Calling this method will invalidate any iterators. It
    should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.

    @brief Replaces the shape by the given polygon (in micrometer units) This method replaces the
    shape by the given polygon, like \\polygon= with a \\Polygon argument does. This version
    translates the polygon from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    polygon = None

    '''@brief Gets the properties ID associated with the shape

    The \\Layout object can be used to retrieve the actual properties associated with the ID.

    @brief Sets the properties ID of this shape

    The \\Layout object can be used to retrieve an ID for a given set of properties. Calling this
    method will invalidate any iterators. It should not be called inside a loop iterating over
    shapes.

    This method has been introduced in version 0.22.'''
    prop_id = None

    '''@brief Returns true, if the path has round ends

    Applies to paths only. Will throw an exception if the object is not a path.

     @brief The path will be a round-ended path if this property is set to true @args r

    Applies to paths only. Will throw an exception if the object is not a path. Please note that the
    extensions will apply as well. To get a path with circular ends, set the begin and end
    extensions to half the path's width.

    This method has been introduced in version 0.23.'''
    round_path = None

    '''@brief Returns the simple polygon object

    Returns the simple polygon object that this shape refers to or converts the object to a simple
    polygon. Paths, boxes and polygons are converted to simple polygons. Polygons with holes will
    have their holes removed but introducing cut lines that connect the hole contours with the outer
    contour.  Starting with version 0.23, this method returns nil, if the shape does not represent a
    geometrical primitive that can be converted to a simple polygon.

     @brief Replaces the shape by the given simple polygon object This method replaces the shape by
    the given simple polygon object. This method can only be called for editable layouts. It does
    not change the user properties of the shape. Calling this method will invalidate any iterators.
    It should not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.

    @brief Replaces the shape by the given simple polygon (in micrometer units) This method replaces
    the shape by the given text, like \\simple_polygon= with a \\SimplePolygon argument does. This
    version translates the polygon from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    simple_polygon = None

    '''@brief Returns the text object

    Starting with version 0.23, this method returns nil, if the shape does not represent a text.

    @brief Replaces the shape by the given text object @args box This method replaces the shape by
    the given text object. This method can only be called for editable layouts. It does not change
    the user properties of the shape. Calling this method will invalidate any iterators. It should
    not be called inside a loop iterating over shapes.

    This method has been introduced in version 0.22.

    @brief Replaces the shape by the given text (in micrometer units) This method replaces the shape
    by the given text, like \\text= with a \\Text argument does. This version translates the text
    from micrometer units to database units internally.

    This method has been introduced in version 0.25.'''
    text = None

    '''@brief Gets the text's position in micrometer units

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been added in version 0.25.

     @brief Sets the text's position in micrometer units Applies to texts only. Will throw an
    exception if the object is not a text.

    This method has been added in version 0.25.'''
    text_dpos = None

    '''@brief Gets the text size in micrometer units

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.25.

    @brief Sets the text size in micrometer units @args size

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.25.'''
    text_dsize = None

    '''@brief Gets the text transformation in micrometer units

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been added in version 0.25.

     @brief Sets the text transformation in micrometer units Applies to texts only. Will throw an
    exception if the object is not a text.

    This method has been introduced in version 0.25.'''
    text_dtrans = None

    '''@brief Gets the text's font

    Applies to texts only. Will throw an exception if the object is not a text.

     @brief Sets the text's font @args font

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.23.'''
    text_font = None

    '''@brief Gets the text's horizontal alignment

    Applies to texts only. Will throw an exception if the object is not a text. The return value is
    0 for left alignment, 1 for center alignment and 2 to right alignment.

    This method has been introduced in version 0.22.

     @brief Sets the text's horizontal alignment @args a

    Applies to texts only. Will throw an exception if the object is not a text. See \\text_halign
    for a description of that property.

    This method has been introduced in version 0.23.'''
    text_halign = None

    '''@brief Gets the text's position

    Applies to texts only. Will throw an exception if the object is not a text.

     @brief Sets the text's position Applies to texts only. Will throw an exception if the object is
    not a text.

     @brief Sets the text's position in micrometer units Applies to texts only. Will throw an
    exception if the object is not a text.

    This method has been added in version 0.25.'''
    text_pos = None

    '''@brief Gets the text's orientation code (see \\Trans)

    Applies to texts only. Will throw an exception if the object is not a text.

     @brief Sets the text's orientation code (see \\Trans) @args o

    Applies to texts only. Will throw an exception if the object is not a text.'''
    text_rot = None

    '''@brief Gets the text size

    Applies to texts only. Will throw an exception if the object is not a text.

     @brief Sets the text size @args size

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.23.'''
    text_size = None

    '''@brief Obtain the text string

    Applies to texts only. Will throw an exception if the object is not a text.

     @brief Sets the text string @args string

    Applies to texts only. Will throw an exception if the object is not a text.

    This method has been introduced in version 0.23.'''
    text_string = None

    '''@brief Gets the text transformation

    Applies to texts only. Will throw an exception if the object is not a text.

     @brief Sets the text transformation Applies to texts only. Will throw an exception if the
    object is not a text.

    This method has been introduced in version 0.23.

    @brief Sets the text transformation in micrometer units Applies to texts only. Will throw an
    exception if the object is not a text.

    This method has been introduced in version 0.25.'''
    text_trans = None

    '''@brief Gets the text's vertical alignment

    Applies to texts only. Will throw an exception if the object is not a text. The return value is
    0 for top alignment, 1 for center alignment and 2 to bottom alignment.

    This method has been introduced in version 0.22.

     @brief Sets the text's vertical alignment @args a

    Applies to texts only. Will throw an exception if the object is not a text. See \\text_valign
    for a description of that property.

    This method has been introduced in version 0.23.'''
    text_valign = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality operator @args other

        Equality of shapes is not specified by the identity of the objects but by the identity of
        the pointers - both shapes must refer to the same object.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''@brief Inequality operator @args other'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Create a string showing the contents of the reference

        This method has been introduced with version 0.16.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Create a string showing the contents of the reference

        This method has been introduced with version 0.16.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief Returns the area of the shape This method has been added in version 0.22.'''

    def array_dtrans(self, ...):
        '''@brief Gets the array instance member transformation in micrometer units

        This attribute is valid only if \\is_array_member? is true. The transformation returned
        describes the relative transformation of the  array member addressed. The displacement is
        given in micrometer units.

        This method has been added in version 0.25.'''

    def array_trans(self, ...):
        '''@brief Gets the array instance member transformation

        This attribute is valid only if \\is_array_member? is true. The transformation returned
        describes the relative transformation of the  array member addressed.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Returns the bounding box of the shape'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def darea(self, ...):
        '''@brief Returns the area of the shape in square micrometer units This method has been
        added in version 0.25.'''

    def dbbox(self, ...):
        '''@brief Returns the bounding box of the shape in micrometer units This method has been
        added in version 0.25.'''

    def delete(self, ...):
        '''@brief Deletes the shape

        After the shape is deleted, the shape object is emptied and points to nothing.

        This method has been introduced in version 0.23.'''

    def delete_property(self, ...):
        '''@brief Deletes the user property with the given key @args key This method is a
        convenience method that deletes the property with the given key. It does nothing if no
        property with that key exists. Using that method is more convenient than creating a new
        property set with a new ID and assigning that properties ID. This method may change the
        properties ID. Calling this method will invalidate any iterators. It should not be called
        inside a loop iterating over shapes.

        This method has been introduced in version 0.22.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dperimeter(self, ...):
        '''@brief Returns the perimeter of the shape in micrometer units

        This method will return an approximation of the perimeter for paths.

        This method has been added in version 0.25.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_dedge(self, ...):
        '''@brief Iterates over the edges of a single contour of the object and returns edges in
        micrometer units

        This method iterates over all edges of polygons and simple polygons like \\each_edge, but
        will deliver edges in micrometer units. Multiplication by the database unit is done
        internally.

        This method has been introduced in version 0.25.'''

    def each_dpoint(self, ...):
        '''@brief Iterates over all points of the object and returns points in micrometer units

        This method iterates over all points of the object like \\each_point, but it returns
        \\DPoint objects that are given in micrometer units already. Multiplication with the
        database unit happens internally.

        This method has been introduced in version 0.25.'''

    def each_dpoint_hole(self, ...):
        '''@brief Iterates over a hole contour of the object and returns points in micrometer units

        This method iterates over all points of the object's contour' like \\each_point_hole, but it
        returns \\DPoint objects that are given in micrometer units already. Multiplication with the
        database unit happens internally.

        This method has been introduced in version 0.25.'''

    def each_dpoint_hull(self, ...):
        '''@brief Iterates over the hull contour of the object and returns points in micrometer
        units

        This method iterates over all points of the object's contour' like \\each_point_hull, but it
        returns \\DPoint objects that are given in micrometer units already. Multiplication with the
        database unit happens internally.

        This method has been introduced in version 0.25.'''

    def each_edge(self, ...):
        '''@brief Iterates over the edges of a single contour of the object @param contour The
        contour number (0 for hull, 1 for first hole ...)

        This method applies to polygons and simple polygons and delivers all edges that form the
        given contour of the polygon. The hull has contour number 0, the first hole has contour 1
        etc. Hole edges are oriented counterclockwise while hull egdes are oriented clockwise.

        It will throw an exception if the object is not a polygon.

        This method was introduced in version 0.24.'''

    def each_point(self, ...):
        '''@brief Iterates over all points of the object

        This method applies to paths and delivers all points of the path's center line. It will
        throw an exception for other objects.'''

    def each_point_hole(self, ...):
        '''@brief Iterates over the points of a hole contour @args hole_index

        This method applies to polygons and delivers all points of the respective hole contour. It
        will throw an exception for other objects. Simple polygons deliver an empty sequence.

        @param hole The hole index (see holes () method)'''

    def each_point_hull(self, ...):
        '''@brief Iterates over the hull contour of the object

        This method applies to polygons and delivers all points of the polygon hull contour. It will
        throw an exception for other objects.'''

    def has_prop_id(self, ...):
        '''@brief Returns true, if the shape has properties, i.e. has a properties ID'''

    def holes(self, ...):
        '''@brief Returns the number of holes

        This method applies to polygons and will throw an exception for other objects.. Simple
        polygons deliver a value of zero.'''

    def is_array_member(self, ...):
        '''@brief Returns true, if the shape is a member of a shape array'''

    def is_box(self, ...):
        '''@brief Returns true if the shape is a box'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_edge(self, ...):
        '''@brief Returns true, if the object is an edge'''

    def is_null(self, ...):
        '''@brief Returns true, if the shape reference is a null reference (not referring to a
        shape)'''

    def is_path(self, ...):
        '''@brief Returns true, if the shape is a path'''

    def is_polygon(self, ...):
        '''@brief Returns true, if the shape is a polygon

        This method returns true only if the object is a polygon or a simple polygon. Other objects
        can convert to polygons, for example paths, so it may be possible to use the \\polygon
        method also if is_polygon? does not return true.'''

    def is_simple_polygon(self, ...):
        '''@brief Returns true, if the shape is a simple polygon

        This method returns true only if the object is a simple polygon. The simple polygon identity
        is contained in the polygon identity, so usually it is sufficient to use \\is_polygon? and
        \\polygon instead of specifically handle simply polygons. This method is provided only for
        specific optimisation purposes.'''

    def is_text(self, ...):
        '''@brief Returns true, if the object is a text'''

    def is_user_object(self, ...):
        '''@brief Returns true if the shape is a user defined object'''

    def is_valid(self, ...):
        '''@brief Returns true, if the shape is valid

        After the shape is deleted, the shape object is no longer valid and this method returns
        false.

        This method has been introduced in version 0.23.'''

    def layout(self, ...):
        '''@brief Gets a reference to the Layout the shape belongs to

        This reference can be nil, if the Shape object is not living inside a layout.

        This method has been introduced in version 0.22.'''

    def path_dlength(self, ...):
        '''@brief Returns the length of the path in micrometer units

        Applies to paths only. Will throw an exception if the object is not a path. This method
        returns the length of the spine plus extensions if present. The value returned is given in
        micrometer units.

        This method has been added in version 0.25.'''

    def path_length(self, ...):
        '''@brief Returns the length of the path

        Applies to paths only. Will throw an exception if the object is not a path. This method
        returns the length of the spine plus extensions if present.

        This method has been added in version 0.23.'''

    def perimeter(self, ...):
        '''@brief Returns the perimeter of the shape

        This method will return an approximation of the perimeter for paths.

        This method has been added in version 0.23.'''

    def property(self, ...):
        '''@brief Gets the user property with the given key @args key This method is a convenience
        method that gets the property with the given key. If no property with that key does not
        exist, it will return nil. Using that method is more convenient than using the layout object
        and the properties ID to retrieve the property value.  This method has been introduced in
        version 0.22.'''

    def set_property(self, ...):
        '''@brief Sets the user property with the given key to the given value @args key, value This
        method is a convenience method that sets the property with the given key to the given value.
        If no property with that key exists, it will create one. Using that method is more
        convenient than creating a new property set with a new ID and assigning that properties ID.
        This method may change the properties ID. Calling this method will invalidate any iterators.
        It should not be called inside a loop iterating over shapes.

        This method has been introduced in version 0.22.'''

    def shapes(self, ...):
        '''@brief Gets a reference to the Shapes container the shape lives in

        This reference can be nil, if the Shape object is not referring to an actual shape.

        This method has been introduced in version 0.22.'''

    def to_s(self, ...):
        '''@brief Create a string showing the contents of the reference

        This method has been introduced with version 0.16.'''

    def transform(self, ...):
        '''@brief Transforms the shape with the given complex transformation, given in micrometer
        units This method has been introduced in version 0.25.'''

    def type(self, ...):
        '''@brief Return the type of the shape

        The returned values are the t_... constants available through the corresponding class
        members.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''

    @classmethod
    def t_box(cls, ...):
        pass

    @classmethod
    def t_box_array(cls, ...):
        pass

    @classmethod
    def t_box_array_member(cls, ...):
        pass

    @classmethod
    def t_edge(cls, ...):
        pass

    @classmethod
    def t_null(cls, ...):
        pass

    @classmethod
    def t_path(cls, ...):
        pass

    @classmethod
    def t_path_ptr_array(cls, ...):
        pass

    @classmethod
    def t_path_ptr_array_member(cls, ...):
        pass

    @classmethod
    def t_path_ref(cls, ...):
        pass

    @classmethod
    def t_polygon(cls, ...):
        pass

    @classmethod
    def t_polygon_ptr_array(cls, ...):
        pass

    @classmethod
    def t_polygon_ptr_array_member(cls, ...):
        pass

    @classmethod
    def t_polygon_ref(cls, ...):
        pass

    @classmethod
    def t_short_box(cls, ...):
        pass

    @classmethod
    def t_short_box_array(cls, ...):
        pass

    @classmethod
    def t_short_box_array_member(cls, ...):
        pass

    @classmethod
    def t_simple_polygon(cls, ...):
        pass

    @classmethod
    def t_simple_polygon_ptr_array(cls, ...):
        pass

    @classmethod
    def t_simple_polygon_ptr_array_member(cls, ...):
        pass

    @classmethod
    def t_simple_polygon_ref(cls, ...):
        pass

    @classmethod
    def t_text(cls, ...):
        pass

    @classmethod
    def t_text_ptr_array(cls, ...):
        pass

    @classmethod
    def t_text_ptr_array_member(cls, ...):
        pass

    @classmethod
    def t_text_ref(cls, ...):
        pass

    @classmethod
    def t_user_object(cls, ...):
        pass


class ShapeProcessor:
    '''@brief The shape processor (boolean, sizing, merge on shapes)

    The shape processor implements the boolean and edge set operations (size, merge). Because the
    shape processor might allocate resources which can be reused in later operations, it is
    implemented as an object that can be used several times. The shape processor is similar to the
    \\EdgeProcessor. The latter is specialized on handling polygons and edges directly.  '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def boolean(self, ...):
        '''@brief Boolean operation on two given shape sets into an edge set @args in_a, in_b, mode

        See the \\EdgeProcessor for a description of the boolean operations. This implementation
        takes shapes rather than polygons for input and produces an edge set.

        This version does not allow to specify a transformation for each shape (unity is assumed).

        @param in_a The set of shapes to use for input A @param in_b The set of shapes to use for
        input A @param mode The boolean operation (see \\EdgeProcessor)'''

    def boolean_to_polygon(self, ...):
        '''@brief Boolean operation on two given shape sets into a polygon set @args in_a, in_b,
        mode, resolve_holes, min_coherence

        See the \\EdgeProcessor for a description of the boolean operations. This implementation
        takes shapes rather than polygons for input and produces a polygon set.

        This version does not allow to specify a transformation for each shape (unity is assumed).

        @param in_a The set of shapes to use for input A @param in_b The set of shapes to use for
        input A @param mode The boolean operation (see \\EdgeProcessor) @param resolve_holes true,
        if holes should be resolved into the hull @param min_coherence true, if minimum polygons
        should be created for touching corners'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def merge(self, ...):
        '''@brief Merge the given shapes @args in, min_wc

        See the \\EdgeProcessor for a description of the merge method. This implementation takes
        shapes rather than polygons for input and produces an edge set.

        This version does not allow to specify a transformation for each shape (unity is assumed).

        @param in The set of shapes to merge @param min_wc The minimum wrap count for output (0: all
        polygons, 1: at least two overlapping)'''

    def merge_to_polygon(self, ...):
        '''@brief Merge the given shapes @args in, min_wc, resolve_holes, min_coherence

        See the \\EdgeProcessor for a description of the merge method. This implementation takes
        shapes rather than polygons for input and produces a polygon set.

        This version does not allow to specify a transformation for each shape (unity is assumed).

        @param in The set of shapes to merge @param min_wc The minimum wrap count for output (0: all
        polygons, 1: at least two overlapping) @param resolve_holes true, if holes should be
        resolved into the hull @param min_coherence true, if minimum polygons should be created for
        touching corners'''

    def size(self, ...):
        '''@brief Size the given shapes @args in, dx, dy, mode

        See the \\EdgeProcessor for a description of the sizing method. This implementation takes
        shapes rather than polygons for input and produces an edge set.

        This version does not allow to specify a transformation for each shape (unity is assumed).

        @param in The set of shapes to size @param dx The sizing value in x-direction @param dy The
        sizing value in y-direction @param mode The sizing mode (see \\EdgeProcessor)'''

    def size_to_polygon(self, ...):
        '''@brief Size the given shapes @args in, dx, dy, mode, resolve_holes, min_coherence

        See the \\EdgeProcessor for a description of the sizing method. This implementation takes
        shapes rather than polygons for input and produces a polygon set.

        This version does not allow to specify a transformation for each shape (unity is assumed).

        @param in The set of shapes to size @param dx The sizing value in x-direction @param dy The
        sizing value in y-direction @param mode The sizing mode (see \\EdgeProcessor) @param
        resolve_holes true, if holes should be resolved into the hull @param min_coherence true, if
        minimum polygons should be created for touching corners'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Shapes:
    '''@brief A collection of shapes

    A shapes collection is a collection of geometrical objects, such as polygons, boxes, paths,
    edges or text objects.

    Shapes objects are the basic containers for geometrical objects of a cell. Inside a cell, there
    is one Shapes object per layer. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __len__(self, ...):
        '''@brief Gets the number of shapes in this container This method was introduced in version
        0.16 @return The number of shapes in this container'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def clear(self, ...):
        '''@brief Clears the shape container This method has been introduced in version 0.16. It can
        only be used in editable mode.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dump_mem_statistics(self, ...):
        '''@hide'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each(self, ...):
        '''@brief Gets all shapes

        This call is equivalent to each(SAll). This convenience method has been introduced in
        version 0.16'''

    def each_overlapping(self, ...):
        '''@brief Gets all shapes that overlap the search box (region) where the search box is given
        in micrometer units @param region The rectangular search region as a \\DBox object in
        micrometer units This call is equivalent to each_touching(SAll,region).

        This method was introduced in version 0.25'''

    def each_touching(self, ...):
        '''@brief Gets all shapes that touch the search box (region) where the search box is given
        in micrometer units @param region The rectangular search region as a \\DBox object in
        micrometer units This call is equivalent to each_touching(SAll,region).

        This method was introduced in version 0.25'''

    def erase(self, ...):
        '''@brief Erases the shape pointed to by the given \\Shape object @args shape This method
        has been introduced in version 0.16. It can only be used in editable mode. Erasing a shape
        will invalidate the shape reference. Access to this reference may then render invalid
        results.

        @param shape The shape which to destroy'''

    def find(self, ...):
        '''@brief Finds a shape inside this collected @args shape This method has been introduced in
        version 0.21. This method tries to find the given shape in this collection. The original
        shape may be located in another collection. If the shape is found, this method returns a
        reference to the shape in this collection, otherwise a null reference is returned.'''

    def insert(self, ...):
        '''@brief Inserts a micrometer-unit polygon with properties into the shapes list @return A
        reference to the new shape (a \\Shape object) This method behaves like the \\insert version
        with a \\Polygon argument and a property ID, except that it will internally translate the
        polygon from micrometer to database units.

        This variant has been introduced in version 0.25.'''

    def insert_as_edges(self, ...):
        '''@brief Inserts the edge pairs from the edge pair collection as individual into this shape
        container with a transformation (given in micrometer units) @param edges The edge pairs to
        insert @param trans The transformation to apply (displacement in micrometer units)

        This method inserts all edge pairs from the edge pair collection into this shape container.
        Each edge from the edge pair is inserted individually into the shape container. Before each
        edge is inserted into the shape collection, the given transformation is applied.

        This method has been introduced in version 0.25.'''

    def insert_as_polygons(self, ...):
        '''@brief Inserts the edge pairs from the edge pair collection as polygons into this shape
        container with a transformation @param edges The edge pairs to insert @param e The extension
        to apply when converting the edges to polygons (in micrometer units) @param trans The
        transformation to apply (displacement in micrometer units)

        This method is identical to the version with a integer-type \\e and \\trans parameter, but
        for this version the \\e parameter is given in micrometer units and the \\trans parameter is
        a micrometer-unit transformation.

        This method has been introduced in version 0.25.'''

    def insert_box(self, ...):
        '''@brief Inserts a box into the shapes list @return A reference to the new shape (a \\Shape
        object) @args box

        Starting with version 0.16, this method returns a reference to the newly created shape'''

    def insert_box_with_properties(self, ...):
        '''@brief Inserts a box with properties into the shapes list @args box, property_id @return
        A reference to the new shape (a \\Shape object) The property Id must be obtained from the
        \\Layout object's property_id method which associates a property set with a property Id.
        Starting with version 0.16, this method returns a reference to the newly created shape'''

    def insert_edge(self, ...):
        '''@brief Inserts a edge into the shapes list @args edge

        Starting with version 0.16, this method returns a reference to the newly created shape'''

    def insert_edge_with_properties(self, ...):
        '''@brief Inserts a edge with properties into the shapes list @args edge, property_id
        @return A reference to the new shape (a \\Shape object) The property Id must be obtained
        from the \\Layout object's property_id method which associates a property set with a
        property Id. Starting with version 0.16, this method returns a reference to the newly
        created shape'''

    def insert_path(self, ...):
        '''@brief Inserts a path into the shapes list @return A reference to the new shape (a
        \\Shape object) @args path

        Starting with version 0.16, this method returns a reference to the newly created shape'''

    def insert_path_with_properties(self, ...):
        '''@brief Inserts a path with properties into the shapes list @args path, property_id
        @return A reference to the new shape (a \\Shape object) The property Id must be obtained
        from the \\Layout object's property_id method which associates a property set with a
        property Id. Starting with version 0.16, this method returns a reference to the newly
        created shape'''

    def insert_polygon(self, ...):
        '''@brief Inserts a polygon into the shapes list @return A reference to the new shape (a
        \\Shape object) @args polygon

        Starting with version 0.16, this method returns a reference to the newly created shape'''

    def insert_polygon_with_properties(self, ...):
        '''@brief Inserts a polygon with properties into the shapes list @args polygon, property_id
        @return A reference to the new shape (a \\Shape object) The property Id must be obtained
        from the \\Layout object's property_id method which associates a property set with a
        property Id. Starting with version 0.16, this method returns a reference to the newly
        created shape'''

    def insert_simple_polygon(self, ...):
        '''@brief Inserts a simple polygon into the shapes list @return A reference to the new shape
        (a \\Shape object) @args simple_polygon

        Starting with version 0.16, this method returns a reference to the newly created shape'''

    def insert_simple_polygon_with_properties(self, ...):
        '''@brief Inserts a simple polygon with properties into the shapes list @args
        simple_polygon, property_id @return A reference to the new shape (a \\Shape object) The
        property Id must be obtained from the \\Layout object's property_id method which associates
        a property set with a property Id. Starting with version 0.16, this method returns a
        reference to the newly created shape'''

    def insert_text(self, ...):
        '''@brief Inserts a text into the shapes list @return A reference to the new shape (a
        \\Shape object) @args text

        Starting with version 0.16, this method returns a reference to the newly created shape'''

    def insert_text_with_properties(self, ...):
        '''@brief Inserts a text with properties into the shapes list @args text, property_id
        @return A reference to the new shape (a \\Shape object) The property Id must be obtained
        from the \\Layout object's property_id method which associates a property set with a
        property Id. Starting with version 0.16, this method returns a reference to the newly
        created shape'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_empty(self, ...):
        '''@brief Returns a value indicating whether the shapes container is empty This method has
        been introduced in version 0.20.'''

    def is_valid(self, ...):
        '''@brief Tests if the given \\Shape object is still pointing to a valid object @args shape
        This method has been introduced in version 0.16. If the shape represented by the given
        reference has been deleted, this method returns false. If however, another shape has been
        inserted already that occupies the original shape's position, this method will return true
        again.'''

    def replace(self, ...):
        '''@brief Replaces the given shape with a polygon given in micrometer units @return A
        reference to the new shape (a \\Shape object)

        This method behaves like the \\replace version with a \\Polygon argument, except that it
        will internally translate the polygon from micrometer to database units.

        This variant has been introduced in version 0.25.'''

    def replace_prop_id(self, ...):
        '''@brief Replaces (or install) the properties of a shape @args shape,property_id @return A
        \\Shape object representing the new shape This method has been introduced in version 0.16.
        It can only be used in editable mode. Changes the properties Id of the given shape or
        install a properties Id on that shape if it does not have one yet. The property Id must be
        obtained from the \\Layout object's property_id method which associates a property set with
        a property Id. This method will potentially invalidate the shape reference passed to it. Use
        the reference returned for future references.'''

    def size(self, ...):
        '''@brief Gets the number of shapes in this container This method was introduced in version
        0.16 @return The number of shapes in this container'''

    def transform(self, ...):
        '''@brief Transforms the shape given by the reference with the given complex transformation,
        where the transformation is given in micrometer units @param trans The transformation to
        apply (displacement in micrometer units) @return A reference (a \\Shape object) to the new
        shape The original shape may be deleted and re-inserted by this method. Therefore, a new
        reference is returned. It is permitted in editable mode only. This method has been
        introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''

    @classmethod
    def s_all(cls, ...):
        '''@brief Indicates that all shapes shall be retrieved'''

    @classmethod
    def s_all_with_properties(cls, ...):
        '''@brief Indicates that all shapes with properties shall be retrieved'''

    @classmethod
    def s_boxes(cls, ...):
        '''@brief Indicates that boxes shall be retrieved'''

    @classmethod
    def s_edges(cls, ...):
        '''@brief Indicates that edges shall be retrieved'''

    @classmethod
    def s_paths(cls, ...):
        '''@brief Indicates that paths shall be retrieved'''

    @classmethod
    def s_polygons(cls, ...):
        '''@brief Indicates that polygons shall be retrieved'''

    @classmethod
    def s_properties(cls, ...):
        '''@brief Indicates that only shapes with properties shall be retrieved'''

    @classmethod
    def s_texts(cls, ...):
        '''@brief Indicates that texts be retrieved'''

    @classmethod
    def s_user_objects(cls, ...):
        '''@brief Indicates that user objects shall be retrieved'''


class SimplePolygon:
    '''@brief A simple polygon class

    A simple polygon consists of an outer hull only. To support polygons with holes, use \\Polygon.
    The hull contour consists of several points. The point list is normalized such that the
    leftmost, lowest point is  the first one. The orientation is normalized such that the
    orientation of the hull contour is clockwise.

    It is in no way checked that the contours are not overlapping This must be ensured by the user
    of the object when filling the contours.

    The \\SimplePolygon class stores coordinates in integer format. A class that stores floating-
    point coordinates is \\DSimplePolygon.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Set the points of the simple polygon

    @args pts @param pts An array of points to assign to the simple polygon

    See the constructor description for details about raw mode.'''
    points = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test @args p @param p The object to compare against'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor converting a box to a polygon

        @args box

        @param box The box to convert to a polygon'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args p @param p The object to compare against This operator is
        provided to establish some, not necessarily a certain sorting order

        This method has been introduced in version 0.25.'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test @args p @param p The object to compare against'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert to a string'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def area(self, ...):
        '''@brief The area of the polygon The area is correct only if the polygon is not self-
        overlapping and the polygon is oriented clockwise.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def bbox(self, ...):
        '''@brief Return the bounding box of the simple polygon'''

    def compress(self, ...):
        '''@brief Compress the simple polygon. @args remove_reflected

        This method removes redundant points from the polygon, such as points being on a line formed
        by two other points. If remove_reflected is true, points are also removed if the two
        adjacent edges form a spike.

        @param remove_reflected See description of the functionality.

        This method was introduced in version 0.18.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def each_edge(self, ...):
        '''@brief Iterate over the edges that make up the simple polygon'''

    def each_point(self, ...):
        '''@brief Iterate over the points that make up the simple polygon'''

    def extract_rad(self, ...):
        '''@brief Extracts the corner radii from a rounded polygon

        Attempts to extract the radii of rounded corner polygon. This is essentially the inverse of
        the \\round_corners method. If this method succeeds, if will return an array of four
        elements: @ul @li The polygon with the rounded corners replaced by edgy ones @/li @li The
        radius of the inner corners @/li @li The radius of the outer corners @/li @li The number of
        points per full circle @/li @/ul

        This method is based on some assumptions and may fail. In this case, an empty array is
        returned.

        If successful, the following code will more or less render the original polygon and
        parameters

        @code p = ...   # some polygon p.round_corners(ri, ro, n) (p2, ri2, ro2, n2) = p.extract_rad
        # -> p2 == p, ro2 == ro, ri2 == ri, n2 == n (within some limits) @/code

        This method was introduced in version 0.25.'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given polygon. This method
        enables polygons as hash keys.

        This method has been introduced in version 0.25.'''

    def inside(self, ...):
        '''@brief Test, if the given point is inside the polygon @args p If the given point is
        inside or on the edge the polygon, true is returned. This tests works well only if the
        polygon is not self-overlapping and oriented clockwise. '''

    def is_box(self, ...):
        '''@brief Returns true, if the polygon is a simple box.

        A polygon is a box if it is identical to it's bounding box.

        @return True if the polygon is a box.

        This method was introduced in version 0.23.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def minkowsky_sum(self, ...):
        '''@brief Compute the Minkowsky sum of a polygon and a contour of points (a trace) @args a,
        b, resolve_holes

        @param a The first argument. @param b The second argument (a series of points forming the
        trace). @param resolve_holes If true, the output polygon will not contain holes, but holes
        are resolved by joining the holes with the hull.

        @return The new polygon representing the Minkowsky sum of a and b.

        This method was introduced in version 0.22.'''

    def move(self, ...):
        '''@brief Moves the polygon. @args x,y

        Moves the polygon by the given offset and returns the  moved polygon. The polygon is
        overwritten.

        @param x The x distance to move the polygon. @param y The y distance to move the polygon.

        @return The moved polygon (self).'''

    def moved(self, ...):
        '''@brief Returns the moved polygon (does not modify self) @args x,y

        Moves the polygon by the given offset and returns the  moved polygon. The polygon is not
        modified.

        @param x The x distance to move the polygon. @param y The y distance to move the polygon.

        @return The moved polygon.

        This method has been introduced in version 0.23.'''

    def num_points(self, ...):
        '''@brief Get the number of points'''

    def perimeter(self, ...):
        '''@brief The perimeter of the polygon The perimeter is sum of the lengths of all edges
        making up the polygon.'''

    def point(self, ...):
        '''@brief Get a specific point of the contour@args p @param p The index of the point to get
        If the index of the point is not a valid index, a default value is returned. This method was
        introduced in version 0.18.'''

    def round_corners(self, ...):
        '''@brief Round the corners of the polygon @args rinner, router, n

        Replaces the corners of the polygon with circle segments.

        @param rinner The circle radius of inner corners (in database units). @param router The
        circle radius of outer corners (in database units). @param n The number of points per full
        circle.

        @return The new polygon.

        This method was introduced in version 0.22 for integer coordinates and in 0.25 for all
        coordinate types.'''

    def set_points(self, ...):
        '''@brief Set the points of the simple polygon

        @param pts An array of points to assign to the simple polygon @param raw If true, the points
        are taken as they are

        See the constructor description for details about raw mode.

        This method has been added in version 0.24.'''

    def split(self, ...):
        '''@brief Splits the polygon into two or more parts This method will break the polygon into
        parts. The exact breaking algorithm is unspecified, the result are smaller polygons of
        roughly equal number of points and 'less concave' nature. Usually the returned polygon set
        consists of two polygons, but there can be more. The merged region of the resulting polygons
        equals the original polygon with the exception of small snapping effects at new vertexes.

        The intended use for this method is a iteratively split polygons until the satisfy some
        maximum number of points limit.

        This method has been introduced in version 0.25.3.'''

    def to_dtype(self, ...):
        '''@brief Converts the polygon to a floating-point coordinate polygon

        The database unit can be specified to translate the integer-coordinate polygon into a
        floating-point coordinate polygon in micron units. The database unit is basically a scaling
        factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Convert to a string'''

    def touches(self, ...):
        '''@brief Returns true, if the polygon touches the other polygon. The polygons touch if they
        overlap or their contours share at least one point.

        This method was introduced in version 0.25.1.'''

    def transform(self, ...):
        '''@brief Transforms the simple polygon (in-place) @args t

        Transforms the simple polygon with the given transformation. Modifies self and returns self.
        An out-of-place version which does not modify self is \\transformed.

        @param t The transformation to apply.

        This method has been introduced in version 0.24.'''

    def transformed(self, ...):
        '''@brief Transforms the simple polygon. @args t

        Transforms the simple polygon with the given complex transformation. Does not modify the
        simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed'
        takes both simple and complex transformations.'''

    def transformed_cplx(self, ...):
        '''@brief Transforms the simple polygon. @args t

        Transforms the simple polygon with the given complex transformation. Does not modify the
        simple polygon but returns the transformed polygon.

        @param t The transformation to apply.

        @return The transformed simple polygon.

        With version 0.25, the original 'transformed_cplx' method is deprecated and 'transformed'
        takes both simple and complex transformations.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def ellipse(cls, ...):
        '''@brief Creates a simple polygon appoximating an ellipse

        @args box, n

        @param box The bounding box of the ellipse @param n The number of points that will be used
        to approximate the ellipse

        This method has been introduced in version 0.23.'''

    @classmethod
    def from_dpoly(cls, ...):
        '''@brief Creates an integer coordinate polygon from a floating-point coordinate polygon

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dpoly'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor converting a box to a polygon

        @args box

        @param box The box to convert to a polygon'''


class Technology:
    '''@brief Represents a technology

    This class represents one technology from a set of technologies. The set of technologies
    available in the system can be obtained with \\technology_names. Individual technology
    definitions are returned with \\technology_by_name. Use \\create_technology to register new
    technologies and \\remove_technology to delete technologies.

    The Technology class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the flag indicating whether to add other layers to the layer properties

     @brief Sets the flag indicating whether to add other layers to the layer properties'''
    add_other_layers = None

    '''@brief Gets the default database unit

    The default database unit is the one used when creating a layout for example.

    @brief Sets the default database unit'''
    dbu = None

    '''@brief Gets the default base path

    See \\base_path for details about the default base path.

     @hide'''
    default_base_path = None

    '''@brief Gets the description

    The technology description is shown to the user in technology selection dialogs and for display
    purposes.

    @brief Sets the description'''
    description = None

    '''@brief Gets the explicit base path

    See \\base_path for details about the explicit base path.

     @brief Sets the explicit base path

    See \\base_path for details about the explicit base path.'''
    explicit_base_path = None

    '''@brief Gets the path of the layer properties file

    If empty, no layer properties file is associated with the technology. If non-empty, this path
    will be corrected by the base path (see \\correct_path) and this layer properties file will be
    loaded for layouts with this technology.

    @brief Sets the path of the layer properties file

    See \\layer_properties_file for details about this property.'''
    layer_properties_file = None

    '''@brief Gets the layout reader options

    This method returns the layout reader options that are used when reading layouts with this
    technology.

    Change the reader options by modifying the object and using the setter to change it:

    @code opt = tech.load_layout_options opt.dxf_dbu = 2.5 tech.load_layout_options = opt @/code

     @brief Sets the layout reader options

    See \\load_layout_options for a description of this property.'''
    load_layout_options = None

    '''@brief Gets the name of the technology

    @brief Sets the name of the technology'''
    name = None

    '''@brief Gets the layout writer options

    This method returns the layout writer options that are used when writing layouts with this
    technology.

    Change the reader options by modifying the object and using the setter to change it:

    @code opt = tech.save_layout_options opt.dbu = 0.01 tech.save_layout_options = opt @/code

     @brief Sets the layout writer options

    See \\save_layout_options for a description of this property.'''
    save_layout_options = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def base_path(self, ...):
        '''@brief Gets the base path of the technology

        The base path is the effective path where files are read from if their file path is a
        relative one. If the explicit path is set (see \\explicit_base_path=), it is used. If not,
        the default path is used. The default path is the one from which a technology file was
        imported. The explicit one is the one that is specified explicitly with
        \\explicit_base_path=.'''

    def component(self, ...):
        '''@brief Gets the technology component with the given name The names are unique system
        identifiers. For all names, use \\component_names.'''

    def component_names(self, ...):
        '''@brief Gets the names of all components available for \\component'''

    def correct_path(self, ...):
        '''@brief Makes a file path relative to the base path if one is specified

        This method turns an absolute path into one relative to the base path. Only files below the
        base path will be made relative. Files above or beside won't be made relative.

        See \\base_path for details about the default base path.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def eff_layer_properties_file(self, ...):
        '''@brief Gets the effective path of the layer properties file'''

    def eff_path(self, ...):
        '''@brief Makes a file path relative to the base path if one is specified

        This method will return the actual path for a file from the file's path. If the input path
        is a relative one, it will be made absolute by using the base path.

        See \\base_path for details about the default base path.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def load(self, ...):
        '''@brief Loads the technology definition from a file'''

    def save(self, ...):
        '''@brief Saves the technology definition to a file'''

    def to_xml(self, ...):
        '''@brief Returns a XML representation of this technolog

        \\technology_from_xml can be used to restore the technology definition.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def create_technology(cls, ...):
        '''@brief Creates a new (empty) technology with the given name

        This method returns a reference to the new technology.'''

    @classmethod
    def has_technology(cls, ...):
        '''@brief Returns a value indicating whether there is a technology with this name'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''

    @classmethod
    def remove_technology(cls, ...):
        '''@brief Removes the technology with the given name'''

    @classmethod
    def technologies_from_xml(cls, ...):
        '''@brief Loads the technologies from a XML representation

        See \\technologies_to_xml for details. This method is the corresponding setter.'''

    @classmethod
    def technologies_to_xml(cls, ...):
        '''@brief Returns a XML representation of all technologies registered in the system

        \\technologies_from_xml can be used to restore the technology definitions. This method is
        provided mainly as a substitute for the pre-0.25 way of accessing technology data through
        the 'technology-data' configuration parameter. This method will return the equivalent
        string.'''

    @classmethod
    def technology_by_name(cls, ...):
        '''@brief Gets the technology object for a given name'''

    @classmethod
    def technology_from_xml(cls, ...):
        '''@brief Loads the technology from a XML representation

        See \\technology_to_xml for details.'''

    @classmethod
    def technology_names(cls, ...):
        '''@brief Gets a list of technology names defined in the system'''


class TechnologyComponent:
    '''@brief A part of a technology definition Technology components extend technology definitions
    (class \\Technology) by specialized subfeature definitions. For example, the net tracer supplies
    it's technology-dependent specification through a technology component called
    \\NetTracerTechnology.

    Components are managed within technologies and can be accessed from a technology using
    \\Technology#component.

    This class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def description(self, ...):
        '''@brief Gets the human-readable description string of the technology component'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def name(self, ...):
        '''@brief Gets the formal name of the technology component This is the name by which the
        component can be obtained from a technology using \\Technology#component.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Text:
    '''@brief A text object

    A text object has a point (location), a text, a text transformation, a text size and a font id.
    Text size and font id are provided to be be able to render the text correctly. Text objects are
    used as labels (i.e. for pins) or to indiciate a particular position.

    The \\Text class uses integer coordinates. A class that operates with floating-point coordinates
    is \\DText.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Get the font number

     @brief Set the font number @args f'''
    font = None

    '''@brief Get the horizontal alignment

    See \\halign= for a description of this property.

     @brief Set the horizontal alignment @args a

    This property specifies how the text is aligned relative to the anchor point. Allowed values for
    this property are 0 (left), 1 (center) and 2 (right). This property has been introduced in
    version 0.22.'''
    halign = None

    '''@brief Get the text height

     @brief Set the text height of this object @args s'''
    size = None

    '''@brief Get the text string

     @brief Assign a text string to this object @args text'''
    string = None

    '''@brief Get the transformation

     @brief Assign a transformation (text position and orientation) to this object @args t'''
    trans = None

    '''@brief Get the vertical alignment

    See \\valign= for a description of this property.

     @brief Set the vertical alignment @args a

    This property specifies how the text is aligned relative to the anchor point. Allowed values for
    this property are 0 (top), 1 (center) and 2 (bottom). This property has been introduced in
    version 0.22.'''
    valign = None

    '''@brief Gets the x location of the text

    This method has been introduced in version 0.23.

     @brief Sets the x location of the text @args x

    This method has been introduced in version 0.23.'''
    x = None

    '''@brief Gets the y location of the text

    This method has been introduced in version 0.23.

     @brief Sets the y location of the text @args y

    This method has been introduced in version 0.23.'''
    y = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality

        @args text

        Return true, if this text object and the given text are equal '''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given text object. This method
        enables texts as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor with string, transformation, text height and font

        @args string, trans, height, font

        A string and a transformation is provided to this constructor. The transformation specifies
        the location and orientation of the text object. In addition, the text height and font can
        be specified.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Less operator @args t @param t The object to compare against This operator is
        provided to establish some, not necessarily a certain sorting order'''

    def __ne__(self, ...):
        '''@brief Inequality

        @args text

        Return true, if this text object and the given text are not equal '''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief Convert to a string'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief Convert to a string'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given text object. This method
        enables texts as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def move(self, ...):
        '''@brief Moves the text by a certain distance (modifies self)

        @args dx, dy

        Moves the text by a given distance in x and y direction and returns the moved text. Does not
        check for coordinate overflows.

        @param dx The x distance to move the text. @param dy The y distance to move the text.

        @return A reference to this text object

        This method was introduced in version 0.23.'''

    def moved(self, ...):
        '''@brief Returns the text moved by a certain distance (does not modify self)

        @args dx, dy

        Moves the text by a given offset and returns the moved text. Does not modify *this. Does not
        check for coordinate overflows.

        @param dx The x distance to move the text. @param dy The y distance to move the text.

        @return The moved text.

        This method was introduced in version 0.23.'''

    def to_dtype(self, ...):
        '''@brief Converts the text to a floating-point coordinate text The database unit can be
        specified to translate the integer-coordinate text into a floating-point coordinate text in
        micron units. The database unit is basically a scaling factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief Convert to a string'''

    def transformed(self, ...):
        '''@brief Transform the text with the given complex transformation

        @args t

        @param t The magnifying transformation to apply @return The transformed text (a DText
        now)'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor with string, transformation, text height and font

        @args string, trans, height, font

        A string and a transformation is provided to this constructor. The transformation specifies
        the location and orientation of the text object. In addition, the text height and font can
        be specified.'''


class TextGenerator:
    '''@brief A text generator class

    A text generator is basically a way to produce human-readable text for labelling layouts. It's
    similar to the Basic.TEXT PCell, but more convenient to use in a scripting context.

    Generators can be constructed from font files (or resources) or one of the registered generators
    can be used.

    To create a generator from a font file proceed this way: @code gen = RBA::TextGenerator::new
    gen.load_from_file("myfont.gds") region = gen.text("A TEXT", 0.001) @/code

    This code produces a RBA::Region with a database unit of 0.001 micron. This region can be fed
    into a \\Shapes container to place it into a cell for example.

    By convention the font files must have two to three layers:

    @ul @li 1/0 for the actual data @/li @li 2/0 for the borders @/li @li 3/0 for an optional
    additional background @/li @/ul

    Currently, all glyphs must be bottom-left aligned at 0, 0. The border must be drawn in at least
    one glyph cell. The border is taken as the overall bbox of all borders.

    The glyph cells must be named with a single character or "nnn" where "d" is the ASCII code of
    the character (i.e. "032" for space). Allowed ASCII codes are 32 through 127. If a lower-case
    "a" character is defined, lower-case letters are supported. Otherwise, lowercase letters are
    mapped to uppercase letters.

    Undefined characters are left blank in the output.

    A comment cell can be defined ("COMMENT") which must hold one text in layer 1 stating the
    comment, and additional descriptions such as line width:

    @ul @li "line_width=<x>": Specifies the intended line width in micron units @/li @li
    "design_grid=<x>": Specifies the intended design grid in micron units @/li @li any other text:
    The description string @/li @/ul

    Generators can be picked form a list of predefined generator. See \\generators,
    \\default_generator and \\generator_by_name for picking a generator from the list.

    This class has been introduced in version 0.25. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def background(self, ...):
        '''@brief Gets the background rectangle of each glyph in the generator's database units The
        background rectangle is the one that is used as background for inverted rendering. A version
        that delivers this value in micrometer units is \\dbackground.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def dbackground(self, ...):
        '''@brief Gets the background rectangle in micron units The background rectangle is the one
        that is used as background for inverted rendering.'''

    def dbu(self, ...):
        '''@brief Gets the basic database unit the design of the glyphs was made This database unit
        the basic resolution of the glyphs.'''

    def ddesign_grid(self, ...):
        '''@brief Gets the design grid of the glyphs in micron units The design grid is the basic
        grid used when designing the glyphs. In most cases this grid is bigger than the database
        unit. '''

    def description(self, ...):
        '''@brief Gets the description text of the generator The generator's description text is a
        human-readable text that is used to identify the generator (aka 'font') in user
        interfaces.'''

    def design_grid(self, ...):
        '''@brief Gets the design grid of the glyphs in the generator's database units The design
        grid is the basic grid used when designing the glyphs. In most cases this grid is bigger
        than the database unit. A version that delivers this value in micrometer units is
        \\ddesign_grid.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dheight(self, ...):
        '''@brief Gets the design height of the glyphs in micron units The height is the height of
        the rectangle occupied by each character. '''

    def dline_width(self, ...):
        '''@brief Gets the line width of the glyphs in micron units The line width is the intended
        (not necessarily precisely) line width of typical character lines (such as the bar of an
        'I').'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def dwidth(self, ...):
        '''@brief Gets the design width of the glyphs in micron units The width is the width of the
        rectangle occupied by each character. '''

    def glyph(self, ...):
        '''@brief Gets the glyph of the given character as a region The region represents the
        glyph's outline and is deliverd in the generator's database units .A more elaborate way to
        getting the text's outline is \\text.'''

    def height(self, ...):
        '''@brief Gets the design height of the glyphs in the generator's database units The height
        is the height of the rectangle occupied by each character. A version that delivers this
        value in micrometer units is \\dheight.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def line_width(self, ...):
        '''@brief Gets the line width of the glyphs in the generator's database units The line width
        is the intended (not necessarily precisely) line width of typical character lines (such as
        the bar of an 'I'). A version that delivers this value in micrometer units is
        \\dline_width.'''

    def load_from_file(self, ...):
        '''@brief Loads the given file into the generator See the description of the class how the
        layout data is read.'''

    def name(self, ...):
        '''@brief Gets the name of the generator The generator's name is the basic key by which the
        generator is identified.'''

    def text(self, ...):
        '''@brief Gets the rendered text as a region @param text The text string @param target_dbu
        The database unit for which to produce the text @param mag The magnification (1.0 for
        original size) @param inv inverted rendering: if true, the glyphs are rendered inverse with
        the background box as the outer bounding box @param bias An additional bias to be applied
        (happens before inversion, can be negative) @param char_spacing Additional space between
        characters (in micron units) @param line_spacing Additional space between lines (in micron
        units) Various options can be specified to control the appearance of the text. See the
        description of the parameters. It's important to specify the target database unit in
        \\target_dbu to indicate what database unit shall be used to create the output for.'''

    def width(self, ...):
        '''@brief Gets the design height of the glyphs in the generator's database units The width
        is the width of the rectangle occupied by each character. A version that delivers this value
        in micrometer units is \\dwidth.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def default_generator(cls, ...):
        '''@brief Gets the default text generator (a standard font) This method delivers the default
        generator or nil if no such generator is installed.'''

    @classmethod
    def generator_by_name(cls, ...):
        '''@brief Gets the text generator for a given name This method delivers the generator with
        the given name or nil if no such generator is registered.'''

    @classmethod
    def generators(cls, ...):
        '''@brief Gets the generators registered in the system This method delivers a list of
        generator objects that can be used to create texts.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class TileOutputReceiver:
    '''@brief A receiver abstraction for the tiling processor.

    The tiling processor (\\TilingProcessor) is a framework for executing sequences of operations on
    tiles of a layout or multiple layouts. The \\TileOutputReceiver class is used to specify an
    output channel for the tiling processor. See \\TilingProcessor#output for more details.

    This class has been introduced in version 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def processor(self, ...):
        '''@brief Gets the processor the receiver is attached to

        This attribute is set before begin and can be nil if the receiver is not attached to a
        processor.

        This method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class TileOutputReceiverBase:
    '''@hide @alias TileOutputReceiver '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def processor(self, ...):
        '''@brief Gets the processor the receiver is attached to

        This attribute is set before begin and can be nil if the receiver is not attached to a
        processor.

        This method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class TilingProcessor:
    '''@brief A processor for layout which distributes tasks over tiles

    The tiling processor executes one or several scripts on one or multiple layouts providing a
    tiling scheme. In that scheme, the processor divides the original layout into rectangular tiles
    and executes the scripts on each tile separately. The tiling processor allows to specify
    multiple, independent scripts which are run separately on each tile. It can make use of multi-
    core CPU's by supporting multiple threads running the tasks in parallel (with respect to tiles
    and scripts).

    Tiling a optional - if no tiles are specified, the tiling processing basically operates flat and
    parallelization extends to the scripts only.

    Tiles can be overlapping to gather input from neighboring tiles into the current tile. In order
    to provide that feature, a border can be specified which gives the amount by which the search
    region is extended beyond the border of the tile. To specify the border, use the
    \\TilingProcessor#tile_border method.

    The basis of the tiling processor are \\Region objects and expressions. Expressions are a built-
    in simple language to form simple scripts. Expressions allow access to the objects and methods
    built into KLayout. Each script can consist of multiple operations. Scripts are specified using
    \\TilingProcessor#queue.

    Input is provided to the script through variables holding a \\Region object each. From outside
    the tiling processor, input is specified with the \\TilingProcessor#input method. This method is
    given a name and a \\RecursiveShapeIterator object which delivers the data for the input. On the
    script side, a \\Region object is provided through a variable named like the first argument of
    the "input" method.

    Inside the script the following functions are provided:

    @ul @li"_dbu" delivers the database unit used for the computations @/li @li"_tile" delivers a
    region containing a mask for the tile (a rectangle) or nil if no tiling is used @/li
    @li"_output" is used to deliver output (see below) @/li @/ul

    Output can be obtained from the tiling processor by registering a receiver with a channel. A
    channel is basically a name. Inside the script, the name describes a variable which can be used
    as the first argument of the "_output" function to identify the channel. A channel is registers
    using the \\TilingProcessor#output method. Beside the name, a receiver must be specified. A
    receiver is either another layout (a cell of that), a report database or a custom receiver
    implemented through the \\TileOutputReceiver class.

    The "_output" function expects two or three parameters: one channel id (the variable that was
    defined by the name given in the output method call) and an object to output (a \\Region,
    \\Edges, \\EdgePairs or a geometrical primitive such as \\Polygon or \\Box). In addition, a
    boolean argument can be given indicating whether clipping at the tile shall be applied. If
    clipping is requested (the default), the shapes will be clipped at the tile's box.

    The tiling can be specified either through a tile size, a tile number or both. If a tile size is
    specified with the \\TilingProcessor#tile_size method, the tiling processor will compute the
    number of tiles required. If the tile count is given (through \\TilingProcessor#tiles), the tile
    size will be computed. If both are given, the tiling array is fixed and the array is centered
    around the original layout's center. If the tiling origin is given as well, the tiling processor
    will use the given array without any modifications.

    Once the tiling processor has been set up, the operation can be launched using
    \\TilingProcessor#execute.

    This is some sample code. It performs two XOR operations between two layouts and delivers the
    results to a report database:

    @code ly1 = ... # first layout ly2 = ... # second layout

    rdb = RBA::ReportDatabase::new("xor") output_cell = rdb.create_cell(ly1.top_cell.name)
    output_cat1 = rbd.create_category("XOR 1-10") output_cat2 = rbd.create_category("XOR 2-11")

    tp = RBA::TilingProcessor::new tp.input("a1", ly1, ly1.top_cell.cell_index,
    RBA::LayerInfo::new(1, 0)) tp.input("a2", ly1, ly1.top_cell.cell_index, RBA::LayerInfo::new(2,
    0)) tp.input("b1", ly2, ly2.top_cell.cell_index, RBA::LayerInfo::new(11, 0)) tp.input("b2", ly2,
    ly2.top_cell.cell_index, RBA::LayerInfo::new(12, 0)) tp.output("o1", rdb, output_cell,
    output_cat1) tp.output("o2", rdb, output_cell, output_cat2) tp.queue("_output(o1, a1 ^ b1)")
    tp.queue("_output(o2, a2 ^ b2)") tp.tile_size(50.0, 50.0) tp.execute("Job description") @/code

    This class has been introduced in version 0.23. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the database unit under which the computations will be done

     @brief Sets the database unit under which the computations will be done @args u

    All data used within the scripts will be brought to that database unit. If none is given it will
    be the database unit of the first layout given or 1nm if no layout is specified.'''
    dbu = None

    '''@brief Sets the layout frame @args frame

    The layout frame is the box (in micron units) taken into account for computing the tiles if the
    tile counts are not given. If the layout frame is not set or set to an empty box, the processor
    will try to derive the frame from the given inputs.

    This method has been introduced in version 0.25.'''
    frame = None

    '''@brief Gets a valid indicating whether automatic scaling to database unit is enabled

    This method has been introduced in version 0.23.2.

    @brief Enables or disabled automatic scaling to database unit @args en

    If automatic scaling to database unit is enabled, the input is automatically scaled to the
    database unit set inside the tile processor. This is the default.

    This method has been introduced in version 0.23.2.'''
    scale_to_dbu = None

    '''@brief Gets the number of threads to use

     @brief Specifies the number of threads to use @args n'''
    threads = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''Return self==value.'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''Return hash(self).'''

    def __init__(self, ...):
        '''@brief Creates a new object of this class'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''Return self<value.'''

    def __ne__(self, ...):
        '''Return self!=value.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''Return repr(self).'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''Return str(self).'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def execute(self, ...):
        '''@brief Runs the job @args desc

        This method will initiate execution of the queued scripts, once for every tile. The desc is
        a text shown in the progress bar for example.'''

    def input(self, ...):
        '''@brief Specifies input for the tiling processor @args name, edges, trans This method will
        establish an input channel for the processor. This version receives input from an \\Edges
        object. Edge collections don't always come with a database unit, hence a database unit
        should be specified with the \\dbu= method if only regions and edges are used as input.

        The name specifies the variable under which the input can be used in the scripts. This
        variant allows to specify an additional transformation too. It has been introduced in
        version 0.23.2.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def output(self, ...):
        '''@brief Specifies output to single value @args name, sum This method will establish an
        output channel which sums up float data delivered by calling the _output function. In order
        to specify the target for the data, a \\Value object must be provided for the "sum"
        parameter.

        The name is the name which must be used in the _output function of the scripts in order to
        address that channel.'''

    def queue(self, ...):
        '''@brief Queues a script for parallel execution @args script

        With this method, scripts are registered that are executed in parallel on each tile. The
        scripts have "Expressions" syntax and can make use of several predefined variables and
        functions. See the \\TilingProcessor class description for details.'''

    def tile_border(self, ...):
        '''@brief Sets the tile border @args bx, by

        Specifies the tile border. The border is a margin that is considered when fetching shapes.
        By specifying a border you can fetch shapes into the tile's data which are outside the tile
        but still must be considered in the computations (i.e. because they might grow into the
        tile).

        The tile border is given in micron.'''

    def tile_origin(self, ...):
        '''@brief Sets the tile origin @args xo, yo

        Specifies the origin (lower left corner) of the tile field. If no origin is specified, the
        tiles are centered to the layout's bounding box. Giving the origin together with the tile
        count and dimensions gives full control over the tile array.

        The tile origin is given in micron.'''

    def tile_size(self, ...):
        '''@brief Sets the tile size @args w, h

        Specifies the size of the tiles to be used. If no tile size is specified, tiling won't be
        used and all computations will be done on the whole layout.

        The tile size is given in micron.'''

    def tiles(self, ...):
        '''@brief Sets the tile count @args nw, nh

        Specifies the number of tiles to be used. If no tile number is specified, the number of
        tiles required is computed from the layout's dimensions and the tile size. If a number is
        given, but no tile size, the tile size will be computed from the layout's dimensions.'''

    def var(self, ...):
        '''@brief Defines a variable for the tiling processor script @args name, value

        The name specifies the variable under which the value can be used in the scripts.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a new object of this class'''


class Trans:
    '''@brief A simple transformation

    Simple transformations only provide rotations about angles which a multiples of 90 degree.
    Together with the mirror options, this results in 8 distinct orientations (fixpoint
    transformations). These can be combined with a displacement which is applied after the
    rotation/mirror. This version acts on integer coordinates. A version for floating-point
    coordinates is \\DTrans.

    Here are some examples for using the Trans class:

    @code t = RBA::Trans::new(0, 100)  # displacement by 100 DBU in y direction # the inverse: ->
    "r0 0,-100" t.inverted.to_s # concatenation: -> "r90 -100,0" (RBA::Trans::R90 * t).to_s # apply
    to a point: -> "0,100" RBA::Trans::R90.trans(RBA::Point::new(100, 0)) @/code

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the angle in units of 90 degree

    This value delivers the rotation component. In addition, a mirroring at the x axis may be
    applied before if the \\is_mirror? property is true.

    @brief Sets the angle in units of 90 degree @param a The new angle

    This method was introduced in version 0.20.'''
    angle = None

    '''@brief Gets to the displacement vector

    Staring with version 0.25 the displacement type is a vector.

    @brief Sets the displacement @param u The new displacement

    This method was introduced in version 0.20. Staring with version 0.25 the displacement type is a
    vector.'''
    disp = None

    '''@brief Sets the mirror flag "mirroring" describes a reflection at the x-axis which is
    included in the transformation prior to rotation.@param m The new mirror flag

    This method was introduced in version 0.20.'''
    mirror = None

    '''@brief Gets the angle/mirror code

    The angle/mirror code is one of the constants R0, R90, R180, R270, M0, M45, M90 and M135. rx is
    the rotation by an angle of x counter clockwise. mx is the mirroring at the axis given by the
    angle x (to the x-axis).

    @brief Sets the angle/mirror code @param r The new angle/rotation code (see \\rot property)

    This method was introduced in version 0.20.'''
    rot = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Tests for equality'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a transformation using a displacement given as two coordinates

        @param x The horizontal displacement @param y The vertical displacement'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Provides a 'less' criterion for sorting This method is provided to implement a
        sorting order. The definition of 'less' is opaque and might change in future versions.'''

    def __mul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __ne__(self, ...):
        '''@brief Tests for inequality'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def ctrans(self, ...):
        '''@brief Transforms a distance

        The "ctrans" method transforms the given distance. e = t(d). For the simple transformations,
        there is no magnification and no modification of the distance therefore.

        @param d The distance to transform @return The transformed distance'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def invert(self, ...):
        '''@brief Inverts the transformation (in place)

        Inverts the transformation and replaces this object by the inverted one.

        @return The inverted transformation'''

    def inverted(self, ...):
        '''@brief Returns the inverted transformation Returns the inverted transformation

        @return The inverted transformation'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mirror(self, ...):
        '''@brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis
        followed by a rotation by the angle given by the \\angle property. '''

    def to_dtype(self, ...):
        '''@brief Converts the transformation to a floating-point coordinate transformation

        The database unit can be specified to translate the integer-coordinate transformation into a
        floating-point coordinate transformation in micron units. The database unit is basically a
        scaling factor.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def trans(self, ...):
        '''@brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform @return The transformed text

        This convenience method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_dtrans(cls, ...):
        '''@brief Creates an integer coordinate transformation from a floating-point coordinate
        transformation

        This constructor has been introduced in version 0.25 and replaces the previous static method
        'from_dtrans'.'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates a transformation from a string Creates the object from a string
        representation (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a transformation using a displacement given as two coordinates

        @param x The horizontal displacement @param y The vertical displacement'''


class VCplxTrans:
    '''@brief A complex transformation

    A complex transformation provides magnification, mirroring at the x-axis, rotation by an
    arbitary angle and a displacement. This is also the order, the operations are applied. This
    version can transform floating point coordinate objects into integer coordinate objects, which
    may involve rounding and can be inexact.

    Complex transformations are extensions of the simple transformation classes (\\Trans in that
    case) and behave similar.

    Transformations can be used to transform points or other objects. Transformations can be
    combined with the '*' operator to form the transformation which is equivalent to applying the
    second and then the first. Here is some code:

    @code # Create a transformation that applies a magnication of 1.5, a rotation by 90 degree # and
    displacement of 10 in x and 20 units in y direction: t = RBA::VCplxTrans::new(1.5, 90, false,
    10, 20) t.to_s            # r90 *1.5 10,20 # compute the inverse: t.inverted.to_s   # r270
    *0.666666667 -13,7 # Combine with another displacement (applied after that):
    (RBA::VCplxTrans::new(5, 5) * t).to_s     # r90 *1.5 15,25 # Transform a point:
    t.trans(RBA::DPoint::new(100, 200)).to_s  # -290,170 @/code

    The VCplxTrans type is the inverse transformation of the CplxTrans transformation and vice
    versa.Transformations of VCplxTrans type can be concatenated (operator *) with either itself or
    with transformations of compatible input or output type. This means, the operator VCplxTrans *
    CplxTrans is allowed (output types of CplxTrans and input of VCplxTrans are identical) while
    VCplxTrans * ICplxTrans is not.

    This class has been introduced in version 0.25.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Gets the angle

    Note that the simple transformation returns the angle in units of 90 degree. Hence for a simple
    trans (i.e. \\Trans), a rotation angle of 180 degree delivers a value of 2 for the angle
    attribute. The complex transformation, supporting any rotation angle returns the angle in
    degree.

    @return The rotation angle this transformation provides in degree units (0..360 deg).

     @brief Sets the angle @param a The new angle See \\angle for a description of that
    attribute.'''
    angle = None

    '''@brief Gets the displacement

     @brief Sets the displacement @param u The new displacement'''
    disp = None

    '''@brief Gets the magnification

     @brief Sets the magnification @args m @param m The new magnification'''
    mag = None

    '''@brief Sets the mirror flag "mirroring" describes a reflection at the x-axis which is
    included in the transformation prior to rotation.@param m The new mirror flag'''
    mirror = None

    # Methods
    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Tests for equality'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis, rotation, application of
        displacement.

        @param mag The magnification @param rot The rotation angle in units of degree @param mirrx
        True, if mirrored at x axis @param x The x displacement @param y The y displacement'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief Provides a 'less' criterion for sorting This method is provided to implement a
        sorting order. The definition of 'less' is opaque and might change in future versions.'''

    def __mul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __ne__(self, ...):
        '''@brief Tests for inequality'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Returns the concatenated transformation

        The * operator returns self*t ("t is applied before this transformation").

        @param t The transformation to apply before @return The modified transformation'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def ctrans(self, ...):
        '''@brief Transforms a distance

        The "ctrans" method transforms the given distance. e = t(d). For the simple transformations,
        there is no magnification and no modification of the distance therefore.

        @param d The distance to transform @return The transformed distance'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given transformation. This
        method enables transformations as hash keys.

        This method has been introduced in version 0.25.'''

    def invert(self, ...):
        '''@brief Inverts the transformation (in place)

        Inverts the transformation and replaces this transformation by it's inverted one.

        @return The inverted transformation'''

    def inverted(self, ...):
        '''@brief Returns the inverted transformation

        Returns the inverted transformation. This method does not modify the transformation.

        @return The inverted transformation'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def is_mag(self, ...):
        '''@brief Test, if the transformation is a magnifying one

        This is the recommended test for checking if the transformation represents a
        magnification.'''

    def is_mirror(self, ...):
        '''@brief Gets the mirror flag

        If this property is true, the transformation is composed of a mirroring at the x-axis
        followed by a rotation by the angle given by the \\angle property. '''

    def is_ortho(self, ...):
        '''@brief Tests, if the transformation is an orthogonal transformation

        If the rotation is by a multiple of 90 degree, this method will return true.'''

    def is_unity(self, ...):
        '''@brief Tests, whether this is a unit transformation'''

    def rot(self, ...):
        '''@brief Returns the respective simple transformation equivalent rotation code if possible

        If this transformation is orthogonal (is_ortho () == true), then this method will return the
        corresponding fixpoint transformation, not taking into account magnification and
        displacement. If the transformation is not orthogonal, the result reflects the quadrant the
        rotation goes into.'''

    def s_trans(self, ...):
        '''@brief Extracts the simple transformation part

        The simple transformation part does not reflect magnification or arbitrary angles. Rotation
        angles are rounded down to multiples of 90 degree. Magnification is fixed to 1.0.'''

    def to_itrans(self, ...):
        '''@brief Converts the transformation to another transformation with floating-point output
        coordinates

        The database unit can be specified to translate the integer coordinate displacement in
        database units to a floating-point displacement in micron units. The displacement's'
        coordinates will be multiplied with the database unit.

        This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def to_trans(self, ...):
        '''@brief Converts the transformation to another transformation with integer input
        coordinates

        This method has been introduced in version 0.25.'''

    def to_vtrans(self, ...):
        '''@brief Converts the transformation to another transformation with integer input and
        floating-point output coordinates

        The database unit can be specified to translate the integer coordinate displacement in
        database units to an floating-point displacement in micron units. The displacement's'
        coordinates will be multiplied with the database unit.

        This method has been introduced in version 0.25.'''

    def trans(self, ...):
        '''@brief Transforms a text

        't*text' or 't.trans(text)' is equivalent to text.transformed(t).

        @param text The text to transform @return The transformed text

        This convenience method has been introduced in version 0.25.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string Creates the object from a string representation
        (as returned by \\to_s)

        This method has been added in version 0.23.'''

    @classmethod
    def new(cls, ...):
        '''@brief Creates a transformation using magnification, angle, mirror flag and displacement

        The sequence of operations is: magnification, mirroring at x axis, rotation, application of
        displacement.

        @param mag The magnification @param rot The rotation angle in units of degree @param mirrx
        True, if mirrored at x axis @param x The x displacement @param y The y displacement'''


class Vector:
    '''@brief A integer vector class A vector is a distance in cartesian, 2 dimensional space. A
    vector is given by two coordinates (x and y) and represents the distance between two points.
    Being the distance, transformations act differently on vectors: the displacement is not applied.
    Vectors are not geometrical objects by itself. But they are frequently used in the database API
    for various purposes.

    This class has been introduced in version 0.25.

    See @<a href="/programming/database_api.xml">The Database API@</a> for more details about the
    database objects. '''
    # Attributes
    '''list of weak references to the object (if defined)'''
    __weakref__ = None

    '''@brief Accessor to the x coordinate

     @brief Write accessor to the x coordinate @args coord'''
    x = None

    '''@brief Accessor to the y coordinate

     @brief Write accessor to the y coordinate @args coord'''
    y = None

    # Methods
    def __add__(self, ...):
        '''@brief Adds a vector and a point

        @args p

        Returns the point p shifted by the vector.'''

    def __delattr__(self, ...):
        '''Implement delattr(self, name).'''

    def __dir__(self, ...):
        '''Default dir() implementation.'''

    def __eq__(self, ...):
        '''@brief Equality test operator

        @args v'''

    def __format__(self, ...):
        '''Default object formatter.'''

    def __ge__(self, ...):
        '''Return self>=value.'''

    def __getattribute__(self, ...):
        '''Return getattr(self, name).'''

    def __gt__(self, ...):
        '''Return self>value.'''

    def __hash__(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given vector. This method
        enables vectors as hash keys.

        This method has been introduced in version 0.25.'''

    def __init__(self, ...):
        '''@brief Constructor for a vector from two coordinate values

        @args x, y'''

    def __itruediv__(self, ...):
        '''@brief Division by some divisor

        @args d

        Divides the object in place. All coordinates are divided with the given divisor and if
        necessary rounded.'''

    def __le__(self, ...):
        '''Return self<=value.'''

    def __lt__(self, ...):
        '''@brief "less" comparison operator

        @args v

        This operator is provided to establish a sorting order'''

    def __mul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __ne__(self, ...):
        '''@brief Inequality test operator

        @args v'''

    def __neg__(self, ...):
        '''@brief Compute the negative of a vector

        @args p

        Returns a new vector with -x,-y.'''

    def __reduce__(self, ...):
        '''Helper for pickle.'''

    def __reduce_ex__(self, ...):
        '''Helper for pickle.'''

    def __repr__(self, ...):
        '''@brief String conversion'''

    def __rmul__(self, ...):
        '''@brief Scaling by some factor

        @args f

        Returns the scaled object. All coordinates are multiplied with the given factor and if
        necessary rounded.'''

    def __setattr__(self, ...):
        '''Implement setattr(self, name, value).'''

    def __sizeof__(self, ...):
        '''Size of object in memory, in bytes.'''

    def __str__(self, ...):
        '''@brief String conversion'''

    def __sub__(self, ...):
        '''@brief Subtract two vectors

        @args v

        Subtract vector v from self by subtracting the coordinates.'''

    def __truediv__(self, ...):
        '''@brief Division by some divisor

        @args d

        Returns the scaled object. All coordinates are divided with the given divisor and if
        necessary rounded.'''

    def _create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def _destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def _destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def _is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def _manage(self, ...):
        '''@brief Marks the object as managed by the script side. After calling this method on an
        object, the script side will be responsible for the management of the object. This method
        may be called if an object is returned from a C++ function and the object is known not to be
        owned by any C++ instance. If necessary, the script side may delete the object if the
        script's reference is no longer required.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def _unmanage(self, ...):
        '''@brief Marks the object as no longer owned by the script side. Calling this method will
        make this object no longer owned by the script's memory management. Instead, the object must
        be managed in some other way. Usually this method may be called if it is known that some C++
        object holds and manages this object. Technically speaking, this method will turn the
        script's reference into a weak reference. After the script engine decides to delete the
        reference, the object itself will still exist. If the object is not managed otherwise,
        memory leaks will occur.

        Usually it's not required to call this method. It has been introduced in version 0.24.'''

    def abs(self, ...):
        '''@brief Returns the length of the vector 'abs' is an alias provided for compatibility with
        the former point type.'''

    def assign(self, ...):
        '''@brief Assigns another object to self @args other'''

    def create(self, ...):
        '''@brief Ensures the C++ object is created Use this method to ensure the C++ object is
        created, for example to ensure that resources are allocated. Usually C++ objects are created
        on demand and not necessarily when the script object is created.'''

    def destroy(self, ...):
        '''@brief Explicitly destroys the object Explicitly destroys the object on C++ side if it
        was owned by the script interpreter. Subsequent access to this object will throw an
        exception. If the object is not owned by the script, this method will do nothing.'''

    def destroyed(self, ...):
        '''@brief Returns a value indicating whether the object was already destroyed This method
        returns true, if the object was destroyed, either explicitly or by the C++ side. The latter
        may happen, if the object is owned by a C++ object which got destroyed itself.'''

    def dup(self, ...):
        '''@brief Creates a copy of self'''

    def hash(self, ...):
        '''@brief Computes a hash value Returns a hash value for the given vector. This method
        enables vectors as hash keys.

        This method has been introduced in version 0.25.'''

    def is_const_object(self, ...):
        '''@brief Returns a value indicating whether the reference is a const reference This method
        returns true, if self is a const reference. In that case, only const methods may be called
        on self.'''

    def length(self, ...):
        '''@brief Returns the length of the vector 'abs' is an alias provided for compatibility with
        the former point type.'''

    def sprod(self, ...):
        '''@brief Computes the scalar product between self and the given vector

        @args v

        The scalar product of a and b is defined as: vp = ax*bx+ay*by.'''

    def sprod_sign(self, ...):
        '''@brief Computes the scalar product between self and the given vector and returns a value
        indicating the sign of the product

        @args v

        @return 1 if the scalar product is positive, 0 if it is zero and -1 if it is negative.'''

    def sq_abs(self, ...):
        '''@brief The square length of the vector 'sq_abs' is an alias provided for compatibility
        with the former point type.'''

    def sq_length(self, ...):
        '''@brief The square length of the vector 'sq_abs' is an alias provided for compatibility
        with the former point type.'''

    def to_dtype(self, ...):
        '''@brief Converts the vector to a floating-point coordinate vector The database unit can be
        specified to translate the integer-coordinate vector into a floating-point coordinate vector
        in micron units. The database unit is basically a scaling factor.'''

    def to_p(self, ...):
        '''@brief Turns the vector into a point This method returns the point resulting from adding
        the vector to (0,0). This method has been introduced in version 0.25.'''

    def to_s(self, ...):
        '''@brief String conversion'''

    def vprod(self, ...):
        '''@brief Computes the vector product between self and the given vector

        @args v

        The vector product of a and b is defined as: vp = ax*by-ay*bx.'''

    def vprod_sign(self, ...):
        '''@brief Computes the vector product between self and the given vector and returns a value
        indicating the sign of the product

        @args v

        @return 1 if the vector product is positive, 0 if it is zero and -1 if it is negative.'''

    Static Methods
    @classmethod
    def __init_subclass__(cls, ...):
        '''This method is called when a class is subclassed.

        The default implementation does nothing. It may be overridden to extend subclasses.'''

    @classmethod
    def __new__(cls, ...):
        '''Create and return a new object.  See help(type) for accurate signature.'''

    @classmethod
    def __subclasshook__(cls, ...):
        '''Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or
        NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).'''

    @classmethod
    def from_s(cls, ...):
        '''@brief Creates an object from a string @args s Creates the object from a string
        representation (as returned by \\to_s)'''

    @classmethod
    def new(cls, ...):
        '''@brief Constructor for a vector from two coordinate values

        @args x, y'''


